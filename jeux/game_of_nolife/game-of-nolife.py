# https://i.postimg.cc/d0LqYYGp/game-of-nolife-tileset.png (old)
# https://i.postimg.cc/fy9MD0gh/game-of-nolife-tileset.png


"""
{
  "game_area": {
    "nb_tile_width": 60,
    "nb_tile_height": 38
  },
  "tile_size": 4,

  "img_coords": {
    "red_01": [0, 0],
    "red_02": [4, 0],
    "red_03": [8, 0],
    "red_04": [12, 0],
    "red_05": [16, 0],
    "red_06": [20, 0],
    "red_07": [24, 0],
    "red_08": [28, 0],
    "red_09": [32, 0],
    "red_10": [36, 0],
    "red_11": [40, 0],
    "red_12": [44, 0],
    "red_13": [48, 0],
    "red_14": [52, 0],
    "red_15": [56, 0],
    "red_16": [60, 0],
    "red_town_1x1": [68, 0],
    "red_town_2x2_00": [64, 12],
    "red_town_2x2_10": [68, 12],
    "red_town_2x2_01": [64, 16],
    "red_town_2x2_11": [68, 16],
    "red_town_4x4_00": [0, 16],
    "red_town_4x4_10": [4, 16],
    "red_town_4x4_20": [8, 16],
    "red_town_4x4_30": [12, 16],
    "red_town_4x4_01": [0, 20],
    "red_town_4x4_11": [4, 20],
    "red_town_4x4_21": [8, 20],
    "red_town_4x4_31": [12, 20],
    "red_town_4x4_02": [0, 24],
    "red_town_4x4_12": [4, 24],
    "red_town_4x4_22": [8, 24],
    "red_town_4x4_32": [12, 24],
    "red_town_4x4_03": [0, 28],
    "red_town_4x4_13": [4, 28],
    "red_town_4x4_23": [8, 28],
    "red_town_4x4_33": [12, 28],

    "red_select_town_1x1": [64, 24],
    "red_select_town_corner_ul": [60, 20],
    "red_select_town_line_u": [64, 20],
    "red_select_town_corner_ur": [68, 20],
    "red_select_town_line_l": [60, 24],
    "red_select_town_line_r": [68, 24],
    "red_select_town_corner_dl": [60, 28],
    "red_select_town_line_d": [64, 28],
    "red_select_town_corner_dr": [68, 28],
    "red_selector": [12, 8],
    "red_ihm_conquest_vertic": [12, 5],
    "red_ihm_conquest_horiz": [12, 11],
    "red_ihm_conquest_dst_pot": [11, 8],
    "red_ihm_conquest_nxt_town": [10, 8],

    "red_controls": [64, 0],
    "red_road_horiz": [72, 0],
    "red_road_vertic": [76, 0],
    "red_road_both": [80, 0],
    "red_cursor": [4, 2],
    "red_magnet": [14, 8],
    "red_go_back": [4, 8],

    "red_town_build_00": [0, 12],
    "red_town_build_01": [4, 12],
    "red_town_build_02": [8, 12],
    "red_town_build_03": [12, 12],
    "red_town_build_04": [16, 12],
    "red_town_build_05": [20, 12],
    "red_town_build_06": [24, 12],
    "red_town_build_07": [28, 12],
    "red_town_build_08": [32, 12],
    "red_town_build_09": [36, 12],

    "blu_01": [0, 4],
    "blu_02": [4, 4],
    "blu_03": [8, 4],
    "blu_04": [12, 4],
    "blu_05": [16, 4],
    "blu_06": [20, 4],
    "blu_07": [24, 4],
    "blu_08": [28, 4],
    "blu_09": [32, 4],
    "blu_10": [36, 4],
    "blu_11": [40, 4],
    "blu_12": [44, 4],
    "blu_13": [48, 4],
    "blu_14": [52, 4],
    "blu_15": [56, 4],
    "blu_16": [60, 4],
    "blu_town_1x1": [68, 4],
    "blu_town_2x2_00": [72, 12],
    "blu_town_2x2_10": [76, 12],
    "blu_town_2x2_01": [72, 16],
    "blu_town_2x2_11": [76, 16],
    "blu_town_4x4_00": [16, 16],
    "blu_town_4x4_10": [20, 16],
    "blu_town_4x4_20": [24, 16],
    "blu_town_4x4_30": [28, 16],
    "blu_town_4x4_01": [16, 20],
    "blu_town_4x4_11": [20, 20],
    "blu_town_4x4_21": [24, 20],
    "blu_town_4x4_31": [28, 20],
    "blu_town_4x4_02": [16, 24],
    "blu_town_4x4_12": [20, 24],
    "blu_town_4x4_22": [24, 24],
    "blu_town_4x4_32": [28, 24],
    "blu_town_4x4_03": [16, 28],
    "blu_town_4x4_13": [20, 28],
    "blu_town_4x4_23": [24, 28],
    "blu_town_4x4_33": [28, 28],

    "blu_select_town_1x1": [76, 24],
    "blu_select_town_corner_ul": [72, 20],
    "blu_select_town_line_u": [76, 20],
    "blu_select_town_corner_ur": [80, 20],
    "blu_select_town_line_l": [72, 24],
    "blu_select_town_line_r": [80, 24],
    "blu_select_town_corner_dl": [72, 28],
    "blu_select_town_line_d": [76, 28],
    "blu_select_town_corner_dr": [80, 28],
    "blu_selector": [12, 8],
    "blu_ihm_conquest_vertic": [12, 5],
    "blu_ihm_conquest_horiz": [12, 11],
    "blu_ihm_conquest_dst_pot": [11, 8],
    "blu_ihm_conquest_nxt_town": [10, 8],

    "blu_controls": [64, 4],
    "blu_road_horiz": [72, 4],
    "blu_road_vertic": [76, 4],
    "blu_road_both": [80, 4],
    "blu_cursor": [12, 8],
    "blu_magnet": [14, 8],
    "blu_go_back": [4, 8],

    "blu_town_build_00": [40, 12],
    "blu_town_build_01": [44, 12],
    "blu_town_build_02": [48, 12],
    "blu_town_build_03": [52, 12],
    "blu_town_build_04": [56, 12],
    "blu_town_build_05": [60, 12],
    "blu_town_build_06": [40, 16],
    "blu_town_build_07": [44, 16],
    "blu_town_build_08": [48, 16],
    "blu_town_build_09": [52, 16],

    "town_desactivate": [68, 8],
    "neutral_road_horiz": [72, 8],
    "neutral_road_vertic": [76, 8],
    "neutral_road_both": [80, 8],

    "grn_01": [0, 8],
    "grn_02": [4, 8],
    "grn_03": [8, 8],
    "grn_04": [12, 8],
    "grn_05": [16, 8],
    "grn_06": [20, 8],
    "grn_07": [24, 8],
    "grn_08": [28, 8],
    "grn_09": [32, 8],
    "grn_10": [36, 8],
    "grn_11": [40, 8],
    "grn_12": [44, 8],
    "grn_13": [48, 8],
    "grn_14": [52, 8],
    "grn_15": [56, 8],
    "grn_16": [60, 8],
    "grn_controls": [64, 8],
    "grn_road_horiz": [32, 20],
    "grn_road_vertic": [36, 20],
    "grn_road_both": [40, 20],

    "missile_ur": [32, 16],
    "missile_dl": [36, 16],
    "missile_exploding": [34, 16],

    "missile_build_00": [0, 0],
    "missile_build_01": [20, 8],
    "missile_build_02": [24, 8],
    "missile_build_03": [28, 8],
    "missile_build_04": [32, 8],
    "missile_build_05": [36, 8],
    "missile_build_06": [40, 8],
    "missile_build_07": [44, 8],
    "missile_build_08": [48, 8],
    "missile_build_09": [52, 8],

    "ihm_background": [44, 20],
    "ihm_border_up": [56, 20],
    "ihm_border_left": [56, 16],
    "ihm_border_right": [60, 16],

    "red_ihm_btn_select_00": [0, 56],
    "red_ihm_btn_select_01": [4, 56],
    "red_ihm_btn_select_02": [8, 56],
    "red_ihm_btn_select_03": [0, 60],
    "red_ihm_btn_select_04": [4, 60],
    "red_ihm_btn_select_05": [8, 60],
    "red_ihm_btn_select_06": [0, 64],
    "red_ihm_btn_select_07": [4, 64],
    "red_ihm_btn_select_08": [8, 64],
    "red_ihm_btn_conq_00": [12, 56],
    "red_ihm_btn_conq_01": [16, 56],
    "red_ihm_btn_conq_02": [20, 56],
    "red_ihm_btn_conq_03": [12, 60],
    "red_ihm_btn_conq_04": [16, 60],
    "red_ihm_btn_conq_05": [20, 60],
    "red_ihm_btn_conq_06": [12, 64],
    "red_ihm_btn_conq_07": [16, 64],
    "red_ihm_btn_conq_08": [20, 64],
    "red_ihm_btn_backw_00": [24, 56],
    "red_ihm_btn_backw_01": [28, 56],
    "red_ihm_btn_backw_02": [32, 56],
    "red_ihm_btn_backw_03": [24, 60],
    "red_ihm_btn_backw_04": [28, 60],
    "red_ihm_btn_backw_05": [32, 60],
    "red_ihm_btn_backw_06": [24, 64],
    "red_ihm_btn_backw_07": [28, 64],
    "red_ihm_btn_backw_08": [32, 64],
    "red_ihm_btn_missile_00": [36, 56],
    "red_ihm_btn_missile_01": [40, 56],
    "red_ihm_btn_missile_02": [44, 56],
    "red_ihm_btn_missile_03": [36, 60],
    "red_ihm_btn_missile_04": [40, 60],
    "red_ihm_btn_missile_05": [44, 60],
    "red_ihm_btn_missile_06": [36, 64],
    "red_ihm_btn_missile_07": [40, 64],
    "red_ihm_btn_missile_08": [44, 64],
    "red_ihm_btn_conqdir_00": [0, 68],
    "red_ihm_btn_conqdir_01": [4, 68],
    "red_ihm_btn_conqdir_02": [8, 68],
    "red_ihm_btn_conqdir_03": [0, 72],
    "red_ihm_btn_conqdir_04": [4, 72],
    "red_ihm_btn_conqdir_05": [8, 72],
    "red_ihm_btn_conqdir_06": [0, 76],
    "red_ihm_btn_conqdir_07": [4, 76],
    "red_ihm_btn_conqdir_08": [8, 76],
    "red_ihm_btn_conqdist_00": [12, 68],
    "red_ihm_btn_conqdist_01": [16, 68],
    "red_ihm_btn_conqdist_02": [20, 68],
    "red_ihm_btn_conqdist_03": [12, 72],
    "red_ihm_btn_conqdist_04": [16, 72],
    "red_ihm_btn_conqdist_05": [20, 72],
    "red_ihm_btn_conqdist_06": [12, 76],
    "red_ihm_btn_conqdist_07": [16, 76],
    "red_ihm_btn_conqdist_08": [20, 76],
    "red_ihm_btn_cancel_00": [24, 68],
    "red_ihm_btn_cancel_01": [28, 68],
    "red_ihm_btn_cancel_02": [32, 68],
    "red_ihm_btn_cancel_03": [24, 72],
    "red_ihm_btn_cancel_04": [28, 72],
    "red_ihm_btn_cancel_05": [32, 72],
    "red_ihm_btn_cancel_06": [24, 76],
    "red_ihm_btn_cancel_07": [28, 76],
    "red_ihm_btn_cancel_08": [32, 76],
    "red_ihm_btn_noorder_00": [36, 68],
    "red_ihm_btn_noorder_01": [40, 68],
    "red_ihm_btn_noorder_02": [44, 68],
    "red_ihm_btn_noorder_03": [36, 72],
    "red_ihm_btn_noorder_04": [40, 72],
    "red_ihm_btn_noorder_05": [44, 72],
    "red_ihm_btn_noorder_06": [36, 76],
    "red_ihm_btn_noorder_07": [40, 76],
    "red_ihm_btn_noorder_08": [44, 76],
    "red_ihm_btn_sleep_00": [48, 68],
    "red_ihm_btn_sleep_01": [52, 68],
    "red_ihm_btn_sleep_02": [56, 68],
    "red_ihm_btn_sleep_03": [48, 72],
    "red_ihm_btn_sleep_04": [52, 72],
    "red_ihm_btn_sleep_05": [56, 72],
    "red_ihm_btn_sleep_06": [48, 76],
    "red_ihm_btn_sleep_07": [52, 76],
    "red_ihm_btn_sleep_08": [56, 76],
    "red_ihm_lit_background": [52, 20],

    "blu_ihm_btn_select_00": [0, 32],
    "blu_ihm_btn_select_01": [4, 32],
    "blu_ihm_btn_select_02": [8, 32],
    "blu_ihm_btn_select_03": [0, 36],
    "blu_ihm_btn_select_04": [4, 36],
    "blu_ihm_btn_select_05": [8, 36],
    "blu_ihm_btn_select_06": [0, 40],
    "blu_ihm_btn_select_07": [4, 40],
    "blu_ihm_btn_select_08": [8, 40],
    "blu_ihm_btn_conq_00": [12, 32],
    "blu_ihm_btn_conq_01": [16, 32],
    "blu_ihm_btn_conq_02": [20, 32],
    "blu_ihm_btn_conq_03": [12, 36],
    "blu_ihm_btn_conq_04": [16, 36],
    "blu_ihm_btn_conq_05": [20, 36],
    "blu_ihm_btn_conq_06": [12, 40],
    "blu_ihm_btn_conq_07": [16, 40],
    "blu_ihm_btn_conq_08": [20, 40],
    "blu_ihm_btn_backw_00": [24, 32],
    "blu_ihm_btn_backw_01": [28, 32],
    "blu_ihm_btn_backw_02": [32, 32],
    "blu_ihm_btn_backw_03": [24, 36],
    "blu_ihm_btn_backw_04": [28, 36],
    "blu_ihm_btn_backw_05": [32, 36],
    "blu_ihm_btn_backw_06": [24, 40],
    "blu_ihm_btn_backw_07": [28, 40],
    "blu_ihm_btn_backw_08": [32, 40],
    "blu_ihm_btn_missile_00": [36, 32],
    "blu_ihm_btn_missile_01": [40, 32],
    "blu_ihm_btn_missile_02": [44, 32],
    "blu_ihm_btn_missile_03": [36, 36],
    "blu_ihm_btn_missile_04": [40, 36],
    "blu_ihm_btn_missile_05": [44, 36],
    "blu_ihm_btn_missile_06": [36, 40],
    "blu_ihm_btn_missile_07": [40, 40],
    "blu_ihm_btn_missile_08": [44, 40],
    "blu_ihm_btn_conqdir_00": [0, 44],
    "blu_ihm_btn_conqdir_01": [4, 44],
    "blu_ihm_btn_conqdir_02": [8, 44],
    "blu_ihm_btn_conqdir_03": [0, 48],
    "blu_ihm_btn_conqdir_04": [4, 48],
    "blu_ihm_btn_conqdir_05": [8, 48],
    "blu_ihm_btn_conqdir_06": [0, 52],
    "blu_ihm_btn_conqdir_07": [4, 52],
    "blu_ihm_btn_conqdir_08": [8, 52],
    "blu_ihm_btn_conqdist_00": [12, 44],
    "blu_ihm_btn_conqdist_01": [16, 44],
    "blu_ihm_btn_conqdist_02": [20, 44],
    "blu_ihm_btn_conqdist_03": [12, 48],
    "blu_ihm_btn_conqdist_04": [16, 48],
    "blu_ihm_btn_conqdist_05": [20, 48],
    "blu_ihm_btn_conqdist_06": [12, 52],
    "blu_ihm_btn_conqdist_07": [16, 52],
    "blu_ihm_btn_conqdist_08": [20, 52],
    "blu_ihm_btn_cancel_00": [24, 44],
    "blu_ihm_btn_cancel_01": [28, 44],
    "blu_ihm_btn_cancel_02": [32, 44],
    "blu_ihm_btn_cancel_03": [24, 48],
    "blu_ihm_btn_cancel_04": [28, 48],
    "blu_ihm_btn_cancel_05": [32, 48],
    "blu_ihm_btn_cancel_06": [24, 52],
    "blu_ihm_btn_cancel_07": [28, 52],
    "blu_ihm_btn_cancel_08": [32, 52],
    "blu_ihm_btn_noorder_00": [36, 44],
    "blu_ihm_btn_noorder_01": [40, 44],
    "blu_ihm_btn_noorder_02": [44, 44],
    "blu_ihm_btn_noorder_03": [36, 48],
    "blu_ihm_btn_noorder_04": [40, 48],
    "blu_ihm_btn_noorder_05": [44, 48],
    "blu_ihm_btn_noorder_06": [36, 52],
    "blu_ihm_btn_noorder_07": [40, 52],
    "blu_ihm_btn_noorder_08": [44, 52],
    "blu_ihm_btn_sleep_00": [48, 44],
    "blu_ihm_btn_sleep_01": [52, 44],
    "blu_ihm_btn_sleep_02": [56, 44],
    "blu_ihm_btn_sleep_03": [48, 48],
    "blu_ihm_btn_sleep_04": [52, 48],
    "blu_ihm_btn_sleep_05": [56, 48],
    "blu_ihm_btn_sleep_06": [48, 52],
    "blu_ihm_btn_sleep_07": [52, 52],
    "blu_ihm_btn_sleep_08": [56, 52],
    "blu_ihm_lit_background": [48, 20],

    "bla": [0, 0]

  }
}
"""


"""

------------
GAME OF NO-LIFE v0.1
------------

Pas de doc, pas d'interface, pas d'infos expliquant comment jouer.
Tout ça viendra plus tard.


Petite information concernant les commentaires dans le code.

J'essaye d'écrire en inclusif, sans pour autant gonfler tout le monde avec des points médians,
ou des mots à rallonge tel que "le/la joueureuse".
Pour ça, la langue anglaise est assez bien, car la plupart des mots sont neutres.
(Et la personne qui vient me dire que c'est mal d'angliciser la langue française,
je lui mets un punch un his/her face).

Pour désigner la personne qui joue, j'utilise le terme "Player". Et je fais comme si
c'était son prénom. Vous lirez donc des phrases du genre : "Player doit déplacer ses unités",
"la town de Player", etc.


Vocabulaire spécifique au jeu :

unité/pixel : un petit pixel rouge, bleu ou vert, qui peut se déplacer d'une tile à l'autre.

tile/case : une case du jeu. Ça fait partie du vocabulaire générique de Squarity

bare tile : une tile sur laquelle il n'y a pas de ville, et aucune route.
Mais il peut y avoir une ou plusieurs unités.

bionature : les pixels verts, qui ne sont pas contrôlés par un humain, mais par le jeu.

town/ville : une ville, de couleur rouge ou bleue. La bionature ne construit pas de ville.

wardness/direction de conquête : deux booléens indiquant vers laquelle Player doit aller :
 - rightward : direction horizontale (True:droite, False:gauche)
 - upward : direction verticale (True:bas , False:haut)
Pour Player red : rightward=True, upward=False. Pour Player blue, c'est inversé.

line conquest : construction, à partir d'une ville existante, d'une ligne de route
(horizontale ou verticale), sur une distance prédéfinie. Puis construction, au bout
de cette ligne de route, d'une nouvelle ville.

La direction de conquête influe sur différents détails : l'ordre des tiles adjacentes où les towns
posent les pixels générés, la direction des missiles bactériologiques, l'ordre de priorité des
merge de town, la direction des backward conquest, etc.
"""

# FUTURE : suppression du backward conquest si une town est merge/shatterée.

import random

# TODO : flèches de conquêtes dessinées mieux que ça.

# TODO : dessiner mieux tous les sprites que j'ai fait à l'arrache.

# TODO : afficher une petite flèche quand on doit choisir un truc dans l'interface.

# TODO : affichage du nombre de cases et villes des deux Players.

# TODO : contrôler vite fait ce que ça donne quand toute l'aire de jeu est complétée, mais si ça plante, osef.

# TODO : le curseur de sandbox est uniquement visible en mode sandbox. Et faut changer un booléen pour pouvoir sandboxer.

# Dimensions, en nombre de cases, du jeu 'game of no-life',
# dans lequel évoluent les unités, les villes, etc.
WARZONE_WIDTH = 36
WARZONE_HEIGHT = 36
# Décalage de l'affichage de la warzone, par rapport à l'interface du jeu
OFFSET_INTERFACE_X = 12
OFFSET_INTERFACE_Y = 2
# TODO : faut faire gaffe à quels endroits on utilise ces constantes.
# Tant que y'a pas d'interface, osef. Mais ça va changer.
# Dimensions, en nombre de cases, du jeu Squarity, en comptant les cases dédiées
# à l'interface, sur les bords.
TOTAL_GAME_WIDTH = WARZONE_WIDTH + 2 * OFFSET_INTERFACE_X
TOTAL_GAME_HEIGHT = WARZONE_HEIGHT + OFFSET_INTERFACE_Y

# Si Player possède un nombre d'unité supérieur à (RATIO_CONTROLLED_TILE_FOR_GENERATION * nombre de tile contrôlées),
# la génération d'unité se met en pause (town et tiles). Ça évite de se retrouver avec un gros tas d'unités
# dont on sait pas quoi faire, et ça rend encore plus importante l'occupation de terrains.
RATIO_CONTROLLED_TILE_FOR_GEN = 3

# La distance jusqu'à laquelle on fait le backward conquest,
# en fonction de la size de la town.
DIST_BACKWARD_CONQUEST = {1: 3, 2: 6, 4: 9}
# Nombre d'unité à envoyer à chaque tour en backward conquest,
# en fonction de la size de la town.
NB_UNIT_TO_SENT_BACKWARD_CONQUEST = {1: 1, 2: 2, 4: 3}

# Nombre de tour de jeu nécessaire pour construire une town.
NB_TURNS_TOWN_BUILDING = 9
# Pour qu'une town soit construite, il faut 16 unités sur la tile,
# durant tous les tours de construction. Si des unités sont supprimés,
# suite à un événement quelconque, la construction est mise en pause.
# La construction de la town s'annule si elle n'est pas terminé
# au bout de "NB_TURNS_TOWN_BUILDING_TIMEOUT" tours.
NB_TURNS_TOWN_BUILDING_TIMEOUT = 25
# Nombre de points que doit accumuler une ville pour générer un pixel.
# La ville gagne un nombre fixe de points à chaque tour, selon sa taille.
# petite : 1, moyenne : 6, grande : 22.
# J'ai mis un nombre assez grand, car ce ne sont pas les villes qui produisent le plus,
# mais le fait de contrôler beaucoup de terrain. Ça devrait (j'espère) rendre le jeu
# plus intéressant.
UNIT_GEN_TOWN_POINT_REQUIRED = 100
# Parfois, une town ne peut pas générer de pixels, parce que toutes les tiles autour d'elle
# sont déjà pleines de pixels. Dans ce cas, la town cumule ses points de génération pour
# plus tard, lorsqu'elle aura de la place autour d'elle.
# Cette variable indique le nombre de points de génération max qu'une town peut cumuler.
UNIT_GEN_TOWN_POINT_MAX_CUMUL = UNIT_GEN_TOWN_POINT_REQUIRED * 2

# Nombre de points à avoir pour générer un pixel par le terrain contrôlé.
# On gagne un point par tour et par tile contrôlée. Une tile est contrôlée si on possède
# au moins une unité dessus.
# Petit calcul pour prouver que c'est plus avantageux de prendre du terrain que de
# construire des villes :
# J'ai 256 pixels, je m'en sers pour conquérir 256 terrains.
# UNIT_GEN_TILE_POINT_REQUIRED / 256 = 3.51.
# Ces 256 terrains vont me générer un pixel tous les 3,51 tours.
# J'ai 256 pixels, ça fait 16 * 4 * 4. Je peux m'en servir pour construire une super grosse ville.
# UNIT_GEN_TOWN_POINT_REQUIRED / 22 = 4.54.
# La super grosse ville me génère un pixel tous les 4,54 tours.
# L'avantage est encore plus flagrant avec les petites villes et les moyennes villes.
UNIT_GEN_TILE_POINT_REQUIRED = 900
# Cumul de points de génération par terrain contrôlé. Pour le cas où a assez de points,
# mais on ne trouve pas de tile sur laquelle poser le pixel généré.
UNIT_GEN_TILE_POINT_MAX_CUMUL = UNIT_GEN_TILE_POINT_REQUIRED * 50
# Nombre de points que la bionature doit avoir pour générer un pixel vert.
# La bionature gagne un point par tour et par tile contrôlée.
# C'est beaucoup plus que UNIT_GEN_TILE_POINT_REQUIRED, car la bionature a beaucoup de terrain
# au départ, et ça embêterait les Players humains d'avoir une bionature qui s'étend trop vite.
UNIT_GEN_TILE_POINT_REQUIRED_BIONATURE = 25000

# Les directions opposées en fonction d'une direction.
# 0:haut, 1:diag haut-droite, 2:droite, etc. ça tourne dans le sens des aiguilles d'une montre.
REVERSE_DIRS = (4, 5, 6, 7, 0, 1, 2, 3)

# Moche, mais ça permet de convertir plus rapidement.
GAMOBJ_NAME_TO_NB_UNIT = tuple(
    "00;01;02;03;04;05;06;07;08;09;10;11;12;13;14;15;16".split(";")
)


def iterate_on_pseudo_random_boolean():
    # Fonction qui sort des booléens random à l'arrache, à partir d'une liste
    # de 1000 valeurs booléennes random prédéfinies. C'est de la merde, mais on n'a pas besoin de plus.
    # Et ça évitera de faire ralentir le jeu en appelant la vraie fonction random à chaque fois.
    RANDOM_QUANTITY = 1000
    bools = [True] * (RANDOM_QUANTITY // 2) + [False] * (RANDOM_QUANTITY // 2)
    random.shuffle(bools)
    index_bool = 0
    while 1:
        yield bools[index_bool]
        index_bool += 1
        if index_bool >= RANDOM_QUANTITY:
            index_bool = 0


pseudo_random_boolean = iterate_on_pseudo_random_boolean()
# Première itération pour initialiser et shuffler la liste.
# Le booléen renvoyé ne sert à rien. Osef.
next(pseudo_random_boolean)


def pos_in_bounding_rect(b_rect, x, y):
    """
    Renvoie True si la position x, y est dans le rect.
    Le rect à passer en paramètre s'étend de x1 à x2 - 1, et de y1 à y2 - 1.
    """
    x_min, y_min, x_max, y_max = b_rect
    return (x_min <= x < x_max) and (y_min <= y < y_max)


def bounding_rect_overlaps(b_rect_1, b_rect_2):
    """
    Renvoie True si les deux rectangles se chevauchent.
    Les rect à passer en paramètre s'étendent de x1 à x2 - 1, et de y1 à y2 - 1.
    """
    x_min_1, y_min_1, x_max_1, y_max_1 = b_rect_1
    x_min_2, y_min_2, x_max_2, y_max_2 = b_rect_2
    if x_max_1 <= x_min_2 or x_max_2 <= x_min_1:
        return False
    if y_max_1 <= y_min_2 or y_max_2 <= y_min_1:
        return False
    return True


def manhattan_dist(tile_1, tile_2):
    return abs(tile_1.x - tile_2.x) + abs(tile_1.y - tile_2.y)


def directions_from_pos(tile_src, tile_dst):
    """
    Renvoie un tuple de 0, 1 ou 2 directions : 0, 6, 4 ou 2,
    en fonction de la position relative de tile_src par rapport à tile_dst.
    0: up, 2:right, 4:down, 6:left.
    Les directions renvoyées correspondent à celles pour aller de tile_src vers tile_dst.
    Si tile_src et tile_dst sont sur la même ligne ou la même colonne, la fonction ne renverra
    qu'une seule direction.
    L'ordre est déterminé selon la distance. Si les deux tiles sont plus éloigneés en X qu'en Y,
    la première direction du tuple sera la direction horizontale. Sinon, c'est l'inverse.
    (On se sert pas de cette particularité dans le code, mais on sait jamais).
    """
    diff_x = tile_dst.x - tile_src.x
    diff_y = tile_dst.y - tile_src.y
    directions = []
    if diff_x:
        dir_x = 6 if diff_x < 0 else 2
        directions.append(dir_x)
    if diff_y:
        dir_y = 0 if diff_y < 0 else 4
        directions.append(dir_y)

    if abs(diff_x) < abs(diff_y):
        directions = directions[::-1]
    return directions


def is_behind_right_down(tile_ref, tile_test):
    """
    Les fonction is_behind_xxx permettent de savoir si une tile est "derrière" une autre tile,
    par rapport à la direction de conquête de Player (rightward, downward).
    Renvoie True si tile_test est derrière tile_ref.
    """
    return tile_test.x <= tile_ref.x and tile_test.y <= tile_ref.y


def is_behind_left_down(tile_ref, tile_test):
    return tile_test.x >= tile_ref.x and tile_test.y <= tile_ref.y


def is_behind_right_up(tile_ref, tile_test):
    return tile_test.x <= tile_ref.x and tile_test.y >= tile_ref.y


def is_behind_left_up(tile_ref, tile_test):
    return tile_test.x >= tile_ref.x and tile_test.y >= tile_ref.y


def get_town_infos_right_down(town):
    """
    Les fonctions get_town_infos_xxx renvoient un tuple de 3 éléments.

    Les deux premiers éléments correspondent à la coordonnée x, y de la tile la plus
    en arrière, de la town passée en paramètre.
    Si la town a une taille de 1, la tile la plus arrière est la tile de la town
    (on n'a pas le choix).
    Si la town est plus étendue, la tile la plus arrière se trouve dans un coin.
    Le coin en question dépend de la direction de conquête de Player.
    C'est pour ça qu'il y a 4 fonctions, une par direction de conquête.

    Le dernier éléent du tuple renvoyé est un sous-tuple de 2 élément.
    Il s'agit d'une clé de tri, pour ordonner les villes, en fonction de la direction
    de conquête de Player.
    Les villes doivent être ordonnables, car on doit pouvoir définir une priorité parmi
    les merge/shatter de ville.
    Par exemple, pour Player red, on merge les villes en commençant par le bas et la gauche.
    Les villes qui sont toutes sur la même diagonale ont leur premier index de priorité égal.
    Le deuxième index permet d'ordonner les villes qui sont sur la même diagonale.

    Pour les moyennes et les grosses villes, qui s'étendent sur plusieurs cases, on prend comme
    case de référence celle qui est le plus en arrière possible.
    (Ça correspond aux coordonnées qu'on a renvoyées dans les 2 premiers elems du tuple).
    Par exemple, pour Player red, qui part du coin inférieur gauche de l'aire de jeu,
    la case la plus derrière pour une de ses towns est le coin inférieur gauche de la town.
    """
    x_behind = town.x_left
    y_behind = town.y_up
    return (x_behind, y_behind, (x_behind + y_behind, y_behind))


def get_town_infos_left_down(town):
    x_behind = town.x_left + town.size - 1
    y_behind = town.y_up
    return (x_behind, y_behind, (-x_behind + y_behind, y_behind))


def get_town_infos_right_up(town):
    x_behind = town.x_left
    y_behind = town.y_up + town.size - 1
    return (x_behind, y_behind, (x_behind - y_behind, -y_behind))


def get_town_infos_left_up(town):
    x_behind = town.x_left + town.size - 1
    y_behind = town.y_up + town.size - 1
    return (x_behind, y_behind, (-x_behind - y_behind, -y_behind))


# C'est dégueu d'avoir besoin d'une fonction comme ça.
# Faut vraiment que je fasse des librairies génériques de manipulation de tile et d'arrays.
def tile_from_coords(array_gamobjs, tile):
    return array_gamobjs[tile.y + OFFSET_INTERFACE_Y][tile.x + OFFSET_INTERFACE_X]


# Configuration de tout un tas de variable de Player, en fonction de ses directions de conquête.
# Clé : 2 booléens (rightward, downward), définissant les directions de conquête.
# Valeur : un tuple de 7 éléments :
# - La fonction sort_by, permettant de trier les towns en partant du point de départ de Player.
# - La fonction is_behind, permettant de savoir si une tile est derrière une autre,
#   dans la direction de conquête de Player
# - directions forward en diagonale, forward horizontale, forward verticale
# - directions backward en diagonale, backward horizontale, backward verticale
CONFIG_FROM_WARDNESSES = {
    (True, True): (get_town_infos_right_down, is_behind_right_down, 3, 2, 4, 7, 6, 0),
    (True, False): (get_town_infos_right_up, is_behind_right_up, 1, 2, 0, 5, 6, 4),
    (False, True): (get_town_infos_left_down, is_behind_left_down, 5, 6, 4, 1, 2, 0),
    (False, False): (get_town_infos_left_up, is_behind_left_up, 7, 6, 0, 3, 2, 4),
    (None, None): (None, None, None, None, None, None, None, None),
}

# Les différents états possibles lorsqu'on effectue des merge/shatter de town.
# Voir fonction Player.process_town_merging.
TOWN_MERGE_STATE_UNSORTED = 0
TOWN_MERGE_STATE_UNCHECKED = 1
TOWN_MERGE_STATE_STABLE = 2

# Utilisé lorsque Player déclenche une "line conquest".
# Il s'agit du nombre de tours de jeu pour le temps de pause après construction d'une route.
DELAY_ROADIFY = 10


class PlayerHandler:
    def __init__(
        self,
        player_id,
        w,
        h,
        color,
        game_master,
        rightward,
        downward,
        is_bionature=False,
    ):
        if is_bionature:
            rightward = None
            downward = None
        else:
            if rightward is None or downward is None:
                raise Exception("Players humains, il faut rightward et downward.")

        self.player_id = player_id
        self.w = w
        self.h = h
        self.color = color
        # Le game master qui gère ce Player, et qui gère aussi tout le jeu.
        self.game_master = game_master
        self.rightward = rightward
        self.downward = downward
        self.is_bionature = is_bionature
        self.gamobj_magnet = self.color + "_magnet"
        self.gamobj_go_back = self.color + "_go_back"
        (
            self.get_town_infos,
            self.is_behind,
            self.dir_forw_diag,
            self.dir_forw_hori,
            self.dir_forw_verti,
            self.dir_back_diag,
            self.dir_back_hori,
            self.dir_back_verti,
        ) = CONFIG_FROM_WARDNESSES[(self.rightward, self.downward)]

        # Liste de tiles
        self._controlled_tiles = []
        # Liste de tiles aussi.
        self._controlled_roads = []
        # Liste de tiles aussi. "bare tile" = une tile qui n'a pas de route.
        # On a besoin de cette liste pour accélérer les traitements. En général, on a plein
        # de bare tiles avec une seule unité dessus. Elles ne demandent aucune gestion.
        # Les bare tiles ayant plusieurs unités sont moins nombreuses, mais demandent une gestion.
        # On bouge les unités supplémentaires forward, ou backward.
        # C'est donc avantageux de référencer ces tiles particulières, pour les gérer plus vite,
        # plutôt que de parcourir toute les controlled_tiles à chaque fois.
        self.controlled_bare_tiles_with_many_units = []
        self.towns = []
        # Les towns ayant au moins une tile non-town adjacente. C'est à dire qu'elle peuvent
        # générer des unités et les placer autour d'elles.
        self.active_towns = []
        self.total_units = 0
        # La tile sur laquelle se trouve une ville en construction.
        # On ne peut construire qu'une seule ville à la fois.
        self.tile_building_town = None
        # Nombre de tour écoulé depuis le début de la construction de la ville en cours.
        self.building_time = 0
        # La tile vers laquelle toutes les unités doivent aller.
        # Lorsqu'il n'y a pas de magnet, les unités doivent à-peu-près se répartir sur les routes.
        self.tile_magnet = None
        # La tile qui fait le backward conquest, s'il y en a une.
        # C'est forcément une tile de town. Et c'est la tile de town la plus en arrière possible
        # (dans le cas des towns ayant une size supérieure à 1)
        self.tile_go_backward = None
        # Les unités qui font un backward conquest sont limitées dans un bounding rect.
        # Plus la town ayant lancé la conquest est grande, plus le bounding rect est grand.
        self.bounding_rect_go_back = None
        self.nb_unit_to_send_backward = 0
        # Pour les 3 variables suivantes, voir fonction Player.process_town_merging.
        self.town_merge_state = TOWN_MERGE_STATE_STABLE
        self.towns_to_merge = None
        self.town_to_shatter = None
        # Nombre de points accumulés, pour la génération des unités par terrain contrôlés.
        self.unit_gen_tile = 0
        # Nombre de tours consécutifs durant lesquels on a tenté de placer une unité générée,
        # et qu'on n'a pas pu parce qu'on n'a pas trouvé de tile adéquate.
        self.unit_gen_tile_nb_turn_fail = 0
        # Pour les 4 variables suivantes : Gestion des line conquest.
        # Voir fonction Player.process_line_conquest.
        self.tiles_to_roadify = []
        self.tile_to_townify = None
        self.delay_roadify = 0
        self.is_roadify_horiz = False
        self.bare_tile_move_priorities_from_x_parity = (
            (self.dir_forw_diag, self.dir_forw_hori, self.dir_forw_verti),
            (self.dir_forw_diag, self.dir_forw_verti, self.dir_forw_hori),
        )
        self.player_interface = None

    def __str__(self):
        return "player_%s" % self.player_id

    def set_player_interface(self, player_interface):
        self.player_interface = player_interface

    def add_controlled_tile(self, tile):
        # Pas besoin de trier ces tiles dans le sens dans lequel on les résout.
        # Au début, je croyais, mais en fait non. Avec les histoires de modulo
        # (à chaque tour, on ne gère qu'une tile sur deux, ou une sur quatre),
        # ça se gère bien tout seul.
        self._controlled_tiles.append(tile)

    def remove_controlled_tile(self, tile):
        self._controlled_tiles.remove(tile)

    def add_towns(self, towns):
        """
        Référence une town qui vient d'être construite.
        """
        self.towns += towns
        self.update_active_towns()
        # Une nouvelle town vient d'être ajoutée. Il y aura peut-être besoin d'une réorganisation.
        # Il faut donc refaire un cycle de vérification des merge/shatter de towns.
        self.town_merge_state = TOWN_MERGE_STATE_UNSORTED

    def remove_towns(self, towns):
        """
        Supprime une town référencée.
        Dans le jeu, on ne détruit jamais les towns. Mais on les merge.
        Un merge provoque une suppression de plusieurs towns,
        que l'on remplace par une town plus grande.
        """
        for town in towns:
            self.towns.remove(town)
        self.update_active_towns()
        # Il faut refaire un cycle de vérification des merge/shatter de towns.
        self.town_merge_state = TOWN_MERGE_STATE_UNSORTED

    def add_controlled_road(self, tile):
        self._controlled_roads.append(tile)

    def remove_controlled_road(self, tile):
        self._controlled_roads.remove(tile)

    def move_unit_without_check(self, tile_source, tile_dest, qty=1):
        """
        Cette fonction n'est à utiliser que quand on est sûr de ce qu'on fait.
        Elle permet de déplacer des unités d'une tile vers une autre.
        Toutes les conditions suivantes doivent être réunies :
         - tile_source et tile_dest sont toutes les deux contrôlées par Player.
         - il y a au moins une route sur tile_source et au moins une route sur tile_dest.
         - les unités déplacées ne vont pas supprimer toutes les unités de tile_source
         - les unités déplacés ne vont pas aboutir à avoir plus de 16 unités sur tile_dest.

        Le déplacement d'unités est très rapide, car on ne fait aucun check.
        Pas de mise à jour des listes de tiles
        (_controlled_tiles, _controlled_roads, controlled_bare_tiles_with_many_units).
        Pas de vérification des owner de tile_source et tile_dest.

        On utilise cette fonction pour équilibrer les unités entre deux routes adjacentes,
        ou entre deux tiles d'un même suburb, contrôlées par Player.
        """
        tile_source.nb_unit -= qty
        tile_dest.nb_unit += qty
        tile_source.update_linked_gamobjs()
        tile_dest.update_linked_gamobjs()

    def cancel_all_orders(self):
        """
        Supprime tous les ordres en cours que Player a pu envoyer :
        les constructions de routes et ville d'une line conquest, magnétisation,
        backward conquest, etc.
        """
        self.tile_magnet = None
        self.tile_go_backward = None
        self.bounding_rect_go_back = None
        self.nb_unit_to_send_backward = 0
        self.tiles_to_roadify = []
        self.tile_to_townify = None

    def _spread_units_on_one_road(self, tile):
        """
        Répartit les unités qui sont sur une tile, vers les tiles adjacentes.
        On sort au maximum une seule unité par tile adjacente.
        On sort une unité lorsque les conditions suivantes sont respectées :
         - la tile de départ et la tile adjacente sont connectées par une route.
         - les deux tiles sont contrôlées par Player.
         - la tile a plus de deux unités dessus. Car on considère qu'il faut toujours
           au moins deux unités sur une road pour en garder le contrôle.
           (en vrai, on contrôle toujours la tile si on a une seule unité dessus,
           mais on peut pas la bouger).
         - il y a plus de une unité de plus entre la tile de départ et la tile adjacente.
           Exemple : 7 unités sur la tile de départ, 5 sur la tile adjacente -> on en déplace une.
           mais avec 6 unités sur la tile de départ, 5 sur la tile adjacente -> on déplace pas.
           C'est ce qui fait qu'au fur et à mesure qu'on s'éloigne d'une ville, on a en général
           de moins en moins d'unités.

        Pour gérer tout ça, la fonction utilise la variable Tile.road_adjacencies_same_player.
        Cette variable est mise à jour lors des déplacements d'unités.
        Voir la classe Tile.
        """
        nb_unit_source = tile.nb_unit
        # On itère sur les 4 cases autour, et non pas sur les 8. On ne fait pas les diagonales.
        # Y'en n'a pas besoin parce que y'a pas de routes diagonales.
        for adj_tile, adj_connexion_type in zip(
            tile.adjacencies[::2], tile.road_adjacencies_same_player[::2]
        ):
            if (
                adj_tile is not None
                and adj_connexion_type == 1
                and nb_unit_source > 2
                and nb_unit_source - adj_tile.nb_unit > 1
            ):
                self.move_unit_without_check(tile, adj_tile)
                nb_unit_source = tile.nb_unit

    def _move_units_to_magnet(self, tile):
        """
        Déplace une unité d'une tile ayant une route, vers une tile adjacente,
        dans le cas ou Player a une magnétisation.
        Ça ne fait pas du vrai pathfinding, mais osef. L'unité est déplacée vers une tile
        adjacente (horizontale ou verticale), dans la direction de la tile magnetisée.
        Et tant pis si à la fin ça mène vers un cul-de-sac ou vers une tile qui ne permet pas
        d'atteindre la tile magnetisée. (Player a qu'à gérer son réseau routier correctement !)
        La tile source et la tile dest doivent être connectées par une route.
        On permet des déplacements vers des tiles non contrôlées, ou même des tiles appartenant
        à l'autre Player. Dans ce dernier cas, l'unité sera détruite. Mais c'est ce qui permet
        d'éliminer des unités adverses pour gagner du terrain.

        On ne déplace pas d'unité si la tile n'a que 1 ou 2 unités. En accord avec le principe
        qu'il faut laisser 2 unités sur une tile de road avant de pouvoir en déplacer.
        """
        nb_unit_source = tile.nb_unit
        if nb_unit_source <= 2:
            return
        dirs = directions_from_pos(tile, self.tile_magnet)
        # Cette variable contiendra toutes les directions possibles vers lesquelles on peut déplacer une unité
        # Soit 0, 1 ou 2 directions possibles.
        # Si il y en a 2, on en sélectionnera une seule, au hasard.
        possible_tiles_dest = []
        for direc in dirs:
            tile_dest = tile.adjacencies[direc]
            if tile_dest is not None:
                if tile_dest.player_owner == self and tile_dest.nb_unit >= 16:
                    # La tile de destination est déjà pleine au max. Pas de déplacement.
                    continue
                if not tile.is_road_connected(direc, tile_dest):
                    # Pas de connexion de route. Pas de déplacement.
                    continue
                if (
                    tile.suburb_owner is not None
                    and tile.suburb_owner == tile_dest.suburb_owner
                ):
                    # Là, ce serait un déplacement d'unité entre deux tiles d'un même suburb.
                    # Ça sert à rien, le suburb gère lui-même ses répartitions d'unités.
                    continue
                # Voilà. On a fait toutes les vérifs qu'il faut. On pourra déplacer dans cette direction.
                possible_tiles_dest.append(tile_dest)

        if not possible_tiles_dest:
            return

        if len(possible_tiles_dest) == 1:
            selected_tile_dest = possible_tiles_dest[0]
        else:
            selected_index = int(next(pseudo_random_boolean))
            selected_tile_dest = possible_tiles_dest[selected_index]

        # Soit c'est un déplacement sans aucun check, car les deux tiles sont contrôlés
        # par Player. Soit c'est un déplacement avec tous les check nécessaires.
        if selected_tile_dest.player_owner == self:
            self.move_unit_without_check(tile, selected_tile_dest)
        else:
            tile.remove_unit()
            selected_tile_dest.add_unit(self)

    def can_generate_unit(self):
        limit_total_units = len(self._controlled_tiles) * RATIO_CONTROLLED_TILE_FOR_GEN
        limit_total_units = max(16, limit_total_units)
        return self.total_units < limit_total_units

    def move_units_on_roads(self, turn_index):
        """
        Gestion de tous les déplacements d'unités qui sont sur des routes,
        en tenant compte de l'éventuelle magnétisation.

        On parcourt une tile sur deux de toutes les tiles ayant des routes et
        contrôlées par Player.
        Le "un sur deux" est géré de cette manière :
        L'aire de jeu est considéré comme ça :
        ABABAB...
        BABABA...
        ABABAB...
        BABABA...
        ...
        La tile en haut à gauche est "A", celle à droite est "B", celle encore à droite est "B",
        et ainsi de suite.
        Sur la ligne en-dessous, c'est presque pareil, sauf que la tile tout à gauche est "B".

        Cette fonction gère, soit toutes les tiles "A", soit toutes les "B".
        Le choix est déterminé par le paramètre turn_index (numéro du tour de jeu actuel).
        Si turn_index est pair, on gère tous les "A", sinon, tous les "B".

        Ça permet de diminuer les traitements à faire à chaque tour, et surtout, ça permet
        de montrer les pixels qui se déplacent progressivement. Si on gère toutes les tiles
        à chaque tour, on prend le risque d'avoir une unité qui se déplace d'une tile à l'autre,
        tout le long d'une route. Et ça donne l'impression qu'elle s'est téléportée. C'est moche.

        Dans tous les cas, il y a une tile particulière qu'on ne gère jamais, qui ne sort jamais
        ses unités (ni en répartition, ni en magnet). C'est la tile sur laquelle Player est
        en train de construire une ville (s'il y a une ville en construction).
        Sinon, on prend le risque d'enlever les 16 unités de la tile sur laquelle
        se construit la ville.
        """
        if self.tile_magnet is None:
            function_move = self._spread_units_on_one_road
        else:
            function_move = self._move_units_to_magnet
        select_tile = turn_index & 1

        for tile in self._controlled_roads:
            # La tile qui construit une ville ne transfère pas ses unités aux autres.
            # Et on fait une tile sur deux, répartie dans l'arène.
            if (tile.x + tile.y) & 1 == select_tile and not tile.town_building_step:
                function_move(tile)

    def move_magnetized_units_on_suburb(self):
        """
        Gère les déplacement d'unités interne au suburb dans lequel se trouve la tile magnetisée.
        """
        if self.tile_magnet is None:
            return
        if self.tile_magnet.suburb_owner is None:
            return
        if self.tile_magnet.town is not None:
            # Il y a une magnétisation, et elle est dans un suburb. Mais la tile magnetisée est
            # sur une town. Dans ce cas, on ne fait aucun déplacement dans le suburb
            # lui-même, parce qu'on ne peut pas placer des unités sur une town.
            return
        magnetized_suburb = self.tile_magnet.suburb_owner
        # Les déplacement internes à un suburb doivent être assez rapide. Pour toutes les tiles
        # du suburb pour lesquelles on peut prélever une unité, on le fait et on la place
        # directement sur la tile magnetisée. Les tiles prélevables sont celles contrôlées par
        # Player, et qui comportent plus que deux unités.
        for suburb_tile in magnetized_suburb.real_suburb_tiles:
            if self.tile_magnet.player_owner == self and self.tile_magnet.nb_unit >= 16:
                # La tile magnetisée est déjà pleine au max des unités de Player.
                # Il n'y a plus besoin de déplacer d'unités.
                return
            if suburb_tile.player_owner == self and suburb_tile.nb_unit > 2:
                # Déplacement d'une unité vers la tile magnetisée.
                suburb_tile.remove_unit()
                self.tile_magnet.add_unit(self)

    def process_town_building(self):
        """
        Gère la town en cours de construction, s'il y en a une.
        Rappel : Player ne peut construire qu'une town à la fois.
        """
        if self.tile_building_town is None:
            return
        self.building_time += 1
        if self.building_time >= NB_TURNS_TOWN_BUILDING_TIMEOUT:
            # La construction de la ville a pris trop de temps.
            # Parce que les unités qui sont dessus n'ont pas arrêté de se faire éliminer.
            # Tant pis, on arrête la construction.
            self.tile_building_town.cancel_town_building()
            self.building_time = 0
            self.tile_building_town = None
            return

        if self.tile_building_town.nb_unit >= 16:
            # Pas de problème, il y a toujours 16 unités dans la ville en construction.
            # On avance la construction de 1.
            self.tile_building_town.advance_town_building()
            if self.tile_building_town.town_building_step >= NB_TURNS_TOWN_BUILDING:
                # On a réussi à faire avancer la construction jusqu'au bout.
                # On peut poser la ville ! La fonction build_town s'occupe de tout ça.
                self.tile_building_town.build_town()
                # Arrêt de la construction en cours, puisqu'on a fini.
                self.building_time = 0
                if self.tile_magnet == self.tile_building_town:
                    self.tile_magnet = None
                self.tile_building_town = None
            return

    def update_active_towns(self):
        if self.player_interface is not None:
            self.player_interface.dirtify_town_list()
        self.active_towns = [town for town in self.towns if town.is_active]

    def process_unit_generation_town(self):
        """
        Effectue la génération des unités pour toutes les towns actives.
        """
        for town in self.active_towns:
            town.process_unit_generation()

    def move_units_on_bare_tiles(self, turn_index):
        """
        Gère les déplacements des unités qui sont sur des bare tiles.
        Seule les bare tiles ayant plus de 1 unité font des déplacements. Sinon ce serait
        un déplacement qui déclencherait la perte de contrôle d'une tile, et c'est un peu idiot.
        On connait directement les tiles concernées, grâce à la liste
        self.controlled_bare_tiles_with_many_units, mise à jour à chaque déplacement d'unité.

        Pour la zone de jeu "backward conquest", les unités sont déplacées en diagonale, vers
        l'arrière (par rapport à la direction de conquête de Player). On permet les déplacements
        sur des tiles non contrôlées ou contrôlées par d'autres (les unités s'élimineront).
        C'est le but de la conquête.
        On déplacera ainsi progressivement les unités vers l'arrière, jusqu'à arriver à la limite
        de la zone, ou bien jusqu'à une tile avec route.

        Pour la zone de jeu en dehors de backward conquest, on déplace les unités vers l'avant,
        mais uniquement sur des tiles contrôlées.
        On prend le premier déplacement possible parmi les 3 dispo :
        diagonal avant, horizontal avant, vertical avant.
        Juste pour ajouter un peu de variété, on alterne l'ordre horizontal/vertical dans ces
        déplacements possibles, en fonction de x (abscisse).
        Ce comportement devrait ramener progressivement les unités vers une route
        (en général, à proximité de la town qui a précédemment lancé une backward conquest).
        Il est possible que les unités se déplaçant de cette manière se retrouvent coincées
        dans un cul de sac. C'est le problème de Player, qui n'a qu'à bien gérer ses terrains.

        À chaque tour, on gère une tile sur 4, selon presque le même principe que dans la fonction
        move_units_on_roads (avec les "ABAB...").
        Mais pour cette fonction, on fait comme ça :
        ABCDABCDABCD...
        CDABCDABCDAB...
        ABCDABCDABCD...
        CDABCDABCDAB...
        ...
        Si on avait géré avec juste les ABAB, ça aurait fait des diagonales de "A"
        et des diagonales de "B". Ce qui est embêtant, car justement les unités se
        déplacent en diagonales ! On aurait eu des grands déplacements qui auraient
        ressemblé à de la téléportation.
        """
        select_tile = turn_index & 3
        check_go_back = self.bounding_rect_go_back is not None
        for tile in self.controlled_bare_tiles_with_many_units:
            # Le y est multiplié par 2, pour pouvoir faire le "ABCD / CDAB" décrit en docstring.
            if (tile.x + tile.y * 2) & 3 == select_tile:
                if check_go_back and pos_in_bounding_rect(
                    self.bounding_rect_go_back, tile.x, tile.y
                ):
                    if tile.nb_unit > 3:
                        # backward, en mode conquest
                        for direction in (
                            self.dir_back_diag,
                            self.dir_back_hori,
                            self.dir_back_verti,
                        ):
                            tile_dest = tile.adjacencies[direction]
                            if (
                                tile_dest is not None
                                and tile_dest.town is None
                                and (
                                    tile_dest.player_owner != self
                                    or tile_dest.nb_unit < 16
                                )
                            ):
                                tile.remove_unit()
                                tile_dest.add_unit(self)
                else:
                    # forward, en mode move.
                    possible_direcs = self.bare_tile_move_priorities_from_x_parity[
                        tile.x & 1
                    ]
                    for direction in possible_direcs:
                        tile_dest = tile.adjacencies[direction]
                        if (
                            tile_dest is not None
                            and tile_dest.town is None
                            and tile_dest.player_owner == self
                            and tile_dest.nb_unit < 16
                        ):
                            # On ne peut pas utiliser la fonction move_unit_without_check,
                            # parce qu'on n'est pas sur des tiles de routes. Et que justement, ces
                            # déplacements changent le contenu de controlled_bare_tiles_with_many_units
                            tile.remove_unit()
                            tile_dest.add_unit(self)
                            break

    def set_town_backward_conquest(self, town):
        """
        Déclenche une backward conquest sur une town. Cette fonction met à jour
        self.tile_go_backward et self.bounding_rect_go_back.
        Cette fonction magnétise également la town qui backward conquest (self.tile_magnet).
        """
        self.tile_magnet = None
        self.tile_go_backward = None
        if town is None:
            return
        self.nb_unit_to_send_backward = NB_UNIT_TO_SENT_BACKWARD_CONQUEST[town.size]
        # Définition de la tile qui fait le backward. Ça correspond à la town.
        # Pour les towns ayant size > 1, on prend la tile la plus derrière
        # (par rapport à la direction de conquête).
        self.tile_go_backward = town.tile_go_backward_diag
        if self.tile_go_backward.adjacencies[self.dir_back_diag] is None:
            # On essaie de backwarder avec une town qui est sur un bord arrière de l'aire de jeu,
            # ça sert à rien. On laisse tomber.
            return

        cur_tile = self.tile_go_backward
        for _ in range(DIST_BACKWARD_CONQUEST[town.size]):
            if cur_tile.adjacencies[self.dir_back_diag] is None:
                break
            else:
                cur_tile = cur_tile.adjacencies[self.dir_back_diag]

        tile_bounding_rect_opposite = cur_tile
        rect_xs = sorted([self.tile_go_backward.x, tile_bounding_rect_opposite.x])
        rect_ys = sorted([self.tile_go_backward.y, tile_bounding_rect_opposite.y])
        self.bounding_rect_go_back = (
            rect_xs[0],
            rect_ys[0],
            rect_xs[1] + 1,
            rect_ys[1] + 1,
        )
        self.tile_magnet = self.tile_go_backward

    def _process_backward_conquest_town_tile(self, select_tile):
        """
        Gère l'envoi d'unité pour la tile de town qui fait le backward conquest.
        La town elle-même n'a pas d'unité. Elle va piocher dans son suburb.

        On envoit une unité tous les 4 tours de jeu, c'est géré par le param select_tile.
        """
        tile_dest = self.tile_go_backward.adjacencies[self.dir_back_diag]
        if tile_dest.town is not None:
            return
        # Ici, pas besoin de y*2 comme pour la fonction move_units_on_bare_tiles.
        # Les town ne sont pas tracés le long de diagonales.
        # On fait comme on veut, du coup on fait au plus simple.
        if (self.tile_go_backward.x + self.tile_go_backward.y) & 3 != select_tile:
            return
        if tile_dest.player_owner == self and tile_dest.nb_unit >= 16:
            return
        if self.tile_go_backward.suburb_owner is None:
            raise Exception("tile_go_back town sans Suburb. Not supposed to happen.")
        # Arrivé ici, on a fait tous les checks nécessaires.
        # C'est le bon tour de jeu et la tile de destination peut accueillir le pixel.
        # Il n'y a plus qu'à trouver des pixels consentant dans le suburb et les envoyer !
        nb_unit_sent = 0
        for tile_src in self.tile_go_backward.suburb_owner.real_suburb_tiles:
            if tile_src.player_owner == self and tile_src.nb_unit >= 2:
                tile_src.remove_unit()
                nb_unit_sent += 1
                if nb_unit_sent == self.nb_unit_to_send_backward:
                    break
        tile_dest.add_unit(self, nb_unit_sent)

    def process_backward_conquest(self, turn_index):
        """
        Gère l'envoi d'unité pour toutes les tiles qui doivent faire le backward conquest.
        """
        if not self.bounding_rect_go_back:
            return
        select_tile = turn_index & 3
        self._process_backward_conquest_town_tile(select_tile)

    def merge_town(self, towns_to_remove, size_new_town):
        """
        Fusionne une town.
        Supprime les towns de la liste towns_to_remove, et crée à la place une nouvelle town
        ayant la taille de size_new_town.
        Il n'y a pas de check de cohérence entre les towns supprimées et celle créée. Il faut
        avoir fait les vérifs avant.

        La fonction met à jour les trucs qu'il faut (lien de tile vers town, etc), mais elle
        ne fait rien concernant les suburbs, car il n'y a rien à faire.
        Un merge ou un shatter de town n'ont aucune influence sur la façon dont sont organisés
        les suburbs. Car ça ne change rien au niveau des tiles. Les tiles ayant une town en ont
        toujours une, les tiles n'en ayant pas n'en ont toujours pas.

        La nouvelle town récupère les points de génération d'unités de toutes les towns supprimées.
        """
        x_new_town = []
        y_new_town = []
        unit_gen_points = 0
        # Le coin supérieur gauche de la nouvelle town correspondra au coin supérieur gauche
        # de la town supprimée qui est le plus en haut à gauche. Si les params sont cohérents,
        # la nouvelle town sera créée au bon endroit.
        for town in towns_to_remove:
            x_new_town.append(town.x_left)
            y_new_town.append(town.y_up)
            unit_gen_points += town.unit_gen_points
        self.remove_towns(towns_to_remove)
        x_new_town = min(x_new_town)
        y_new_town = min(y_new_town)
        new_town = Town(
            x_new_town, y_new_town, size_new_town, self, self.game_master, False
        )
        new_town.unit_gen_points = unit_gen_points
        self.add_towns([new_town])
        # Mise à jour des liens vers les towns, qui sont dans les tiles concernées.
        for tile in new_town.tiles_position:
            tile.town = new_town
            tile.update_linked_gamobjs()
        # Maintenant que tout a été bien fini (suppressions et ajouts de town),
        # on fait un dernier petit dirtify, pour prévenir l'interface que faut refaire
        # une dernière fois la vérif de modif éventuelle de la town sélectionnée.
        self.player_interface.dirtify_town_list()

    def shatter_town(self, town_to_shatter, size_new_town):
        """
        Le nom de la fonction ressemble à Chatterton. Lolilol !

        Détruit une town et crée 4 towns plus petite à la place.
        Le param size_new_town doit être égal à la taille de la town à supprimer,
        divisée par deux. Sinon ça donnerait n'importe quoi.

        Les points de génération de la town détruite sont divisés en 4
        et donnés à chaque nouvelle town. Il peut y avoir de la perte, car on fait
        une divison entière. C'est comme ça. La réurbanisation, ça coûte des ressources.

        Comme pour merge_town, on ne fait rien dans les suburbs, car un shatter ne modifie
        pas l'organisation des suburbs.
        """
        unit_gen_points_new_towns = town_to_shatter.unit_gen_points // 4
        x_left = town_to_shatter.x_left
        y_up = town_to_shatter.y_up
        self.remove_towns([town_to_shatter])
        coord_new_towns = (
            (x_left, y_up),
            (x_left + size_new_town, y_up),
            (x_left, y_up + size_new_town),
            (x_left + size_new_town, y_up + size_new_town),
        )
        new_towns = []
        for x, y in coord_new_towns:
            new_town = Town(x, y, size_new_town, self, self.game_master, False)
            new_town.unit_gen_points = unit_gen_points_new_towns
            for tile in new_town.tiles_position:
                tile.town = new_town
                tile.update_linked_gamobjs()
            new_towns.append(new_town)
        self.add_towns(new_towns)
        # Maintenant que tout a été bien fini (suppressions et ajouts de town),
        # on fait un dernier petit dirtify, pour prévenir l'interface que faut refaire
        # une dernière fois la vérif de modif éventuelle de la town sélectionnée.
        self.player_interface.dirtify_town_list()

    def check_town_size_1_merge(self, cur_town):
        """
        Renvoie False si il n'y a rien à faire.
        Renvoie True si on a retenu quelque chose à faire, c'est à dire si on a
        modifié self.town_to_shatter ou self.towns_to_merge.
        """
        tile_of_town = cur_town.tiles_position[0]
        tiles_aside = [
            tile_of_town.adjacencies[self.dir_forw_hori],
            tile_of_town.adjacencies[self.dir_forw_verti],
            tile_of_town.adjacencies[self.dir_forw_diag],
        ]
        if None in tiles_aside:
            return False
        towns_aside = [tile.town for tile in tiles_aside]
        if None in towns_aside:
            return False
        if any((town.player_owner != self for town in towns_aside)):
            return False

        can_modify = True
        potential_towns_to_shatter = []
        for town in towns_aside:
            if town.size != 1:
                if cur_town.sorting_key < town.sorting_key:
                    potential_towns_to_shatter.append(town)
                else:
                    can_modify = False

        if not can_modify:
            return False

        if potential_towns_to_shatter:
            self.town_to_shatter = potential_towns_to_shatter[0]
            return True
        else:
            self.towns_to_merge = [cur_town] + towns_aside
            return True

    def check_town_size_2_merge(self, cur_town):
        """
        Vérifie si la town passée en paramètre, qui doit avoir une size de 2, peut être fusionnée
        avec 3 autres towns de size 2 bien placée. Si c'est le cas, la variable membre
        self.towns_to_merge sera définie.
        Vérifie aussi si cette town devrait déclencher un shatter d'une town de size 4, pour
        pouvoir refaire un merge à un autre endroit.
        Une town de size 1 peut déclencher un shatter de towns de size 2 et 4.
        Une town de size 2 ne peut déclencher un shatter que pour les towns de size 4.

        Si une town de size 2 ne peut être fusionnée à cause d'un mauvais placement d'une autre town
        de size 2, cette fonction n'a pas à le gérer. C'est le shatter par une town de size 1
        qui le fera.

        On checke que 3 cases. Celles où on est censé avoir le left_up
        des 3 villes avec lesquelles on merge. (2*forward chacune)
        Si, sur l'une de ces 3 cases, on a :
         - une ville de taille 4,
         - avec des modulos de left_up égaux à ceux de cur_town,
         - qui est située plus loin selon le tri par sort_key_xxx,
         - et qu'on a aucune ville de taille 4 située avant selon le tri par sort_key_xxx,
        alors on shatter cette ville de taille 4 qui est située plus loin.
        Si tout ça n'est pas réuni, on shatter rien du tout, car ça risque de tout pourrir.
        """
        tile_of_town = cur_town.tiles_position[0]
        # Récupération des 3 cases que l'on checke : tile_diag_2, tile_forw_hori, tile_forw_verti.
        tile_diag_1 = tile_of_town.adjacencies[self.dir_forw_diag]
        if tile_diag_1 is None:
            return False
        tile_diag_2 = tile_diag_1.adjacencies[self.dir_forw_diag]
        if tile_diag_2 is None:
            return False
        tile_forw_hori = tile_of_town.adjacencies[self.dir_forw_hori]
        tile_forw_hori = tile_forw_hori.adjacencies[self.dir_forw_hori]
        tile_forw_verti = tile_of_town.adjacencies[self.dir_forw_verti]
        tile_forw_verti = tile_forw_verti.adjacencies[self.dir_forw_verti]
        tiles_aside = [tile_forw_verti, tile_forw_hori, tile_diag_2]
        # Récupération des 3 towns associées à ces 3 cases.
        # Si on n'a pas 3 towns, ou si l'une d'elle a une taille de 1, pas de merge/shatter possible.
        # On s'en va.
        towns_aside = [tile.town for tile in tiles_aside]
        if None in towns_aside:
            return False
        if 1 in [town.size for town in towns_aside]:
            return False

        x_modu_cur_town = cur_town.x_left % 2
        y_modu_cur_town = cur_town.y_up % 2
        for town in towns_aside:
            if town.x_left % 2 != x_modu_cur_town or town.y_up % 2 != y_modu_cur_town:
                # L'une des towns de taille 2 n'est pas placée au bon endroit
                # par rapport à cur_town. Pas de merge/shatter possible.
                return False
        if any((town.player_owner != self for town in towns_aside)):
            # Tout est bien placé, mais au moins une des towns n'appartient pas à Player.
            return False

        can_modify = True
        potential_towns_to_shatter = []
        for town in towns_aside:
            if town.size == 4:
                if cur_town.sorting_key < town.sorting_key:
                    # Il y a une town de taille 4 qui gêne, et elle est placée après.
                    # On pourra peut-être la shatterer.
                    potential_towns_to_shatter.append(town)
                else:
                    # Il y a une town de taille 4 qui gêne, mais elle est placée avant.
                    # C'est elle qui a la priorité. On ne la shatter pas.
                    # Et donc, pas de merge/shatter possible.
                    # La ville cur_town va rester comme elle est.
                    can_modify = False
        if not can_modify:
            return False

        if potential_towns_to_shatter:
            # Il faudrait shatterer une ou plusieurs towns pour faire un merge ultérieur.
            # Pas besoin de se souvenir de tout ce qu'il faut shatterer.
            # On signale juste la première.
            # Lors d'une prochaine exécution de la fonction process_town_merging, on retrouvera
            # les éventuelles autres towns à shatterer, et on s'en occupera.
            self.town_to_shatter = potential_towns_to_shatter[0]
            return True
        else:
            # Youpi ! On peut faire un merge !
            self.towns_to_merge = [cur_town] + towns_aside
            return True

    def process_town_merging(self):
        """
        Gère tous les merge/shatter des towns. Cette gestion est décomposée en plusieurs
        petites étapes, on en effectue une seule à chaque tour. Ça permet de ne pas faire de
        gros traitements qui ralentirait le jeu, et ça permet aussi de montrer les étapes
        intermédiaires de merge/shatter. On voit petit à petit les villes se réorganiser,
        et je trouve ça cool.

        L'étape en cours est renseignée par les variables membres
        town_merge_state, towns_to_merge et town_to_shatter.

        Ça se passe comme ça :

        town_merge_state == TOWN_MERGE_STATE_STABLE : on a tout vérifié récemment,
        il n'y a rien à faire. Dès qu'une nouvelle town est construite par Player, on entame un
        cycle de vérification, avec TOWN_MERGE_STATE_UNSORTED.

        town_merge_state == TOWN_MERGE_STATE_UNSORTED : on trie la liste self.towns, selon l'ordre
        town.sorting_key (un tuple précalculé pour chaque town), qui permet de savoir quelles towns
        doivent être mergées en priorité. (voir fonction get_town_infos_right_down).

        town_merge_state = TOWN_MERGE_STATE_UNCHECKED : on parcourt toutes les towns.
        Dès qu'on en trouve une qui doit être mergée, ou shatterée, on arrête le parcours,
        et on retient ce qu'on a trouvé. Soit self.towns_to_merge devient différent de None,
        soit self.town_to_shatter devient différent de None.
        Si on n'a rien trouvé à faire, town_merge_state prend la valeur TOWN_MERGE_STATE_STABLE,
        et on met la gestion en pause, jusqu'à la prochaine construction de ville
        où on revérifie tout.
        À priori, la vérification complète de toutes les villes ne prend pas beaucoup de temps.
        On peut donc se permettre de tout vérifier en un seul tour.

        towns_to_merge is not None : on merge les town qui ont été retenues comme étant à merger.
        Cette action modifie la liste de towns, donc on revient à l'étape TOWN_MERGE_STATE_UNSORTED
        et on refait tout un processus de vérification.

        self.town_to_shatter : on shatter la town qui a été retenue comme étant à shatterer,
        puis on revient à l'étape TOWN_MERGE_STATE_UNSORTED pour refaire le processus.

        Cette gestion a la garantie qu'on n'aura jamais de cycle infinie de merge/shatter, grâce
        au fait qu'on ait ordonné les villes (avec town.sorting_key).
        Il suffit d'instaurer ces règles :
         - on merge tout ce qu'on peut merger.
         - on shatter une town uniquement si elle empêche un merge, et uniquement si la
           première town du merge empêché se trouve avant la town à shatterer.
        """
        if self.town_merge_state == TOWN_MERGE_STATE_STABLE:
            return

        if self.town_merge_state == TOWN_MERGE_STATE_UNSORTED:
            self.towns.sort(key=lambda town: town.sorting_key)
            self.town_merge_state = TOWN_MERGE_STATE_UNCHECKED
            return

        if self.towns_to_merge:
            self.merge_town(self.towns_to_merge, self.towns_to_merge[0].size * 2)
            self.towns_to_merge = None
            return

        if self.town_to_shatter:
            self.shatter_town(self.town_to_shatter, self.town_to_shatter.size // 2)
            self.town_to_shatter = None
            return

        if self.town_merge_state == TOWN_MERGE_STATE_UNCHECKED:
            for cur_town in self.towns:

                # Vérification des merge/shatter pour les villes ayant une size de 1
                if cur_town.size == 1:
                    if self.check_town_size_1_merge(cur_town):
                        return
                # Vérification des merge/shatter pour les villes ayant une size de 2
                elif cur_town.size == 2:
                    if self.check_town_size_2_merge(cur_town):
                        return

            # On a vérifié toutes les towns, aucun merge ni aucun shatter à faire.
            # On se remet dans l'état stable, et on est en pause.
            self.town_merge_state = TOWN_MERGE_STATE_STABLE

    def process_unit_gen_tile(self):
        """
        Gère la génération des unités produites par la possession de terrain.
        Les unités produites ainsi sont placées au hasard, sur n'importe quelle tile contrôlée
        par Player et pouvant accueillir une unité. Ça peut être sur une road,
        ou sur une "bare tile". Si c'est sur une bare tile, l'unité se déplacera progressivement
        en forward, jusqu'à rejoindre une route (ou pas, mais c'est le problème de Player).

        La gestion de choix de la tile au hasard est faite de manière un peu particulière.
        Et de toutes façons ça va changer. Voir commentaire dans la fonction.
        """
        if self.unit_gen_tile < UNIT_GEN_TILE_POINT_MAX_CUMUL:
            self.unit_gen_tile += len(self._controlled_tiles)
        if self.unit_gen_tile < UNIT_GEN_TILE_POINT_REQUIRED:
            return

        tile_target = None
        if self.unit_gen_tile_nb_turn_fail < 10:
            tile_target = random.choice(self._controlled_tiles)
            if tile_target.town is not None or tile_target.nb_unit >= 16:
                # On peut pas ajouter de unit sur la tile choisie.
                # On s'en va direct, et on retentera sa chance au prochain tour.
                # Si la personne qui joue a beaucoup de ville et beaucoup de tile pleine,
                # elle aura du retard dans la génération de ses units.
                # C'est son problème. Elle a qu'à gérer mieux son expansion.
                tile_target = None
        else:
            # Ça fait 10 tours de jeu qu'on n'arrive pas à placer la unit générée.
            # Du coup, on cherche une tile où c'est possible et on prend la
            # première qui va bien. Ça évite de se retrouver à exécuter un random.choice
            # à chaque tour de jeu pour rien.
            for pot_tile_target in self._controlled_tiles:
                if pot_tile_target.town is None and pot_tile_target.nb_unit < 16:
                    tile_target = pot_tile_target
                    break

        if tile_target is None:
            self.unit_gen_tile_nb_turn_fail += 1
        else:
            tile_target.add_unit(self)
            self.unit_gen_tile -= UNIT_GEN_TILE_POINT_REQUIRED
            self.unit_gen_tile_nb_turn_fail = 0

    def process_unit_gen_tile_bionature(self, turn_index=0):
        """
        Gère la génération des unités produites par la possession de terrain, dans le cas
        où Player est de type "bionature" (les pixels verts).
        Les unités de bionature peuvent être placées sur une tile déjà contrôlée par la bionature,
        ou sur une tile adjacente si elle n'est contrôlée par personne.

        On permet donc à la bionature de s'étendre progressivement, mais jamais de conquérir
        des tiles occupées par d'autres Player, ou d'éliminer d'autres unités.
        Comme ça, la bionature n'embête pas trop les autres Player,
        tout en ayant quand même des possibiltés d'envahissement.

        On choisit d'abord une tile contrôlée par la bionature et pouvant accueillir une unité
        de plus, ensuite on regarde les tiles autour qui sont vides, et on choisi parmi la première
        tile, ou l'une des autres.
        Ça fait une probabilité plus grande de choisir une tile vide plutôt qu'une tile déjà
        occupée. C'est ce qu'on veut, ça fait une bionature qui va plutôt avoir tendance
        à s'étendre, et c'est cool.
        """
        if self.unit_gen_tile < UNIT_GEN_TILE_POINT_MAX_CUMUL:
            self.unit_gen_tile += len(self._controlled_tiles)
        if self.unit_gen_tile >= UNIT_GEN_TILE_POINT_REQUIRED_BIONATURE:
            tile_target = random.choice(self._controlled_tiles)
            # Là c'est un peu pourri. Si toutes les tiles de la bionature sont au max,
            # avec 16 pixels, alors on ne peut plus choisir aucune tile de départ.
            # Donc on ne peut même plus s'étendre sur les autres tiles.
            # On ne gère pas ce cas, car il est quand même très rare.
            # Et il se règle tout seul dès qu'on élimine une seul unité de bionature.
            if tile_target.town is not None or tile_target.nb_unit >= 16:
                return
            potential_tiles = [
                tile
                for tile in tile_target.adjacencies
                if tile is not None and tile.player_owner is None and tile.town is None
            ]
            potential_tiles.append(tile_target)
            # On choisit la potential tile avec un faux random à la turn_index.
            # Pas besoin de faire du vrai random pour ça.
            tile_target_final = potential_tiles[turn_index % len(potential_tiles)]
            tile_target_final.add_unit(self)
            self.unit_gen_tile -= UNIT_GEN_TILE_POINT_REQUIRED_BIONATURE

    def process_line_conquest(self):
        """
        Gère les "line conquest", permettant à Player de s'étendre sur l'aire de jeu.
        Une line conquest est gérée par les variables membres suivantes :
         - self.tiles_to_roadify : liste de tile (censées être disposées sur une ligne),
           sur lesquelles on doit construire des roads.
         - self.is_roadify_horiz : Booléean indiquant s'il faut construire des roads horizontales
           ou verticales.
         - self.tile_to_townify : une tile, censée être au bout de la ligne de roads. On doit
           construire une ville sur cette tile, lorsque toutes les roads auront été construites.
           Pour que ça fonctionne bien, il faut que le dernier élément de tiles_to_roadify
           soit égal à tile_to_townify. (On peut aussi avoir tile_to_townify à None, si on ne
           veut pas construire de ville à la fin de la ligne).

        Cette fonction est exécutée à chaque tour de jeu, elle effectue un peu de construction
        et/ou un peu de vérification à chaque tour. Ça permet de montrer progressivement
        la conquête de Player, et de pas surcharger les traitements, comme d'hab'.

        La méthode est la suivante :
         - Vérifier la présence de la route à construire sur la première case de tiles_to_roadify.
         - Si pas de route, on la construit, même si la tile contient des unités appartenant
           à l'autre Player.
         - Si il a fallu construire la route, on se met en pause durant "DELAY_ROADIFY" tours.
           Ça permet de donner l'impression que les routes mettent un peu de temps à se construire.
           Le temps de pause restant est stocké dans self.delay_roadify.
         - magnétiser la tile sur laquelle on vient de construire la route.
         - attendre que cette tile soit contrôlée par Player, avec au moins 2 unités dessus.
           Cela peut prendre plus ou moins de temps, selon les unités qui sont déjà dessus, la
           quantité d'unité que peut mobiliser Player, etc.
         - enlever cette tile de tiles_to_roadify et passer à la suivante.

        Cette méthode gère correctement le cas où Player déclenche une line conquest sur des roads
        déjà construite, dont certaines tiles sont déjà contrôlée par Player.
        Dans ce cas, on passe très vite (en quelques tours) sur les tiles
        déjà construites et contrôlées, et on s'occupe comme il faut de conquérir les autres tiles,
        grâce à la magnétisation.

        Lorsqu'il n'y a plus de tiles_to_roadify, on passe à la construction de la town.
        La méthode est la suivante (beaucoup plus simple) :
         - magnétiser tile_to_townify.
         - attendre que la tile soit contrôlée par Player, avec 16 unités dessus.
         - lancer la construction de la ville. Le reste du code se charge d'amener la construction
           jusqu'au bout, si c'est possible.

        FUTURE : faudrait gérer le cas où l'autre Player construit une ville
        en plein pendant que Player fait une line conquest.
        Mais pour l'instant osef. On verra si c'est vraiment important quand on testera à 2.
        """
        if not self.tiles_to_roadify and not self.tile_to_townify:
            return
        if self.delay_roadify:
            self.delay_roadify -= 1
            return
        if self.tiles_to_roadify:
            first_tile = self.tiles_to_roadify[0]
            if self.tile_magnet != first_tile:
                self.tile_magnet = first_tile
            if first_tile.town is not None:
                self.tiles_to_roadify.pop(0)
                return
            if self.is_roadify_horiz and not first_tile.road_horiz:
                first_tile.add_road(horiz=True)
                self.delay_roadify = DELAY_ROADIFY
                return
            if not self.is_roadify_horiz and not first_tile.road_vertic:
                first_tile.add_road(vertic=True)
                self.delay_roadify = DELAY_ROADIFY
                return
            if first_tile.player_owner == self and first_tile.nb_unit > 2:
                self.tiles_to_roadify.pop(0)
                return
        else:
            if self.tile_magnet != self.tile_to_townify:
                self.tile_magnet = self.tile_to_townify
            if (
                self.tile_to_townify.player_owner == self
                and self.tile_to_townify.nb_unit >= 16
            ):
                if self.tile_building_town is None:
                    self.tile_building_town = self.tile_to_townify
                    self.tile_to_townify = None

    def init_first_units_and_town(self):
        # Zut, j'ai déjà fait ce genre de petit bout de code ici et là,
        # mais flemme de le factoriser.
        if self.rightward:
            x_first_town = 1
        else:
            x_first_town = self.w - 2
        if self.downward:
            y_first_town = 1
        else:
            y_first_town = self.h - 2
        tile_first_town = self.game_master.game_area[y_first_town][x_first_town]
        tile_first_town.add_unit(self, 16)
        tile_first_town.build_town()

        for tile_adj in tile_first_town.town.adjacent_tiles:
            tile_adj.add_road(True, True)
            tile_adj.add_unit(self, 16)
        tile_back = tile_first_town.adjacencies[self.dir_back_diag]
        tile_back.add_unit(self, 14)

    def auto_build_towns(self):
        if self.tile_building_town is not None:
            return

        if self.tile_to_townify is not None and self.tile_to_townify.town is not None:
            self.tile_to_townify = None
            return

        if self.tile_to_townify is None and self.active_towns:
            selected_town = random.choice(self.active_towns)
            if selected_town.unit_gen_tiles:
                self.tile_to_townify = selected_town.unit_gen_tiles[0]


class Town:
    """
    Une ville, placée sur une seule tile, ou qui s'étend sur un carré de 2x2 ou 4x4 tiles.

    Les villes sont imprenables et indestructibles (ça simplifie le jeu), mais elles peuvent
    être fusionnées/shatterées avec d'autres villes de la même couleur.
    """

    # clé : un tuple. (taille town, rightward, downward)
    # valeur : les index, dans la liste self.tiles_position, des tiles
    #          qui génèrent des missiles.
    # Il n'y a pas la taille de town = 1, car pour cette tile, la liste se déduit très facilement.
    DICT_INDEX_MISSILE_TILES = {
        (2, False, False): (1, 2),
        (2, True, True): (2, 1),
        (2, False, True): (0, 3),
        (2, True, False): (3, 0),
        (4, False, False): (3, 6, 9, 12),
        (4, True, True): (12, 9, 6, 3),
        (4, False, True): (0, 5, 10, 15),
        (4, True, False): (15, 10, 5, 0),
    }

    def __init__(
        self, x_left, y_up, size, player_owner, game_master, create_suburb=True
    ):
        # Coordonnées du coin supérieur gauche de la ville.
        self.x_left = x_left
        self.y_up = y_up
        self.size = size
        self.player_owner = player_owner
        # Le game master qui gère tout le jeu.
        self.game_master = game_master
        # Une town est active si elle a au moins une tile non-town adjacente.
        # C'est à dire qu'elle peut générer des unités et les placer autour d'elle.
        self.is_active = True
        self.unit_gen_points = UNIT_GEN_TOWN_POINT_REQUIRED - 5
        # Formule compliquée, juste pour dire :
        # size 1 : 1 point de génération. size 2 : 6. size 4 : 22.
        self.unit_gen_speed = size ** 2 + size * 2 * (size > 1)

        # Liste des tiles sur lesquelles est placée la town. La première tile est toujours celle
        # du coin supérieur gauche, quel que soit la direction de conquête de Player.
        self.tiles_position = []
        for y in range(y_up, y_up + size):
            for x in range(x_left, x_left + size):
                self.tiles_position.append(self.game_master.game_area[y][x])

        self._compute_unit_gen_tiles()
        self.adjacent_tiles = tuple([tile for tile in self.unit_gen_tiles])
        self.update_unit_gen_tiles()
        self.built_all_adjacent_roads = False
        x_behind, y_behind, self.sorting_key = self.player_owner.get_town_infos(self)
        # tile_go_backward_diag est la tile de town qui est la plus backward possible.
        # C'est elle qui sera utilisée pour envoyer les units lors d'une backward conquest.
        self.tile_go_backward_diag = self.game_master.game_area[y_behind][x_behind]
        # Détermination de la liste des tiles générant des missiles.
        if self.size == 1:
            self.tiles_gen_missile = self.tiles_position
        else:
            missile_tile_indexes_key = (
                self.size,
                self.player_owner.rightward,
                self.player_owner.downward,
            )
            self.tiles_gen_missile = [
                self.tiles_position[index]
                for index in Town.DICT_INDEX_MISSILE_TILES[missile_tile_indexes_key]
            ]
        # Si c'est une town qui vient d'être construite, on lui crée tout de suite son petit suburb
        # (qui sera éventuellement fusionné avec d'autres juste après).
        # Si c'est une town créée suite à des merge/shatter, on ne crée pas de suburb.
        # Il y en a déjà un.
        if create_suburb:
            suburb_of_this_town = Suburb(self, self.game_master)

    def get_suburb_owner(self):
        """
        Renvoie le suburb auquel appartient cette town.
        """
        # Toutes les tiles d'une même town ont le même suburb owner. Puisque c'est la même town.
        # Donc on se prend pas la tête, on renvoie le suburb owner de la première tile de la town.
        # Pas besoin de checker les autres ni de vérifier que c'est le même suburb owner pour
        # tout le monde.
        return self.tiles_position[0].suburb_owner

    def _apply_coord_offsets_and_filter(self, x_base, y_base, offsets):
        """
        Renvoie une liste de tile en fonction d'une coordonnée de départ et d'une liste
        d'offset (x, y). Au passage, on filtre : on vérifie que les coordonnées
        ne dépassent pas les bords de l'aire de jeu.
        """
        return [
            self.game_master.game_area[y_base + y_offset][x_base + x_offset]
            for (x_offset, y_offset) in offsets
            if 0 <= x_base + x_offset < self.game_master.w
            and 0 <= y_base + y_offset < self.game_master.h
        ]

    def _compute_unit_gen_tiles(self):
        """
        Calcule la variable unit_gen_tiles. C'est la liste de tiles où on pose les units.
        L'ordre des tiles est donnée avec le horiz en priorité, puis le vertic.
        L'ordre est en accord avec la direction de conquête de Player.
        Faudrait faire un schéma, mais pfouuuu...

        Calcule également les listes tiles_cmd_go_backward_horiz et tiles_cmd_go_backward_vertic.
        Ce sont les listes de tiles à partir desquelles la town envoie ses commandes "go backward".
        """
        size = self.size
        wardnesses = (self.player_owner.rightward, self.player_owner.downward)
        if wardnesses == (True, False):
            unit_gen_offsets = (
                [(size, size - 1 - offset) for offset in range(size)],
                [(offset, -1) for offset in range(size)],
                [(-1, size - 1 - offset) for offset in range(size)],
                [(offset, size) for offset in range(size)],
            )
        elif wardnesses == (False, True):
            unit_gen_offsets = (
                [(-1, offset) for offset in range(size)],
                [(size - 1 - offset, size) for offset in range(size)],
                [(size, offset) for offset in range(size)],
                [(size - 1 - offset, -1) for offset in range(size)],
            )
        elif wardnesses == (True, True):
            unit_gen_offsets = (
                [(size, offset) for offset in range(size)],
                [(offset, -1) for offset in range(size)],
                [(-1, offset) for offset in range(size)],
                [(offset, size) for offset in range(size)],
            )
        elif wardnesses == (False, False):
            unit_gen_offsets = (
                [(-1, size - 1 - offset) for offset in range(size)],
                [(size - 1 - offset, -1) for offset in range(size)],
                [(size, size - 1 - offset) for offset in range(size)],
                [(size - 1 - offset, size) for offset in range(size)],
            )
        else:
            raise Exception("Bad wardnesses. Not supposed to happen.")

        # On filtre d'abord. Et ensuite on additionne les listes.
        (horiz_first, vertic_first, horiz_second, vertic_second) = unit_gen_offsets
        horiz_first = self._apply_coord_offsets_and_filter(
            self.x_left, self.y_up, horiz_first
        )
        vertic_first = self._apply_coord_offsets_and_filter(
            self.x_left, self.y_up, vertic_first
        )
        horiz_second = self._apply_coord_offsets_and_filter(
            self.x_left, self.y_up, horiz_second
        )
        vertic_second = self._apply_coord_offsets_and_filter(
            self.x_left, self.y_up, vertic_second
        )

        self.unit_gen_tiles = horiz_first + vertic_first + horiz_second + vertic_second
        self.tiles_cmd_go_backward_horiz = tuple(horiz_second)
        self.tiles_cmd_go_backward_vertic = tuple(vertic_second)

    def update_unit_gen_tiles(self):
        """
        Met à jour la liste self.unit_gen_tiles, ainsi que self.is_active,
        en fonction des towns autour.
        La mise à jour de self.unit_gen_tiles ne fait que des suppressions de tiles (pas d'ajout).
        On enlève les tiles au fur et à mesure que des towns adjacentes se construisent.
        """
        self.unit_gen_tiles = [
            tile for tile in self.unit_gen_tiles if tile.town is None
        ]

        if not self.unit_gen_tiles:
            # La town est entourée de town. Elle ne peut plus générer d'unité.
            # On la désactive, et on met à jour la liste des towns active de Player.
            self.is_active = False
            # La town garde ses points de génération de unit.
            # Ils seront réutilisés si la town est fusionnée avec d'autres.
            # Et si c'est une town de size max et qu'elle est désactivée, eh bien
            # ces points ne servent plus à rien. Player avait qu'à mieux gérer son urbanisme.
            self.player_owner.update_active_towns()
            # Il faut updater la liste des gamobjects de chaque tile de la town,
            # car lorsque la town est désactivée, on l'affiche en plus foncée.
            for tile in self.tiles_position:
                tile.update_linked_gamobjs()

    def process_unit_generation(self):
        """
        Gère la construction des routes autour d'une town,
        ainsi que la génération d'unités par les towns.
        Une town crée de temps en temps une unité, sur une de ses case adjacente.
        """
        self.unit_gen_points += self.unit_gen_speed
        self.unit_gen_points = min(self.unit_gen_points, UNIT_GEN_TOWN_POINT_MAX_CUMUL)

        if not self.built_all_adjacent_roads:
            if self.unit_gen_points % 5 == 0:
                all_roads_are_controlled = True
                # Il faut créer les routes tout autour de la ville.
                # On en crée une à chaque fois, pas plus.
                # Ça fait des routes qui se construisent progressivement,
                # c'est toujours rigolo à regarder.
                for tile in self.unit_gen_tiles:
                    if (
                        tile.road_horiz
                        and tile.road_vertic
                        and self.player_owner != tile.player_owner
                    ):
                        # Toutes les tiles de routes autour de la town
                        # ne sont pas contrôlées par Player.
                        all_roads_are_controlled = False
                        break

                if all_roads_are_controlled:
                    # On n'a pas encore construit toutes les routes autour de la town,
                    # mais les cases ayant des routes sont toutes contrôlées par Player.
                    # On peut donc se permettre de construire une route de plus.
                    # Ça va automatiquement étendre le suburb de la town, ce qui permettra
                    # de répartir les unités de Player sur plus de tiles
                    # (si Player a assez d'unités).
                    for tile in self.unit_gen_tiles:
                        if not tile.road_horiz or not tile.road_vertic:
                            tile.add_road(True, True)
                            if all(
                                [
                                    tile.road_horiz and tile.road_vertic
                                    for tile in self.unit_gen_tiles
                                ]
                            ):
                                self.built_all_adjacent_roads = True
                            # On a construit une route.
                            # On ne produit pas forcément l'unité que la ville devrait produire.
                            # Ce n'est pas trop grave, ça décale la production juste pour un tour,
                            # puisque les points de production unit_gen_points sont conservés.
                            return

        if self.unit_gen_points > UNIT_GEN_TOWN_POINT_REQUIRED:
            # On ajoute une unité sur n'importe quelle tile, osef.
            # Le suburb s'occupera de les répartir comme il faut.
            for tile in self.unit_gen_tiles:
                if self.player_owner != tile.player_owner or tile.nb_unit < 16:
                    tile.add_unit(self.player_owner)
                    self.unit_gen_points -= UNIT_GEN_TOWN_POINT_REQUIRED
                    return

            # Si on est arrivé à la fin de la boucle, on aurait du générer une unit,
            # mais on n'a aucun endroit où la placer. Tant pis, on testera au prochain tour.
            # C'est pour ça qu'on peut cumuler plus de points de génération que le coût de
            # création d'une unit. Ça permet d'avoir un petit délai dans la génération,
            # sans perdre de points.


class Suburb:
    """
    Un suburb peut contenir des towns de différents players.
    Les suburbs sont neutres et sont gérés pas le game_master. Les players n'en on pas besoin.
    Les suburbs servent uniquement à répartir les units autour.

    Variables membres importantes des suburbs :
     - town_tiles : liste de tiles contenant les towns appartenant à ce suburb.
       une town est toujours dans un et un seul suburb.
     - real_suburb_tiles : toutes les tiles de roads adjacentes à une town du suburb.
     - potential_tiles : les tiles non-road et non-ville, adjacentes à une town du suburb.
       c'est à dire qu'elles sont pas dans le suburb, mais pourraient y être si on construit
       une road dessus.
     - bounding_rect : rectangle englobant toutes les tiles et potential tiles du suburb.
       (On s'en sert uniquement pour accélerer les traitements).

    Lorsqu'une ville est créée sur une potential ou real tile d'un suburb existant, on crée
    le mini-suburb autour de la nouvelle ville, et on le fusionne tout de suite
    avec le suburb existant.

    Lorsqu'une route est créée, il faut vérifier si la tile n'appartient pas aux potential tiles
    de un ou plusieurs suburbs. Lorsque c'est le cas, on transfère cette tile de potential à real.
    Si on l'a fait pour plusieurs suburbs, on fusionne tous ces suburbs ensemble.

    On a besoin que de deux choses pour gérer l'évolution des suburbs.
    La fonction de merge, et une petite fonction, dans la classe Town,
    qui va créer un mini-suburb de 4 tiles potentielles autour d'une town.

    L'intérêt d'un suburb, c'est que les unités se répartissent équitablement entre les
    real_suburb_tiles du suburb.
    Et s'il y a des unités de couleurs différentes dans le suburb, elles s'éliminent
    automatiquement une par une, jusqu'à ce qu'il ne reste qu'une couleur.
    """

    def __init__(self, initial_town, game_master):
        self.game_master = game_master
        if initial_town.size != 1:
            raise Exception("Pas de création de suburb à partir de grandes towns.")
        self.town_tiles = list(initial_town.tiles_position)
        for tile in self.town_tiles:
            tile.suburb_owner = self
        all_suburb_tiles = [
            tile for tile in initial_town.adjacent_tiles if tile.town is None
        ]
        # Ici, on ne gère pas le cas de la coupure de connexions entre deux roads qui sont dans
        # le même suburb. Ça arrive jamais, car les nouveaux suburbs ne sont créés que avec des
        # towns ayant une size de 1.
        # Mais si on avait voulu pinailler, il aurait fallu exécuter
        # transfer_potential_road à chaque tile de route.
        self.real_suburb_tiles = []
        self.potential_tiles = []
        for tile in all_suburb_tiles:
            if tile.road_horiz or tile.road_vertic:
                self.real_suburb_tiles.append(tile)
                tile.suburb_owner = self
            else:
                self.potential_tiles.append(tile)
        self._update_bounding_rect()
        self.game_master.suburbs.append(self)

    def _update_bounding_rect(self):
        """
        Définit self.bounding_rect. Une liste de 4 int. x1, y1, x2, y2.
        On englobe toutes les tiles du suburb.
        Comme d'hab' en python, le rect s'étend de x1 à x2 - 1, et de y1 à y2 - 1.
        Comme les ranges.
        """
        all_tiles = self.town_tiles + self.real_suburb_tiles + self.potential_tiles
        xs = [tile.x for tile in all_tiles]
        ys = [tile.y for tile in all_tiles]
        self.bounding_rect = (min(xs), min(ys), max(xs) + 1, max(ys) + 1)

    def transfer_potential_road(self, tile):
        """
        Transfert une tile de la liste self.potential_tiles vers la liste self.real_suburb_tiles,
        car une route (ou les deux routes) ont été construites dessus.
        """
        if tile not in self.potential_tiles:
            return
        if not tile.road_horiz and not tile.road_vertic:
            return
        self.potential_tiles.remove(tile)
        self.real_suburb_tiles.append(tile)
        tile.suburb_owner = self
        # Il faudrait mettre des valeurs "2" dans les connexions entre roads du même suburb.
        # C'est la classe Tile qui s'en charge.

    def merge(self, other_suburb):
        """
        Fusionne ce suburb avec un autre suburb passé en paramètre.
        Après la fusion, tout est dans le suburb self. Le other_suburb sera retiré du jeu.
        """
        roads_other_suburb = other_suburb.real_suburb_tiles
        # On met en commun toutes les tiles des deux suburbs et on en fait une grosse liste.
        # Et ensuite, on répartit ces tiles dans les 3 listes :
        # town_tiles, real_suburb_tiles, potential_tiles. En fonction de ce qu'il y a dessus.
        # On élimine bien entendu les doublons.
        # Et on met à jour les liens suburb_owner dans les tiles.
        all_tiles_two_suburbs = (
            self.potential_tiles
            + self.real_suburb_tiles
            + self.town_tiles
            + other_suburb.potential_tiles
            + other_suburb.real_suburb_tiles
            + other_suburb.town_tiles
        )
        self.town_tiles = []
        self.real_suburb_tiles = []
        self.potential_tiles = []

        for tile in all_tiles_two_suburbs:
            if tile.town is not None:
                tile.suburb_owner = self
                if tile not in self.town_tiles:
                    self.town_tiles.append(tile)
            elif tile.road_horiz or tile.road_vertic:
                tile.suburb_owner = self
                if tile not in self.real_suburb_tiles:
                    self.real_suburb_tiles.append(tile)
            else:
                if tile not in self.potential_tiles:
                    self.potential_tiles.append(tile)

        for road_tile in roads_other_suburb:
            # On met des connexions à 2 entre les routes d'un même suburb.
            # C'est à dire qu'on coupe ces connexions. Car l'équilibrage des
            # unités sera géré par le suburb lui-même.
            # Il faut checker toutes les routes du suburb mergé.
            # D'où l'intérêt de prendre le plus gros suburb et d'exécuter sa fonction merge,
            # avec le plus petit suburb en paramètre. Et non pas le contraire.
            # Sinon on se retrouve à rechecker plein de connexions déjà annulées.
            road_tile.update_all_road_adjacencies()

        self._update_bounding_rect()
        self.game_master.suburbs.remove(other_suburb)

    def __str__(self):
        coords_towns = [(tile.x, tile.y) for tile in self.town_tiles]
        coords_real = [(tile.x, tile.y) for tile in self.real_suburb_tiles]
        coords_poten = [(tile.x, tile.y) for tile in self.potential_tiles]
        return (
            f"Suburb. bounding rect : {self.bounding_rect}\n"
            f"Towns: {coords_towns}"
            f"Real : {coords_real}"
            f"Poten: {coords_poten}"
        )


class Tile:
    """
    Une tile. Une case dans l'aire de jeu.
    """

    GAMOBJ_BACKGROUND_FROM_ROADS = {
        (False, False): "_controls",
        (True, False): "_road_horiz",
        (False, True): "_road_vertic",
        (True, True): "_road_both",
    }

    def __init__(self, x, y, linked_gamobjs, game_master):
        self.x = x
        self.y = y
        self.linked_gamobjs = linked_gamobjs
        self.game_master = game_master
        # Contiendra des références vers les tiles adjacentes à cette tile.
        # (C'est le game master qui initialise cette liste, après avoir créé toutes les tiles)
        # Certains éléments de cette liste pourront rester à None, si la tile est sur un bord
        # de l'aire de jeu.
        self.adjacencies = [None for _ in range(8)]
        # self.road_adjacencies_same_player indique si la route est adjacente avec une autre route
        # contrôlée aussi par Player.
        # 0 : non
        # 1 : Oui. On doit transférer automatiquement des unités d'une tile à l'autre,
        #     dans le cas où la répartition est trop désequilibrée.
        # 2 : Il y a une connexion, mais c'est entre deux routes d'un même suburb.
        #     Dans ce cas, on n'équilibre pas par les routes.
        #     Ça s'équilibre tout seul par le suburb.
        # Dans cette liste, toutes les adjacences diagonales (1, 3, 5, 7) sont toujours à zéro.
        # Mais je laisse comme ça pour être homogène avec la gestion d'adjacence, qui utilise
        # systématiquement les nombres de 0 à 7.
        self.road_adjacencies_same_player = [0 for _ in range(8)]
        self.road_vertic = False
        self.road_horiz = False
        # Player qui contrôle la tile.
        self.player_owner = None
        self.nb_unit = 0
        # Référence éventuelle vers la town qui occupe cette tile. Pour les towns de size > 1,
        # on a alors plusieurs tiles qui ont cette référence vers une même town.
        self.town = None
        # La variable suburb_owner est définie par les Suburb.
        # Soit lors de la création d'un nouveau suburb, soit lors d'un merge.
        self.suburb_owner = None
        # Indique si une town est en cours de construction sur cette tile.
        self.town_building_step = 0

    def update_linked_gamobjs(self):
        """
        Grosse fonction, qui met à jour tous les game objects que possède cette tile, pour
        afficher à l'écran ce qu'il ya dessus.
        Cette fonction doit être appelée à chaque fois qu'on effectue un changement sur la tile :
        ajout/suppression d'unité, ajout de road, avancement de la construction d'une ville,
        merge/shatter de ville, etc.

        La fonction recalcule tous les game objects qui doivent être présents. C'est ensuite mis
        en cache, pour pouvoir faire un redraw rapide du jeu à l'écran.
        Trop la classe, on a l'impression de faire du double buffering.

        Lorsqu'on modifie des éléments d'interface : Player sélectionne une town, on affiche
        la destination d'un missile avant de le lancer, etc. Il ne faut pas modifier le contenu
        de la tile elle-même, donc pas besoin d'appeler cette fonction.
        """

        if self.player_owner is None:
            # détermination du background (avec route ou pas) dans le cas d'une tile contrôlée
            # par aucun Player. Rien de plus à faire dans ce cas, car si aucun Player
            # ne contrôle la tile, il n'y a pas grand chose à afficher dessus.
            if self.road_horiz or self.road_vertic:
                gamobj_bg_suffix = Tile.GAMOBJ_BACKGROUND_FROM_ROADS[
                    (self.road_horiz, self.road_vertic)
                ]
                gamobj_background = "neutral" + gamobj_bg_suffix
                self.linked_gamobjs[:] = [gamobj_background]
            else:
                self.linked_gamobjs[:] = []
            return

        gamobjs = []
        color = self.player_owner.color
        if self.town:
            # Détermination du game object de la town.
            # Soit c'est une town de size 1, et on sait tout de suite lequel c'est.
            # Soit c'est une town plus étendu, et il faut faire un petit calcul pour savoir
            # où se trouve la tile par rapport au coin supérieur gauche de la town.
            town_size = self.town.size
            if town_size == 1:
                gamobj_town_suffix = "_town_1x1"
            else:
                offset_x = min(self.x - self.town.x_left, town_size - 1)
                offset_y = min(self.y - self.town.y_up, town_size - 1)
                gamobj_town_suffix = (
                    f"_town_{town_size}x{town_size}_{offset_x}{offset_y}"
                )
            gamobjs.append(color + gamobj_town_suffix)
            if not self.town.is_active:
                gamobjs.append("town_desactivate")
        else:
            # Détermination du background (avec route ou pas) dans le cas d'une tile
            # contrôlée par un/une Player.
            # Puis détermination du game object affichant le nombre d'unités présente sur la tile.
            gamobj_bg_suffix = Tile.GAMOBJ_BACKGROUND_FROM_ROADS[
                (self.road_horiz, self.road_vertic)
            ]
            gamobj_background = color + gamobj_bg_suffix
            gamobjs.append(gamobj_background)
            if self.nb_unit:
                # Il ne devrait jamais y avoir plus de 16 unités sur une même tile,
                # mais on sait jamais. Donc on met un min.
                gamobjs.append(
                    color + "_" + GAMOBJ_NAME_TO_NB_UNIT[min(self.nb_unit, 16)]
                )
            if self.town_building_step:
                gamobjs.append(
                    color + "_town_build_" + str(self.town_building_step).zfill(2)
                )
        self.linked_gamobjs[:] = gamobjs

    def __str__(self):
        str_roads = "|" * self.road_vertic + "-" * self.road_horiz
        return (
            f"Tile x: {self.x} y: {self.y} player_owner: {self.player_owner} "
            f"nb_unit: {self.nb_unit} town: {self.town} road: {str_roads} "
            f"road_adjacencies_same_player {self.road_adjacencies_same_player} "
            f"suburb_owner: {self.suburb_owner}"
        )

    def is_road_connected(self, direction, other_tile):
        """
        Vérifie si deux tiles adjacentes sont connectées par une route.
        Attention, les paramètres doivent être cohérents entre eux. Il faut le vérifier avant.
        C'est à dire que other_tile doit être la tile adjacente à celle-ci, dans la direction donnée.
        Pour résumer : self.adjacencies[direction] == other_tile
        """
        if direction in (2, 6):
            return self.road_horiz and other_tile.road_horiz
        if direction in (0, 4):
            return self.road_vertic and other_tile.road_vertic
        return False

    def _update_road_adjacency(self, direction):
        """
        Met à jour un élément de la variable road_adjacencies_same_player, pour la direction
        indiquée en param.
        En même temps, on met à jour l'élément opposé de road_adjacencies_same_player de la
        tile adjacente.
        Rappel : chaque élément de road_adjacencies_same_player peut valoir :
         - 0 : pas de route, ou alors une route, mais les deux tiles adjacentes
               appartiennent à deux Players différent(e)s.
         - 1 : une route qui connecte, et les deux tiles sont contrôlées par Player.
         - 2 : les deux tiles appartiennent au même suburb. Il y a une connexion,
               mais on s'en fiche (lorsqu'on effectue des répartitions de pixels sur les routes).
        """
        other_tile = self.adjacencies[direction]
        if other_tile is None:
            # C'est une tile sur un bord d'écran.
            self.road_adjacencies_same_player[direction] = 0
            return

        # Pas de pre-check. On fixe systématiquement à 0, 1 ou 2 selon l'état en cours.
        # Si ça redéfinit à la même valeur, osef.
        # Comme ça on gère automatiquement le passage de 2 à 0, lorsqu'on construit une ville
        # à l'endroit où il y avait une route de suburb.
        if self.town is not None or other_tile.town is not None:
            # Jamais de connexion de route entre une town et une tile adjacente.
            # Même si il y a une road sur la tile adjacente.
            # L'équilibrage des unités dans ce cas est géré par le suburb.
            connection_type = 0
        elif (
            self.suburb_owner is not None
            and self.suburb_owner == other_tile.suburb_owner
        ):
            # C'est pas une vraie connexion.
            # Il y a des routes, mais on considère qu'elles ne sont pas connectées.
            # Dans ce cas aussi, l'équilibrage des unités est géré par le suburb.
            connection_type = 2
        else:
            roads_ok = self.is_road_connected(direction, other_tile)
            connection_ok = all(
                (
                    roads_ok,
                    self.player_owner is not None,
                    self.player_owner == other_tile.player_owner,
                )
            )
            connection_type = int(connection_ok)

        self.road_adjacencies_same_player[direction] = connection_type
        reversed_direction = REVERSE_DIRS[direction]
        # Mise à jour de la connexion opposée, pour la tile adjacente à cette tile.
        other_tile.road_adjacencies_same_player[reversed_direction] = connection_type

    def update_all_road_adjacencies(self):
        """
        Mise à jour de toutes la liste road_adjacencies_same_player, en fonction
        des roads et des tiles contrôlées.
        Pas de mise à jour sur les adjacences diagonales, car pas de routes diagonales.
        """
        self._update_road_adjacency(0)
        self._update_road_adjacency(2)
        self._update_road_adjacency(4)
        self._update_road_adjacency(6)

    def _update_all_road_adjacencies_with_current_roads(self):
        """
        Comme on ne peut que ajouter des routes et pas en détruire (sauf dans le cas spécial
        où on construit une ville), les seules mises à jour d'adjacences utiles
        sont pour les directions où on a la route correspondante.
        Sinon, les autres adjacences, ça va rester à zéro, pas besoin d'updater.
        """
        if self.road_horiz:
            self._update_road_adjacency(2)
            self._update_road_adjacency(6)
        if self.road_vertic:
            self._update_road_adjacency(0)
            self._update_road_adjacency(4)

    def add_unit(self, player, qty=1):
        """
        Ajoute une ou plusieurs unités sur la tile, appartenant à player, indiqué en param.
        Cette fonction effectue tous les checks nécessaires, et toutes les mises à jour
        des listes d'indexation, de comptage, de contrôle, etc.

        Si on ajoute des unités de Player A, alors qu'il y a déjà des unités de Player B,
        les unités s'annulent. On peut avoir 3 cas possibles :
         - moins d'unité de A que de B : ça fait diminuer un peu les unités de B, c'est tout.
         - autant d'unités de A et de B : toutes les unités s'éliminent. La tile n'est plus
           contrôlée par personne.
         - plus d'unités de A que de B : on enlève d'abord toutes les unités de B.
           On met à jour tout ce qu'il faut par rapport au fait que B perd le contrôle
           d'une tile, puis on ajoute ce qu'il reste des unités de A. Et on fait
           à nouveau des mises à jour par rapport au fait que A gagne le contrôle d'une tile.
        """
        if not qty:
            return
        if self.town is not None:
            raise Exception(
                "Ajout de unit sur une ville. Not supposed to happen." + str(self)
            )

        initial_nb_unit = self.nb_unit
        must_check_road_adjacencies = True
        if self.player_owner == player:
            # Pas de check pour vérifier que ça dépasse pas 16. Faut le faire avant.
            self.nb_unit += qty
            player.total_units += qty
            # On ne fait que ajouter des unités d'une couleur à une tile qui en a déjà.
            # Ça change rien au niveau des routes, des contrôles, etc.
            must_check_road_adjacencies = False
        elif self.player_owner is None:
            self.player_owner = player
            player.add_controlled_tile(self)
            if self.road_vertic or self.road_horiz:
                player.add_controlled_road(self)
                self.game_master.uncontrolled_roads.remove(self)
            self.nb_unit += qty
            player.total_units += qty
        else:
            if qty < self.nb_unit:
                # On élimine un peu d'unité de l'autre Player, et on s'arrête là.
                self.remove_unit(qty)
            else:
                qty_unit_left_after = qty - self.nb_unit
                # On enlève toutes les unités de l'autre Player. La fonction remove_unit
                # gère toutes les mises à jour de listes, index, etc., dans le cas d'une
                # suppression.
                self.remove_unit(self.nb_unit)
                # Ha ha. Récursivité. La fonction add_unit s'appelle elle-même.
                # Mais ce re-appel ne peut arriver qu'une seule fois maximum.
                # car quand on en arrive là, la tile n'est plus contrôlée par personne.
                self.add_unit(player, qty_unit_left_after)

        if (
            not self.road_vertic
            and not self.road_horiz
            and self.town is None
            and self.nb_unit > 1
            and initial_nb_unit <= 1
        ):
            # On est passé de 0 ou 1 unités à plusiers unités, et il n'y a pas de routes.
            # Cette tile doit donc être référencée dans la liste des bare tiles ayant
            # plus de une unité.
            self.player_owner.controlled_bare_tiles_with_many_units.append(self)

        if must_check_road_adjacencies:
            # L'ajout d'unité a provoqué un changement important.
            # Par exemple, la tile a changé d'owner.
            # Il faut donc vérifier tous les contrôles et les adjacences de routes.
            self._update_all_road_adjacencies_with_current_roads()
        self.update_linked_gamobjs()

    def remove_unit(self, qty=1):
        """
        Supprime une ou plusieurs unités sur une tile, que que soit Player qui contrôle la tile.
        Comme pour add_unit, cette fonction effectue tous les checks nécessaires,
        et toutes les mises à jour des listes d'indexation, de comptage, de contrôle, etc.

        Si on essaye d'enlever plus d'unité qu'il n'y en a déjà, on fait tomber le nombre d'unité
        à zéro (on n'émet pas d'erreur ni d'avertissement).
        Lorsque le nombre d'unité tombe à zéro, Player perd le contrôle de cette tile.
        """
        if not qty:
            return
        if self.player_owner is None:
            raise Exception("Not supposed to happen.")

        initial_nb_unit = self.nb_unit
        qty = min(qty, self.nb_unit)
        self.nb_unit -= qty
        self.player_owner.total_units -= qty

        if (
            not self.road_vertic
            and not self.road_horiz
            and self.town is None
            and self.nb_unit <= 1
            and initial_nb_unit > 1
        ):
            # On est passé de plusieurs unités à 0 ou 1 unités.
            # On enlève la tile de la liste des bare tiles ayant plus d'une unités.
            self.player_owner.controlled_bare_tiles_with_many_units.remove(self)

        if self.nb_unit == 0:
            self.player_owner.remove_controlled_tile(self)
            if self.road_vertic or self.road_horiz:
                self.player_owner.remove_controlled_road(self)
                self.game_master.uncontrolled_roads.append(self)
            self.player_owner = None
            # L'ajout d'unité a provoqué un changement important. Il n'y a plus d'owner.
            # Il faut donc vérifier tous les contrôles et les adjacences de routes.
            self._update_all_road_adjacencies_with_current_roads()

        self.update_linked_gamobjs()

    def add_road(self, horiz=False, vertic=False):
        """
        Ajoute une route horizontale ou verticale ou les deux à la fois sur la tile.
        Ça fait tous les checks qu'il faut, et ça met à jour toutes les listes et les références.
        En particulier, les opérations à faire sur les suburbs.
        La construction d'une route à côté d'une ville fait transférer la tile de
        "potential_tiles" vers "real_suburb_tiles".
        Et en plus, ça peut faire fusionner plusieurs suburbs, car la route les
        connecte entre eux.
        """
        if not (horiz or vertic):
            return
        adj_towns = [
            adj_tile.town
            for adj_tile in self.adjacencies[::2]
            if adj_tile is not None and adj_tile.town is not None
        ]
        if adj_towns:
            # Si c'est à côté d'une ville, on ajoute obligatoirement les deux routes.
            horiz = True
            vertic = True

        if horiz == self.road_horiz and vertic == self.road_vertic:
            return
        if self.town is not None:
            raise Exception("Ajout de road sur une town. Not supposed to happen.")

        previous_road_qty = self.road_horiz + self.road_vertic
        self.road_horiz = self.road_horiz or horiz
        self.road_vertic = self.road_vertic or vertic
        current_road_qty = self.road_horiz + self.road_vertic
        self._update_all_road_adjacencies_with_current_roads()
        # Si on a ajouté des routes alors qu'il n'y en avait pas du tout au départ,
        # il y a diverses listes à mettre à jour, pour le game_master et pour Player.
        if previous_road_qty == 0 and current_road_qty > 0:
            if self.player_owner is None:
                self.game_master.uncontrolled_roads.append(self)
            else:
                self.player_owner.add_controlled_road(self)
                if self.nb_unit > 1:
                    self.player_owner.controlled_bare_tiles_with_many_units.remove(self)

        # Gestion des suburbs, que cet ajout de route peut modifier.
        # Si on a une ou plusieurs villes à côté de la tile, alors il se passe des trucs au
        # niveau des suburbs. Sinon, ce n'est pas une tile potentielle de suburb.
        if adj_towns:
            # Récupération de tous les suburbs adjacents. Plusieurs tiles adjacentes peuvent
            # appartenir au même suburb. On gère ce cas avec le "set".
            adj_suburbs = set((town.get_suburb_owner() for town in adj_towns))
            for suburb in adj_suburbs:
                # Dans le ou les suburbs concernés, la construction de route transfère la tile
                # des potential_tiles vers real_suburb_tiles.
                suburb.transfer_potential_road(self)
            if len(adj_suburbs) > 1:
                # Ce transfert de tile peut faire merger un ou plusieurs suburbs.
                # La fonction check_suburb_merging_by_list vérifie tous les merges posibles,
                # et effectue ceux qui doivent être fait.
                self.game_master.check_suburb_merging_by_list(list(adj_suburbs))
            # Maintenant qu'on a fait des merges, on met à jour les connexions entre route.
            # On en annulera certaines (on met des "2" dans road_adjacencies_same_player),
            # car ce sont devenues des routes d'un même suburb.
            self.update_all_road_adjacencies()
        self.update_linked_gamobjs()

    def _remove_all_roads(self):
        """
        Supprime toutes les routes de la tile.
        Il n'y a pas de fonction pour supprimer une seule des deux routes, car pas besoin.
        Le seul moment où on supprime des routes, c'est pour mettre une ville à la place.
        Du coup, la suppression de roads ne provoque jamais de diminution ou de split de suburb,
        donc on gère pas ça non plus, et ça va très bien.
        """
        if not self.road_vertic and not self.road_horiz:
            return
        self.road_vertic = False
        self.road_horiz = False
        # Quelques listes à mettre à jour, et les adjacencies. Mais rien concernant les suburbs.
        if self.player_owner is None:
            self.game_master.uncontrolled_roads.remove(self)
        else:
            self.player_owner.remove_controlled_road(self)
        self.update_all_road_adjacencies()
        self.update_linked_gamobjs()

    def advance_town_building(self):
        """
        Fait avancer de 1 point la construction en cours de la town sur cette tile.
        """
        if self.town_building_step >= NB_TURNS_TOWN_BUILDING:
            return
        self.town_building_step += 1
        self.update_linked_gamobjs()

    def cancel_town_building(self):
        """
        Annule la construction en cours de la town sur cette tile.
        Soit à cause d'un timeout, soit parce que Player a donné d'autres ordres, qui annulent
        les diverses actions en cours.
        Une annulation de construction n'a aucune conséquence pour Player. Pas de perte d'unités,
        ni de tile contrôlée. Player a juste perdu quelques tours à commencer de construire
        une town pour finalement ne pas la terminer.
        """
        self.town_building_step = 0
        self.update_linked_gamobjs()

    def build_town(self):
        """
        Crée immédiatement une town de size 1 sur cette tile.
        Les 16 unités présentes sur la tile, qui ont été nécessaires durant tout le temps de
        construction de la town, sont automatiquement supprimées.
        La fonction fait tous les checks qu'il faut, la suppression des unités existantes,
        l'ajout dans les listes, etc.
        Pas besoin de spécifier Player. On prend player_owner actuel de la tile.
        Si pas de player_owner, on balance une exception.

        La fonction ne fait rien concernant les merge/shatter de town. C'est le game_master
        qui s'occupe de ça, quand c'est le moment. Mais l'ajout de la town modifie l'état
        de vérification des merge/shatter, pour prévenir le game_master qu'il doit relancer
        tout un cycle de vérification.
        """
        if self.player_owner is None:
            raise Exception("Town without owner. Not supposed to happen.")

        if self in self.player_owner.controlled_bare_tiles_with_many_units:
            self.player_owner.controlled_bare_tiles_with_many_units.remove(self)
        self._remove_all_roads()

        # On transforme toutes les routes sur les tiles adjacentes en routes horiz+vertic.
        # Il n'y a pas de route droite autour des towns. C'est une règle que j'ai décidée,
        # car ça simplifie le jeu, et ça évite d'embêter Player, qui n'a pas besoin
        # de les construire manuellement.
        for tile_adj in self.adjacencies[::2]:
            if tile_adj is not None:
                if int(tile_adj.road_horiz) + int(tile_adj.road_vertic) == 1:
                    tile_adj.add_road(True, True)

        # Pour enlever les units, on aurait dû passer par la fonction remove_unit.
        # Mais on va pas le faire, parce que ça mettrait player_owner à None.
        self.player_owner.total_units -= self.nb_unit
        self.nb_unit = 0
        # Création effective de la town.
        self.town = Town(self.x, self.y, 1, self.player_owner, self.game_master)
        self.player_owner.add_towns([self.town])
        # On ajoute une town. Donc toutes les towns adjacentes ne peuvent plus générer
        # leurs unités sur cette tile. Elles doivent donc remettre à jour leurs listes
        # de génération, voire remettre à jour leur booléen is_active.
        for tile_adj in self.adjacencies[::2]:
            if tile_adj is not None and tile_adj.town is not None:
                tile_adj.town.update_unit_gen_tiles()
        # L'ajout d'une town a automatiquement créé son petit suburb autour d'elle.
        # Il faut immédiatement vérifier si ce suburb ne peut pas être mergé avec
        # un ou plusieurs autres. De cette manière, ça déclenchera les éventuels merges
        # de suburb existants qui doivent être mergés.
        self.game_master.check_suburb_merging_with_all_others(
            self.town.get_suburb_owner()
        )
        self.update_linked_gamobjs()


class Missile:
    """
    Pattern de placement des unités vertes, pour chaque tour.
         |  .  |     |     |
      .  |     |  .. | .   |
    . X. | .X .|  X. | .X  |
         |  .  | .   |  .. |
      .  |     |     |     |
    """

    DELAY_MOVE = 2
    UNIT_COST = 10
    # Nombre de tours avant que la construction du missile soit annulée
    # Si il y a suffisamment d'unité dans le suburb de la ville où le missile
    # est en train d'être construit, on ne devrait pas atteindre le timeout.
    TIMEOUT = UNIT_COST * 3

    BUILDING = 0
    MOVING = 1
    DEFINING_DEST_TILES = 2
    EXPLODING = 3
    FINISHED = 4

    # J'aime bien Black, mais quand il formate des trucs comme ça, je le trouve relou.
    DIRECTIONS_DEST_TILES = (
        (),
        (0,),
        (2,),
        (6, 6),
        (4, 4),
        (),
        (6,),
        (4,),
        (2, 2),
        (0, 0),
        (),
        (0,),
        (2,),
        (0, 2),
        (6, 4),
        (),
        (6,),
        (4,),
        (0, 6),
        (2, 4),
    )

    # clé : taille de la town qui va générer le ou les missiles.
    # valeur : tuple de 2 elems.
    #  - distance max du missile
    #  - sous-tuple. nombre de delay des missiles.
    #    (Le nombre d'elem de la liste donne le nombre de missile à générer)
    GEN_INFOS_FROM_TOWN_SIZE = {
        1: (WARZONE_HEIGHT // 2, (2,)),
        2: (WARZONE_HEIGHT // 1.5, (2, 6)),
        4: (WARZONE_HEIGHT, (2, 10, 14, 6)),
    }

    def __init__(
        self,
        player_owner,
        tile,
        duration,
        game_master,
        initial_delay_move=2,
        direction=None,
        player_to_spawn=None,
    ):
        self.player_owner = player_owner
        self.tile = tile
        self.duration = duration
        self.index_dest_tile = 0
        self.payload_qty = 20
        self.dumps_per_turn = 5
        self.game_master = game_master
        self.initial_delay_move = initial_delay_move
        self.direction = (
            self.player_owner.dir_forw_diag if direction is None else direction
        )
        self.player_to_spawn = (
            self.game_master.player_bionature
            if player_to_spawn is None
            else player_to_spawn
        )
        self.suburb_owner = self.tile.suburb_owner
        if self.suburb_owner is None:
            raise Exception(
                "Construction d'un missile sur une zone sans suburb. Not supposed to happen."
            )
        self.slide_dir_1 = (self.direction + 1) % 8
        self.slide_dir_2 = (self.direction - 1) % 8
        self.build_step = 0
        self.time_before_timeout = Missile.TIMEOUT
        self.current_action = Missile.BUILDING
        self.gamobj = f"missile_build_{self.build_step:02}"

    def handle(self):
        function_from_action = {
            Missile.BUILDING: self.build,
            Missile.MOVING: self.move,
            Missile.DEFINING_DEST_TILES: self.define_dest_tiles,
            Missile.EXPLODING: self.dump_payload,
            Missile.FINISHED: self.finished,
        }
        function_from_action[self.current_action]()

    def build(self):
        self.time_before_timeout -= 1
        # On enlève une unité du player dans le suburb, pour avancer la construction du missile.
        for suburb_tile in self.suburb_owner.real_suburb_tiles:
            if (
                suburb_tile.player_owner == self.player_owner
                and suburb_tile.nb_unit > 1
            ):
                suburb_tile.remove_unit(1)
                self.build_step += 1

        if self.build_step < Missile.UNIT_COST:
            self.gamobj = f"missile_build_{self.build_step:02}"
        else:
            self.delay_move = self.initial_delay_move
            self.gamobj = "missile_ur" if self.direction == 1 else "missile_dl"
            self.current_action = Missile.MOVING

        if not self.time_before_timeout:
            # Construction du missile fail.
            # Il faut rendre les unités investies et annuler le missile.
            for suburb_tile in self.suburb_owner.real_suburb_tiles:
                if (
                    suburb_tile.player_owner != self.player_owner
                    or suburb_tile.nb_unit + self.build_step <= 16
                ):
                    suburb_tile.add_unit(self.player_owner, self.build_step)
                    break
            # Si on a parcourut toutes les tiles sans trouver d'endroit où rendre les unités,
            # elles sont perdues tant pis. Mais c'est pas censé arriver, car si il y a des unités,
            # alors on aurait pu avancer la construction du missile.
            self.current_action = Missile.FINISHED

    def move(self):
        self.delay_move -= 1
        if self.delay_move:
            return

        if self.tile.player_owner is not None and self.tile.player_owner not in (
            self.player_owner,
            self.player_to_spawn,
        ):
            # Le missile survole une case appartenant au Player ennemi.
            # On explose tout de suite, parce que ça va l'embêter. Ha ha !
            self.duration = 0

        if self.duration == 0:
            self.current_action = Missile.DEFINING_DEST_TILES
            self.gamobj = "missile_exploding"
            return

        self.delay_move = Missile.DELAY_MOVE
        self.duration -= 1
        next_tile = self.tile.adjacencies[self.direction]
        if next_tile is None:
            next_tile = self.tile.adjacencies[self.slide_dir_1]
        if next_tile is None:
            next_tile = self.tile.adjacencies[self.slide_dir_2]
        if next_tile is None:
            return

        self.tile = next_tile

    def define_dest_tiles(self):
        self.dest_tiles = []
        for direction_sequence in Missile.DIRECTIONS_DEST_TILES:
            cur_tile = self.tile
            for direction in direction_sequence:
                cur_tile = cur_tile.adjacencies[direction]
                if cur_tile is None:
                    break
            if cur_tile is not None and cur_tile.town is None:
                self.dest_tiles.append(cur_tile)

        if not self.dest_tiles:
            # Aucune tile de libre sur laquelle on peut poser des unités vertes.
            # on enlève la payload. Au prochain tour, la fonction dump_payload
            # mettra automatiquement l'état en FINISHED.
            # Je ne met pas directement l'état en FINISHED, comme ça, le dessin du missile
            # qui explose reste un peu plus longtemps. Pour bien montrer que le missile était
            # quand même là, même si il n'a eu aucun effet.
            self.payload_qty = 0
        self.current_action = Missile.EXPLODING

    def dump_payload(self):
        if not self.payload_qty:
            self.current_action = Missile.FINISHED
            return

        self.dumps_made = 0
        nb_times_resetted_index = 0
        while (
            self.dumps_made < self.dumps_per_turn
            and self.payload_qty
            and nb_times_resetted_index <= 2
        ):

            dest_tile = self.dest_tiles[self.index_dest_tile]
            if dest_tile.town is None and (
                dest_tile.player_owner != self.player_to_spawn or dest_tile.nb_unit < 16
            ):
                dest_tile.add_unit(self.player_to_spawn)
                self.payload_qty -= 1
                self.dumps_made += 1

            self.index_dest_tile += 1
            if self.index_dest_tile >= len(self.dest_tiles):
                self.index_dest_tile = 0
                nb_times_resetted_index += 1
                if nb_times_resetted_index == 2 and self.dumps_made == 0:
                    # Ça fait deux fois qu'on repasse par l'index numéro 0.
                    # Ça veut dire qu'on a fait le tour du compteur (et même un peu plus)
                    # sans avoir réussi à placer une seule unité verte.
                    # C'est pas la peine d'essayer d'en replacer d'autres. Il n'y a plus
                    # de tile disponible (elles sont peut-être déjà toute remplie de vert)
                    # On termine le missile, même si il avait encore de la payload. Tant pis !
                    self.payload_qty = 0

    def finished(self):
        pass


class GameMaster:
    """
    Le maître du jeu. La classe qui dirige tout le bazar, qui contient les Players, l'aire de jeu,
    qui ordonnance les actions, etc.

    C'est aussi le GameMaster qui gère les suburb (merge, équilibrage des unités), car les suburbs
    sont neutres.
    """

    def __init__(self, w, h):
        self.w = w
        self.h = h
        # Tableau à 2 dimensions contenant des objets Tile
        self.game_area = []
        # Tableau à 2 dimensions contenant des game_objects (c'est à dire des listes de strings)
        # Lorsqu'on veut rafraîchir ce qui est affiché à l'écran, on prend une ou plusieurs tiles
        # de game_area, on update leurs game_objects, et on les mets dans
        # les cases correspondantes de gamobjs_to_export.
        # De cette manière, on n'a pas besoin de recalculer les apparences de toutes les tiles
        # lorsqu'il faut redessiner l'aire de jeu à l'écran.
        self.gamobjs_to_export = []
        # Initialisation de ces deux tableaux.
        for y in range(self.h):
            line = []
            line_gamobjs = []
            for x in range(self.w):
                cell_gamobjs = []
                line_gamobjs.append(cell_gamobjs)
                tile = Tile(x, y, cell_gamobjs, self)
                line.append(tile)
            self.gamobjs_to_export.append(tuple(line_gamobjs))
            self.game_area.append(tuple(line))
        # On convertit tout en tuple. Parce qu'on ne change pas la disposition des éléments
        # dans les tableaux. On ne change que le contenu de chacun des éléments.
        self.game_area = tuple(self.game_area)
        self.gamobjs_to_export = tuple(self.gamobjs_to_export)

        # Définition des adjacences. Chaque objet Tile a une variable membre "adjacencies",
        # contenant des références vers les tiles adjacentes, selon les directions.
        for y in range(self.h):
            for x in range(self.w):
                adjacencies = self._make_adjacencies(x, y)
                self.game_area[y][x].adjacencies = adjacencies

        # Tous les objets Suburb de l'aire de jeu.
        self.suburbs = []
        # J'ai besoin de ça pour savoir si il faut checker des conquêtes de roads.
        # C'est assez rare qu'il y ait des routes inocuppées, mais quand c'est le cas,
        # faut boucler dessus pour voir si on peut y propager des unités.
        self.uncontrolled_roads = []
        self.players = None
        self.player_bionature = None

        self.missiles = []

    def set_all_players(self, real_players, player_bionature):
        """
        real_players est une liste contenant tous les "vrais" PlayerHandler, dirigés par des humains.
        player_bionature est un seul PlayerHandler, dirigé par le jeu.
        """
        # Initialisation des PlayerHandler.
        for player in real_players:
            player.init_first_units_and_town()
        self.init_bionature_units(player_bionature)
        # La variable membre players contient tous les players, y compris la bionature.
        self.players = real_players + [player_bionature]
        self.player_bionature = player_bionature

    def _make_adjacencies(self, x, y):
        """
        Renvoie les tiles adjacentes à la tile aux coordonnées x, y.
        On renvoie toujours une liste de 8 éléments (les 8 directions), mais certains éléments
        peuvent être None, si les coordonnées x, y sont sur un bord de l'aire de jeu.
        """
        adjacencies = (
            self.game_area[y - 1][x] if 0 <= y - 1 else None,
            self.game_area[y - 1][x + 1] if 0 <= y - 1 and x + 1 < self.w else None,
            self.game_area[y][x + 1] if x + 1 < self.w else None,
            self.game_area[y + 1][x + 1] if y + 1 < self.h and x + 1 < self.w else None,
            self.game_area[y + 1][x] if y + 1 < self.h else None,
            self.game_area[y + 1][x - 1] if y + 1 < self.h and 0 <= x - 1 else None,
            self.game_area[y][x - 1] if 0 <= x - 1 else None,
            self.game_area[y - 1][x - 1] if 0 <= y - 1 and 0 <= x - 1 else None,
        )
        return adjacencies

    def conquest_neutral_roads(self):
        """
        Lorsqu'une tile de road n'a pas de owner, et qu'elle est connectée à une road adjacente,
        et que cette road est contrôlée par quelqu'un,
        alors on déplace automatiquement une unité dessus pour la conquérir.
        Si les tiles adjacentes sont contrôlées par plusieurs Players, on ne fait rien.
        """
        if not self.uncontrolled_roads:
            return

        # On fait une copie de la liste,
        # car elle risque de changer pendant qu'on boucle dessus.
        uncontrolled_roads_copy = list(self.uncontrolled_roads)
        for tile in uncontrolled_roads_copy:
            # Liste des tiles adjacentes qui pourraient conquérir cette tile non contrôlée.
            conqueror_tiles = []
            # Liste des Players qui pourraient conquérer cette tile.
            conqueror_players = set()
            if tile.road_vertic:
                for adj_tile in (tile.adjacencies[0], tile.adjacencies[4]):
                    if (
                        adj_tile is not None
                        and adj_tile.player_owner is not None
                        # Si Player a fait une magnetisation, il/elle ne conquiert
                        # pas les routes neutres. (En fait si, mais pas via cette fonction).
                        # Player va automatiquement conquérir les routes
                        # qui lui permettent d'accéder à la tile magnetisée.
                        and adj_tile.player_owner.tile_magnet is None
                        and adj_tile.nb_unit > 1
                        and adj_tile.road_vertic
                    ):
                        conqueror_tiles.append(adj_tile)
                        conqueror_players.add(adj_tile.player_owner)
            if tile.road_horiz:
                for adj_tile in (tile.adjacencies[2], tile.adjacencies[6]):
                    if (
                        adj_tile is not None
                        and adj_tile.player_owner is not None
                        and adj_tile.player_owner.tile_magnet is None
                        and adj_tile.nb_unit > 1
                        and adj_tile.road_horiz
                    ):
                        conqueror_tiles.append(adj_tile)
                        conqueror_players.add(adj_tile.player_owner)

            # Si plusieurs Player peuvent conquérir la tile, on ne fait rien.
            if len(conqueror_players) == 1:
                # Player peut conquérir la tile. On prend la première tile adjacente
                # qui peut faire la conquête, et on déplace une unité, de la tile adjacente,
                # vers cette tile. Rien de plus à faire. L'équilibrage des unités entre
                # cette tile nouvellement conquise et les tiles adjacentes se fera tout
                # seul, au prochain tour, grâce à la fonction Player._spread_units_on_one_road.
                conqueror_tile = conqueror_tiles[0]
                conqueror_player = list(conqueror_players)[0]
                conqueror_tile.remove_unit()
                tile.add_unit(conqueror_player)

    def check_two_suburbs_merge(self, suburb_1, suburb_2):
        """
        Renvoie True ou False, selon que les deux suburbs passés en paramètre doivent être
        mergés, ou pas.
        On merge si la town d'un suburb se trouve sur n'importe quelle tile de l'autre suburb
        (potential tile, real tile, town tile).
        On merge aussi si la real tile d'un suburb se trouve dans les real tile de l'autre suburb.
        (Ce serait le cas où on a construit une route entre deux villes, qui merge les
        suburb de ces deux villes).
        """
        suburb_1_all_tiles = (
            suburb_1.town_tiles + suburb_1.real_suburb_tiles + suburb_1.potential_tiles
        )
        if not set(suburb_1_all_tiles).isdisjoint(set(suburb_2.town_tiles)):
            return True
        suburb_2_all_tiles = (
            suburb_2.town_tiles + suburb_2.real_suburb_tiles + suburb_2.potential_tiles
        )
        if not set(suburb_2_all_tiles).isdisjoint(set(suburb_1.town_tiles)):
            return True
        if not set(suburb_2.real_suburb_tiles).isdisjoint(
            set(suburb_1.real_suburb_tiles)
        ):
            return True
        return False

    def check_suburb_merging_by_list(self, many_suburbs):
        """
        Vérifie si tous les suburbs de la liste many_suburbs doivent être mergés en un seul
        gros suburb, ou pas. Si oui, effectue ces merges.

        Attention, cette fonction ne peut gérer que deux cas :
         - soit faut tout merger en un seul, et on le fait.
         - soit il ne faut merger aucun suburb entre eux, et on ne fait rien.

        Par exemple, si on passe une liste de suburbs [A, B, C, D], et qu'il faudrait merger
        A+B et C+D, mais pas A+B+C+D : la fonction ne va pas savoir gérer ça, et les
        actions effectuées seront plus ou moins n'importe quoi.

        Il faut donc faire attention à la liste qu'on donne en paramètre.
        """
        # On trie les suburbs, du plus grand au plus petit.
        # Plus un suburb possède de "real_suburb_tiles", plus il est grand.
        # Comme ça, on merge le plus grand suburb avec les autres,
        # C'est plus rapide que de merger un petit suburb avec d'autres.
        many_suburbs.sort(
            key=lambda suburb: len(suburb.real_suburb_tiles), reverse=True
        )
        first_suburb = many_suburbs.pop(0)
        while many_suburbs:
            other_suburb = many_suburbs.pop(0)
            # À priori, il n'y aurait besoin de faire la vérification que entre les deux
            # premiers suburbs. Mais je préfère la faire à chaque fois.
            if self.check_two_suburbs_merge(first_suburb, other_suburb):
                first_suburb.merge(other_suburb)

    def check_suburb_merging_with_all_others(self, one_suburb):
        """
        Vérifie si il faut merger le suburb passé en paramètre, avec tous
        les autres suburb existants.
        L'ordre de vérif n'est pas important, car les merge sont transitifs.
        Si A doit être mergé avec B et D, mais pas avec C,
        on peut faire (A verif B), puis (A verif D), ou l'inverse. Ça reviendra au même.
        Dans cet exemple, B pourrait être mergé directement avec D, ou pas. Ça dépend de la
        disposition des suburbs. Mais on ne s'occupe pas de ces cas, car le but est uniquement
        de merger A avec le reste.
        """
        suburbs_to_merge = []
        # D'abord on vérifie tout ce qui doit être mergé.
        for other_suburb in self.suburbs:
            if one_suburb == other_suburb:
                continue
            if bounding_rect_overlaps(
                one_suburb.bounding_rect, other_suburb.bounding_rect
            ):
                if self.check_two_suburbs_merge(one_suburb, other_suburb):
                    suburbs_to_merge.append(other_suburb)

        # Et ensuite on merge tout ce qui doit être mergé.
        # En commençant par les plus grands, pour optimiser.
        suburbs_to_merge.sort(
            key=lambda suburb: len(suburb.real_suburb_tiles), reverse=True
        )
        for other_suburb in suburbs_to_merge:
            one_suburb.merge(other_suburb)

    def _equilibrate_units_in_one_suburb(self, suburb, turn_index):
        """
        Répartit toutes les unités qui sont présentes dans un même suburb,
        ou bien élimine des unités différentes si plusieurs PlayerHandlers sont sur ce suburb.

        Quand on répartit les unités, on ne le fait que "ponctuellement". On prend la tile
        qui a le plus d'unités et celle qui en a le moins, on calcule la différence,
        et on transfère la moitié de la différence de la plus peuplée à la moins peuplée.

        Ça ne fait pas une répartition parfaite. Mais au prochain tour de jeu, on refera
        la même petite action ponctuelle. Et progressivement, ça finit par se répartir
        équitablement. On applique toujours le même principe : ça fait moins de traitement
        à exécuter à chaque tour, et ça montre à l'écran la répartition progressive.

        Même chose lorsqu'il y a des unités de différentes couleurs. On en élimine que deux,
        (une de chaque couleur). On élimine pas tout d'un coup. Ça finit par se nettoyer
        tout seul au fur et à mesure des tours de jeux.
        """
        # most_unequilibrateds est un dictionnaire enregistrant les tiles les plus déséquilibrées
        # (en nombre d'unités)
        # Clé : Player ayant des unités dans ce suburb.
        # Valeur : tuple de 2 éléments : tile avec le max d'unité, tile avec le min d'unité.
        # ça peut être deux fois la même si Player ne contrôle qu'une seule tile dans ce suburb.
        most_unequilibrateds = {}
        # Une tile du suburb contrôlée par personne. On prend la première qu'on trouve.
        # Ça peut rester None si toutes les tiles sont contrôlées.
        un_owned_tile = None
        func_get_unit = lambda tile: tile.nb_unit
        # Définition de most_unequilibrateds et un_owned_tile
        for tile in suburb.real_suburb_tiles:
            player_tile = tile.player_owner
            if player_tile is None:
                if un_owned_tile is None:
                    un_owned_tile = tile
            else:
                if player_tile not in most_unequilibrateds:
                    most_unequilibrateds[player_tile] = [tile, tile]
                else:
                    tile_unit_min, tile_unit_max = most_unequilibrateds[player_tile]
                    # Il y a peut-être plusieurs tile ayant le même max d'unités, et plusieurs
                    # tile ayant le même min. C'est pas important. On prend n'importe quel max
                    # et n'importe quel min.
                    most_unequilibrateds[player_tile] = [
                        min(tile_unit_min, tile, key=func_get_unit),
                        max(tile_unit_max, tile, key=func_get_unit),
                    ]
        if not most_unequilibrateds:
            # Il n'y a personne dans ce suburb ! (c'est rare). On ne fait rien.
            return

        if len(most_unequilibrateds) == 1:
            # Il n'y a qu'une seule personne dans ce suburb. On fait de la répartition d'unités,
            # si c'est nécessaire et possible.
            player_tile, tile_extrems = next(iter(most_unequilibrateds.items()))
            tile_unit_min, tile_unit_max = tile_extrems
            if tile_unit_max.nb_unit > 2:
                if un_owned_tile:
                    # Il y a une tile non contrôlée dans le suburb. C'est plus prioritaire
                    # de contrôler toutes les tiles que de se répartir dans les tiles
                    # qu'on contrôle. Donc on prend une unité de la tile où on en a le plus,
                    # et on la met sur la tile non contrôlée.
                    # Il y a peut-être d'autres tiles non contrôlée, mais on ne s'en occupe pas.
                    # Ça se fera tout seul au prochain tour.
                    tile_unit_max.remove_unit()
                    un_owned_tile.add_unit(player_tile)
                else:
                    # Toutes les tiles du suburb sont contrôlées par Player.
                    # On peut faire une répartition.
                    if (
                        player_tile.tile_magnet is not None
                        and player_tile.tile_magnet.suburb_owner == suburb
                    ):
                        # Si la tile magnétisée de Player est dans ce suburb, on ne répartit pas
                        # les unités. Player veut rassembler toutes ses unités au même endroit,
                        # si on fait une répartition, ça va gêner le rassemblement.
                        pass
                    else:
                        diff = tile_unit_max.nb_unit - tile_unit_min.nb_unit
                        if diff > 1:
                            player_tile.move_unit_without_check(
                                tile_unit_max, tile_unit_min, diff // 2
                            )
        elif len(most_unequilibrateds) == 2:
            # Il y a plusieurs personnes dans ce suburb. On élimine une unité à chacune,
            # en les prenant à partir de leurs tiles ayant le maximum d'unité.
            tile_extrems = list(most_unequilibrateds.values())
            tile_extrems_1 = tile_extrems[0]
            tile_extrems_2 = tile_extrems[1]
            tile_unit_max_1 = tile_extrems_1[1]
            tile_unit_max_2 = tile_extrems_2[1]
            tile_unit_max_1.remove_unit()
            tile_unit_max_2.remove_unit()
        else:
            # Si on a plus que 2 players, il faut déterminer équitablement quelles unités on élimine.
            # On prend 2 players dans la liste, et on élimine une unité chacun.
            # Il faut choisir ces players de façons à ce que ce soit équitable : pas tout le temps les 2 mêmes.
            # (Au tour suivant, faudra prendre le player qui n'a pas été choisi)
            # Pour faire ça, on fait un espèce de round-robin basé sur le numéro de tour de jeu.
            sorted_extrems = [
                (player.player_id, one_tile_extrems)
                for player, one_tile_extrems in most_unequilibrateds.items()
            ]
            sorted_extrems.sort()
            tile_extrems = [
                one_tile_extrems for p_id, one_tile_extrems in sorted_extrems
            ]
            # Round-robin de la mort.
            turn_index_mod = turn_index % len(tile_extrems)
            select_index_1 = turn_index_mod
            select_index_2 = turn_index_mod % (len(tile_extrems) - 1)
            if select_index_2 >= select_index_1:
                select_index_2 += 1
            # C'est bon, on a round-robiné. Il n'y a plus qu'à prendre les tiles concernées
            # et on leur enlève une unité chacun.
            tile_extrems_1 = tile_extrems[select_index_1]
            tile_extrems_2 = tile_extrems[select_index_2]
            tile_unit_max_1 = tile_extrems_1[1]
            tile_unit_max_2 = tile_extrems_2[1]
            tile_unit_max_1.remove_unit()
            tile_unit_max_2.remove_unit()

    def equilibrate_units_in_suburbs(self, turn_index):
        """
        Équilibrage/élimination d'unités dans tous les suburbs de l'aire de jeu.
        """
        for suburb in self.suburbs:
            self._equilibrate_units_in_one_suburb(suburb, turn_index)

    def init_bionature_units(self, player_bionature):
        """
        Place les unités d'une bionature dans l'aire de jeu, au début d'une partie.

        On en place systématiquement 2 le long de la diagonale qui va de haut-gauche à bas-droit,
        et aussi à quelques cases de distance de cette diagonale, pour en faire une "plus épaisse".
        On en place systématiquement 1 à quelques cases de distance plus grande de cette diagonale.
        Pour que ça transitionne doucment de 0 vers 1 puis 1 vers 2 au fur et à mesure qu'on est
        proche de la diagonale.

        En plus de ça, on place quelques "épicentres" le long de cette diagonale, à quelques cases
        de distance (avec un peu de random).
        Les tiles ayant des épicentres proche d'elle peuvent avoir plus d'unités, aussi bien en max
        que en min. La quantité d'unité est à chaque fois déterminée au hasard, entre le min et
        le max calculé en tenant compte de la diagonale et des épicentres proches.
        """
        nb_epicentre = 15
        min_size = min(self.w, self.h)
        rand_epi = min_size // 5
        epicentres = []
        # Placement des épicentres.
        for _ in range(nb_epicentre):
            # D'abord on le place au hasard sur la diagonale.
            x_epi = random.randint(0, min_size)
            y_epi = x_epi
            # Et ensuite on le déplace un peu à côté, avec du hasard.
            x_epi += random.randint(-rand_epi, rand_epi)
            y_epi += random.randint(-rand_epi, rand_epi)
            epicentres.append((x_epi, y_epi))

        for x in range(self.w):
            for y in range(self.h):

                # Détermination du min et du max initial, en fonction de la distance
                # par rapport à la diagonale.
                dist_main_diag = abs(x - y)
                min_unit = max(0, (3 - dist_main_diag / 2))
                max_unit = 10 - dist_main_diag * 3
                # Ajout de quantité en min et en max, en fonction des épicentres proches.
                epi_adds = [
                    20 - (x - x_epi) ** 2 - (y - y_epi) ** 2
                    for x_epi, y_epi in epicentres
                ]
                epi_adds = [val for val in epi_adds if val > 0]
                max_unit += sum(epi_adds)
                min_unit += len(epi_adds)
                # Augmentation du max en dernier recours, si la tile est proche de la diagonale
                # mais qu'on n'a pas eu de bol et qu'on n'a pas assez de min et max.
                if max_unit <= 0:
                    if dist_main_diag < 10:
                        max_unit = 2
                    elif dist_main_diag < 20:
                        max_unit = 1
                # Des fois, avec tous ces savants calcul, max_unit est plus petit que min_unit.
                # Dans ce cas, on redéfinit max_unit.
                max_unit = max(min_unit, max_unit)

                # Et finalement, on choisit le nombre d'unité au hasard entre le min et le max,
                # et on pose ça sur la tile.
                if max_unit > 0:
                    min_unit = int(min_unit)
                    max_unit = int(max_unit)
                    nb_bionature_unit = random.randint(min_unit, max_unit)
                    if nb_bionature_unit > 16:
                        nb_bionature_unit = 16
                    tile = self.game_area[y][x]
                    if tile.town is None:
                        tile.add_unit(player_bionature, nb_bionature_unit)


class IhmMode:

    MAIN_MENU = 0
    SELECT_TOWN = 1
    SELECT_CONQUEST_TILE = 2
    SELECT_CONQUEST_DEST = 3
    BACKWARD_CONQUEST = 4
    SUBMENU_CANCEL = 5
    CANCEL_CURRENT_ORDERS = 6
    SLEEP_MODE = 7
    LAUNCH_MISSILE = 8


class PlayerInterface:

    # TODO : explain ! (These 2 variables !)

    BUTTON_DEFINITIONS = (
        ("ihm_btn_select", 0, 0, "D"),
        ("ihm_btn_conq", 0, 1, "DR"),
        ("ihm_btn_backw", 0, 2, "D"),
        ("ihm_btn_missile", 0, 3, "D"),
        ("ihm_btn_conqdir", 1, 1, "R"),
        ("ihm_btn_conqdist", 2, 1, ""),
        ("ihm_btn_noorder", 0, 4, "R"),
        ("ihm_btn_noorder", 1, 4, "D"),
        ("ihm_btn_sleep", 1, 5, ""),
    )

    INDEX_LIT_BUTTONS = {
        (IhmMode.MAIN_MENU, IhmMode.SELECT_TOWN): 0,
        (IhmMode.SELECT_TOWN, IhmMode.SELECT_TOWN): 0,
        (IhmMode.MAIN_MENU, IhmMode.SELECT_CONQUEST_TILE): 1,
        (IhmMode.MAIN_MENU, IhmMode.BACKWARD_CONQUEST): 2,
        (IhmMode.MAIN_MENU, IhmMode.LAUNCH_MISSILE): 3,
        (IhmMode.MAIN_MENU, IhmMode.SUBMENU_CANCEL): 6,
        (IhmMode.SUBMENU_CANCEL, IhmMode.CANCEL_CURRENT_ORDERS): 7,
        (IhmMode.SUBMENU_CANCEL, IhmMode.SLEEP_MODE): 8,
        # TODO : Ici faudrait du None en next. Là, ça fait bizarre.
        (IhmMode.SELECT_CONQUEST_TILE, IhmMode.SELECT_CONQUEST_TILE): 4,
        (IhmMode.SELECT_CONQUEST_DEST, IhmMode.SELECT_CONQUEST_TILE): 5,
    }

    # dict. clé : taille de la town.
    # valeur : liste de tuple de 2 elems :
    #  - nom du gamobj à placer pour montrer que la town est sélectionnée
    #  - index de la tile de town où placer ce gamobj.
    # faut préfixer avec blu ou red, comme d'hab'.
    TOWN_SELECTORS = {
        1: (("select_town_1x1", 0),),
        2: (
            ("select_town_corner_ul", 0),
            ("select_town_corner_ur", 1),
            ("select_town_corner_dl", 2),
            ("select_town_corner_dr", 3),
        ),
        4: (
            ("select_town_corner_ul", 0),
            ("select_town_line_u", 1),
            ("select_town_line_u", 2),
            ("select_town_corner_ur", 3),
            ("select_town_line_l", 4),
            ("select_town_line_r", 7),
            ("select_town_line_l", 8),
            ("select_town_line_r", 11),
            ("select_town_corner_dl", 12),
            ("select_town_line_d", 13),
            ("select_town_line_d", 14),
            ("select_town_corner_dr", 15),
        ),
    }

    def __init__(
        self,
        game_master,
        player_me,
        player_enemy,
        player_bionature,
        offset_btn_coords,
        ihm_right_side,
    ):
        self.game_master = game_master
        self.player_me = player_me
        self.player_enemy = player_enemy
        self.player_bionature = player_bionature
        self.offset_btn_x, self.offset_btn_y = offset_btn_coords
        self.ihm_right_side = ihm_right_side
        self.color = self.player_me.color
        self.current_mode = IhmMode.MAIN_MENU
        self.next_mode = IhmMode.SELECT_TOWN
        self.sleep_mode = False
        self.index_selected_town = 0
        self.selected_town = self.player_me.active_towns[self.index_selected_town]
        self.index_conquest_start = 0
        # TODO : si ça sert qu'à un seul truc (choix du départ de conquête),
        # faut renommer cette variable.
        self.tile_selector = None
        self.index_conquest_line = 0
        self.conquest_lines = None
        self.conquest_dir = None
        self.gamobj_conquest_line = None
        self.conquest_dest_pot_tiles = []
        self.current_conquest_line = None
        self.tile_next_town = None
        self.is_town_list_dirty = True
        self.pre_render_ihm_btn()
        self.refresh_town_list()

    def pre_render_ihm_btn(self):

        array_gamobjs = []
        for y in range(WARZONE_HEIGHT):
            line = []
            for x in range(OFFSET_INTERFACE_X):
                line.append(())
            array_gamobjs.append(line)

        for (name, btn_pos_x, btn_pos_y, link) in PlayerInterface.BUTTON_DEFINITIONS:
            index_tile = 0
            for tile_y in range(3):
                for tile_x in range(3):
                    final_x = self.offset_btn_x + btn_pos_x * 4 + tile_x
                    final_y = self.offset_btn_y + btn_pos_y * 4 + tile_y
                    gamobj = f"{self.color}_{name}_{index_tile:02d}"
                    array_gamobjs[final_y][final_x] = ("ihm_background", gamobj)
                    index_tile += 1
            if "D" in link:
                final_x = self.offset_btn_x + btn_pos_x * 4 + 1
                final_y = self.offset_btn_y + btn_pos_y * 4 + 3
                array_gamobjs[final_y][final_x] = ("ihm_background",)
            if "R" in link:
                final_x = self.offset_btn_x + btn_pos_x * 4 + 3
                final_y = self.offset_btn_y + btn_pos_y * 4 + 1
                array_gamobjs[final_y][final_x] = ("ihm_background",)

        if self.ihm_right_side:
            border_x = 0
            gamobj_border = "ihm_border_right"
        else:
            border_x = OFFSET_INTERFACE_X - 1
            gamobj_border = "ihm_border_left"

        for y in range(WARZONE_HEIGHT):
            array_gamobjs[y][border_x] = (gamobj_border,)

        array_gamobjs = [tuple(line) for line in array_gamobjs]
        self.array_gamobjs_ihm_btn = tuple(array_gamobjs)

    def refresh_town_list(self):
        self.is_town_list_dirty = False
        selected_tile = self.selected_town.tiles_position[0]
        self.sorted_towns = sorted(
            self.player_me.active_towns, key=lambda town: (town.y_up, town.x_left)
        )
        self.nb_towns = len(self.sorted_towns)
        # print("TODO refresh_town_list: self.nb_towns", self.nb_towns)
        if not self.nb_towns:
            # Cas stupide où on se retrouve avec 0 villes actives pendant un cycle de jeu,
            # parce que Player a commencé par créer une grosse ville.
            # On laisse tomber, et cette foncton sera rappelée plus tard.
            return

        # On retrouve la town qu'on a sélectionné (c'est pas forcément la même, si y'a eu des merge/shatter)
        # Et à partir de la town sélectionnée, on retrouve son index dans la liste.
        new_selected_town = selected_tile.town

        if new_selected_town is None:
            raise Exception("Perte de la sélection de town. Not supposed to happen.")

        try:
            self.index_selected_town = self.sorted_towns.index(new_selected_town)
        except ValueError:
            # Ça arrive si la town qu'on avait sélectionnée avant est devenue désactivée.
            # Dans ce cas on sait pas trop quoi faire, on reste sur une town désactivée et pis c'est tout.
            # On réglera ça plus tard, quand Player voudra lancer une action.
            return

        self.selected_town = new_selected_town

    def dirtify_town_list(self):
        # print("TODO Dirtyfication !!")
        self.is_town_list_dirty = True
        if self.selected_town not in self.player_me.active_towns:
            # La liste des towns a changée, et en plus, la town actuellement sélectionnée
            # n'est plus dans la liste des town active. Dans ce cas, on doit immédiatement changer
            # la town sélectionnée.
            # Dans le cas contraire, pas besoin de faire ça tout de suite. On le fera lorsque Player
            # voudra sélectionner une autre town.
            self.refresh_town_list()

    def add_interface_gamobjs(self, array_gamobjs):
        # TODO : pas de concaténation de merde avec self.color.
        town_selector_infos = PlayerInterface.TOWN_SELECTORS[self.selected_town.size]
        for gamobj, index_tile in town_selector_infos:
            tile = self.selected_town.tiles_position[index_tile]
            tile_from_coords(array_gamobjs, tile).append(self.color + "_" + gamobj)
        if self.tile_selector is not None:
            tile_from_coords(array_gamobjs, self.tile_selector).append(
                self.color + "_selector"
            )
        for tile in self.conquest_dest_pot_tiles:
            tile_from_coords(array_gamobjs, tile).append(
                self.color + "_ihm_conquest_dst_pot"
            )
        if self.current_conquest_line:
            for tile in self.current_conquest_line[:-1]:
                tile_from_coords(array_gamobjs, tile).append(self.gamobj_conquest_line)
            last_tile = self.current_conquest_line[-1]
            tile_from_coords(array_gamobjs, last_tile).append(self.color + "_selector")
        if self.tile_next_town is not None:
            if self.tile_next_town.town is not None:
                self.tile_next_town = None
            else:
                tile_from_coords(array_gamobjs, self.tile_next_town).append(
                    self.color + "_ihm_conquest_nxt_town"
                )

        x_lit_upleft, y_lit_upleft = self._get_lit_coordinates()
        x_lit_upleft += self.ihm_right_side * (WARZONE_WIDTH + OFFSET_INTERFACE_X)
        for y_lit in range(y_lit_upleft, y_lit_upleft + 3):
            for x_lit in range(x_lit_upleft, x_lit_upleft + 3):
                array_gamobjs[y_lit][x_lit][0] = self.color + "_ihm_lit_background"

        show_cancel = (
            (
                self.current_mode == IhmMode.SELECT_CONQUEST_TILE
                and self.index_conquest_start is None
            )
            or (
                self.current_mode == IhmMode.SELECT_CONQUEST_DEST
                and self.index_conquest_line is None
            )
            or (self.sleep_mode)
        )

        if show_cancel:
            gamobj_index = 0
            for y_cancel in range(y_lit_upleft, y_lit_upleft + 3):
                for x_cancel in range(x_lit_upleft, x_lit_upleft + 3):
                    # TODO : nan mais c'est dégueulase ça. Rhoooo ....
                    array_gamobjs[y_cancel][x_cancel][
                        1
                    ] = f"{self.color}_ihm_btn_cancel_{gamobj_index:02d}"

                    gamobj_index += 1

    def launch_missiles(self):
        # On vérifie que y'a pas déjà des missiles en construction pour cette town.
        tiles_gen_missile = self.selected_town.tiles_gen_missile
        for missile in self.game_master.missiles:
            if (
                missile.player_owner == self.player_me
                and missile.current_action == Missile.BUILDING
                and missile.tile in tiles_gen_missile
            ):
                # Il y a un missile en construction. On laisse tomber.
                return

        duration, missile_delays = Missile.GEN_INFOS_FROM_TOWN_SIZE[
            self.selected_town.size
        ]
        for tile, delay in zip(tiles_gen_missile, missile_delays):
            missile = Missile(self.player_me, tile, duration, self.game_master, delay)
            self.game_master.missiles.append(missile)

    def on_change_action(self):

        if self.sleep_mode:
            self.current_mode = IhmMode.MAIN_MENU
            self.next_mode = IhmMode.SELECT_TOWN
            self.sleep_mode = False

        elif self.current_mode == IhmMode.MAIN_MENU:
            next_modes = {
                IhmMode.SELECT_TOWN: (
                    IhmMode.SELECT_CONQUEST_TILE,
                    "next mode conquest tile",
                ),
                IhmMode.SELECT_CONQUEST_TILE: (
                    IhmMode.BACKWARD_CONQUEST,
                    "next mode backward conquest",
                ),
                IhmMode.BACKWARD_CONQUEST: (IhmMode.LAUNCH_MISSILE, "launch missile"),
                IhmMode.LAUNCH_MISSILE: (IhmMode.SUBMENU_CANCEL, "submenu cancel"),
                IhmMode.SUBMENU_CANCEL: (IhmMode.SELECT_TOWN, "next mode select town"),
            }
            next_next_mode, log = next_modes[self.next_mode]
            self.next_mode = next_next_mode
            # print(log) # TODO crap.

        elif self.current_mode == IhmMode.SELECT_TOWN:
            if self.is_town_list_dirty:
                self.refresh_town_list()
            self.index_selected_town += 1
            if self.index_selected_town >= self.nb_towns:
                self.index_selected_town = 0
            self.selected_town = self.sorted_towns[self.index_selected_town]

        elif self.current_mode == IhmMode.SELECT_CONQUEST_TILE:
            # On parcourt town.unit_gen_tiles : c'est la liste des tiles adjacentes de la town,
            # qui sont libres (c'est à dire que y'a pas une autre town dessus).
            conquest_tiles = self.selected_town.unit_gen_tiles

            if self.index_conquest_start is None:
                self.index_conquest_start = 0
            else:
                self.index_conquest_start += 1
                if self.index_conquest_start >= len(conquest_tiles):
                    self.index_conquest_start = None

            self.tile_selector = (
                None
                if self.index_conquest_start is None
                else conquest_tiles[self.index_conquest_start]
            )

        elif self.current_mode == IhmMode.SELECT_CONQUEST_DEST:
            if self.index_conquest_line is None:
                self.index_conquest_line = 0
            else:
                self.index_conquest_line += 1
                if self.index_conquest_line >= len(self.conquest_lines):
                    self.index_conquest_line = None

            self.current_conquest_line = (
                None
                if self.index_conquest_line is None
                else self.conquest_lines[self.index_conquest_line]
            )

        elif self.current_mode == IhmMode.SUBMENU_CANCEL:
            next_modes = {
                IhmMode.CANCEL_CURRENT_ORDERS: IhmMode.SLEEP_MODE,
                IhmMode.SLEEP_MODE: IhmMode.CANCEL_CURRENT_ORDERS,
            }
            next_next_mode = next_modes[self.next_mode]
            self.next_mode = next_next_mode

    def on_activate_action(self):

        # Si on est sur une town désactivée, on se remet à la town 0.
        # Le cas peut arriver, car on refreshe pas forcément la sélection lors des constructions de towns.
        # C'est bourrin, mais osef.
        if self.selected_town is None or not self.selected_town.is_active:
            self.refresh_town_list()
            self.index_selected_town = 0
            self.selected_town = self.sorted_towns[self.index_selected_town]
            print("TODO blargh town desactivée")
            return

        if self.current_mode == IhmMode.MAIN_MENU:
            self.tile_selector = None
            self.current_mode = self.next_mode

            if self.current_mode == IhmMode.SELECT_CONQUEST_TILE:
                self.index_conquest_start = 0
                conquest_tiles = self.selected_town.unit_gen_tiles
                self.tile_selector = conquest_tiles[self.index_conquest_start]
            elif self.current_mode == IhmMode.BACKWARD_CONQUEST:
                print("backward conquest !")
                # TODO : ça c'est du cancel all interface. Faudra le factoriser.
                self.player_me.cancel_all_orders()
                self.tile_next_town = None
                self.current_conquest_line = []
                self.current_mode = IhmMode.MAIN_MENU
                self.next_mode = IhmMode.SELECT_TOWN
                self.player_me.set_town_backward_conquest(self.selected_town)
                print("back to main menu")
            elif self.current_mode == IhmMode.LAUNCH_MISSILE:
                print("missiles !")
                # TODO : ça c'est du cancel all interface. Faudra le factoriser.
                self.player_me.cancel_all_orders()
                self.tile_next_town = None
                self.current_conquest_line = []
                self.current_mode = IhmMode.MAIN_MENU
                self.next_mode = IhmMode.LAUNCH_MISSILE
                self.launch_missiles()
                print("back to main menu")
            elif self.current_mode == IhmMode.SUBMENU_CANCEL:
                self.next_mode = IhmMode.CANCEL_CURRENT_ORDERS

        elif self.current_mode == IhmMode.SELECT_TOWN:
            self.tile_selector = None
            self.current_mode = IhmMode.MAIN_MENU
            print("back to main menu")

        elif self.current_mode == IhmMode.SELECT_CONQUEST_TILE:
            if self.tile_selector is None:
                self.current_mode = IhmMode.MAIN_MENU
                print("back to main menu")
            else:
                # Truc dégueulasse : on doit retrouver la direction de conquête en fonction de la town
                # et de la tile de démarrage de conquête. J'aurais vraiment pu arranger ça mieux, mais zut.
                for tile in self.selected_town.tiles_position:
                    dirs = directions_from_pos(tile, self.tile_selector)
                    if len(dirs) == 1:
                        self.conquest_dir = dirs[0]
                        break
                else:
                    raise Exception("Impossible de trouver la conquest dir. Blargh.")
                self.conquest_lines = []
                self.conquest_dest_pot_tiles = []
                current_tile = self.tile_selector
                current_conquest_line = []
                current_conquest_line.append(current_tile)
                for conquest_distance in range(9):

                    next_tile = current_tile.adjacencies[self.conquest_dir]
                    must_stop_lining = next_tile is None or next_tile.town is not None

                    if conquest_distance in (0, 3, 7) or must_stop_lining:
                        self.conquest_dest_pot_tiles.append(current_tile)
                        self.conquest_lines.append(list(current_conquest_line))
                        if must_stop_lining:
                            break

                    current_tile = next_tile
                    current_conquest_line.append(current_tile)

                if not self.conquest_lines:
                    raise Exception("conquest line empty. Not supposed to happen")
                self.tile_selector = None
                self.index_conquest_line = 0
                self.current_conquest_line = self.conquest_lines[
                    self.index_conquest_line
                ]
                self.tile_selector = None
                self.current_mode = IhmMode.SELECT_CONQUEST_DEST
                # Détermination de la direction vertic/horiz des routes.
                # TODO : c'est dégueux. Faut precalc les deux gamobj.
                self.gamobj_conquest_line = (
                    self.color + "_ihm_conquest_horiz"
                    if self.conquest_dir in (2, 6)
                    else self.color + "_ihm_conquest_vertic"
                )

                # TODO : crap.
                # for line in self.conquest_lines:
                #     print("--- conquest line ---")
                #     for tile in line:
                #         print(tile.x, tile.y)

        elif self.current_mode == IhmMode.SELECT_CONQUEST_DEST:
            self.conquest_dest_pot_tiles = []
            if self.index_conquest_line is None:
                self.current_mode = IhmMode.MAIN_MENU
                print("back to main menu")
            else:
                # TODO : factoriser les cancels.
                self.player_me.cancel_all_orders()
                self.player_me.tiles_to_roadify.extend(self.current_conquest_line)
                self.player_me.tile_to_townify = self.current_conquest_line[-1]
                self.tile_next_town = self.current_conquest_line[-1]
                self.player_me.is_roadify_horiz = self.conquest_dir in (2, 6)
                print("launch conquest")
                self.current_conquest_line = []
                self.current_mode = IhmMode.MAIN_MENU

        elif self.current_mode == IhmMode.SUBMENU_CANCEL:
            if self.next_mode == IhmMode.CANCEL_CURRENT_ORDERS:
                # TODO : ça c'est du cancel all interface. Faudra le factoriser.
                self.player_me.cancel_all_orders()
                self.tile_next_town = None
                self.current_conquest_line = []
                self.current_mode = IhmMode.MAIN_MENU
                self.next_mode = IhmMode.SELECT_TOWN
                print("back to main menu")
            else:
                self.sleep_mode = not self.sleep_mode
                if self.sleep_mode:
                    self.player_me.cancel_all_orders()

    def _get_lit_coordinates(self):
        mode_infos = (self.current_mode, self.next_mode)
        if mode_infos not in PlayerInterface.INDEX_LIT_BUTTONS:
            raise Exception(f"Fail mode_infos {mode_infos}")
        index_lit_button = PlayerInterface.INDEX_LIT_BUTTONS[mode_infos]
        btn_pos_x, btn_pos_y = PlayerInterface.BUTTON_DEFINITIONS[index_lit_button][1:3]
        # TODO : on l'a à deux endroits différents ce calcul à la con.
        final_x = self.offset_btn_x + btn_pos_x * 4
        final_y = self.offset_btn_y + btn_pos_y * 4 + OFFSET_INTERFACE_Y
        return final_x, final_y


SANDBOX_MODES = [
    "switch to interface mode",
    "add red unit",
    "add blu unit",
    "add horiz road",
    "add vertic road",
    "add town",
    "red magnet",
    "blu magnet",
    "backward conquest",
    "add grn unit",
    "conquest up",
    "conquest right",
    "conquest down",
    "conquest left",
    "missiles",
    "describe",
]

# Utile uniquement pour le mode sandbox.
def coord_move(x, y, direction):
    if direction == "R":
        x += 1
    elif direction == "L":
        x -= 1
    if direction == "D":
        y += 1
    if direction == "U":
        y -= 1
    return (x, y)


class GameModel:
    """
    Pas de doc précise concernant cette classe, car il y a sûrement beaucoup de choses
    qui vont changer.
    TODO : écrire la doc quand les choses arrêteront de changer.
    """

    def __init__(self):
        self.w = WARZONE_WIDTH
        self.h = WARZONE_HEIGHT
        self.nb_warzone_tiles = WARZONE_WIDTH * WARZONE_HEIGHT

        self.game_master = GameMaster(self.w, self.h)
        self.player_red = PlayerHandler(
            0, self.w, self.h, "red", self.game_master, rightward=True, downward=False
        )
        self.player_blu = PlayerHandler(
            1, self.w, self.h, "blu", self.game_master, rightward=False, downward=True
        )
        self.player_bionature = PlayerHandler(
            2, self.w, self.h, "grn", self.game_master, None, None, is_bionature=True
        )
        self.game_master.set_all_players(
            [self.player_red, self.player_blu], self.player_bionature
        )
        self.must_start = True
        self.player_interface_red = PlayerInterface(
            self.game_master,
            self.player_red,
            self.player_blu,
            self.player_bionature,
            (0, 5),
            False,
        )
        self.player_red.set_player_interface(self.player_interface_red)
        self.player_interface_blu = PlayerInterface(
            self.game_master,
            self.player_blu,
            self.player_red,
            self.player_bionature,
            (1, 5),
            True,
        )
        self.player_blu.set_player_interface(self.player_interface_blu)

        self.sandboxing = True
        self.sandbox_action = False
        self.x_cursor = 0
        self.y_cursor = 0
        self.sandbox_mode_index = 0
        self.turn_index = 0
        print("mode actuel :", SANDBOX_MODES[self.sandbox_mode_index])

    def export_all_tiles(self):
        gamobjs_source = self.game_master.gamobjs_to_export
        gamobjs_copy = []
        for _ in range(OFFSET_INTERFACE_Y - 1):
            line = [[]] * TOTAL_GAME_WIDTH
            gamobjs_copy.append(line)
        # TODO : précalculer cette line.
        line = (
            [[]] * OFFSET_INTERFACE_X
            + [["ihm_border_up"]] * WARZONE_WIDTH
            + [[]] * OFFSET_INTERFACE_X
        )
        gamobjs_copy.append(line)
        for line_ihm_red, line_source, line_ihm_blu in zip(
            self.player_interface_red.array_gamobjs_ihm_btn,
            gamobjs_source,
            self.player_interface_blu.array_gamobjs_ihm_btn,
        ):
            line = [
                list(gamobjs) for gamobjs in line_ihm_red + line_source + line_ihm_blu
            ]
            gamobjs_copy.append(line)

        # TODO : C'est dégueulasse tout ces offsets.
        for missile in self.game_master.missiles:
            tile = missile.tile
            gamobjs_copy[tile.y + OFFSET_INTERFACE_Y][
                tile.x + OFFSET_INTERFACE_X
            ].append(missile.gamobj)
        gamobjs_copy[self.y_cursor + OFFSET_INTERFACE_Y][
            self.x_cursor + OFFSET_INTERFACE_X
        ].append("red_cursor")
        for player in self.game_master.players:
            if player.tile_magnet is not None:
                tile = player.tile_magnet
                gamobjs_copy[tile.y + OFFSET_INTERFACE_Y][
                    tile.x + OFFSET_INTERFACE_X
                ].append(player.gamobj_magnet)
            if player.tile_go_backward is not None:
                tile = player.tile_go_backward
                gamobjs_copy[tile.y + OFFSET_INTERFACE_Y][
                    tile.x + OFFSET_INTERFACE_X
                ].append(player.gamobj_go_back)

        self.player_interface_red.add_interface_gamobjs(gamobjs_copy)
        self.player_interface_blu.add_interface_gamobjs(gamobjs_copy)
        return gamobjs_copy

    def _conquest(self, tile_target, direc):
        if tile_target.town is None:
            return
        player = tile_target.player_owner
        player.cancel_all_orders()
        cur_tile = tile_target
        add_a_town = True
        for _ in range(7):
            next_tile = cur_tile.adjacencies[direc]
            if next_tile is None:
                add_a_town = False
                break
            if next_tile.town is not None:
                if next_tile.player_owner == player:
                    add_a_town = False
                break
            player.tiles_to_roadify.append(next_tile)
            cur_tile = next_tile
        if add_a_town and cur_tile is not None and cur_tile.town is None:
            player.tile_to_townify = cur_tile
        player.is_roadify_horiz = direc in (2, 6)

    def on_process_turn(self):
        if self.sandbox_action:
            sandbox_mode = SANDBOX_MODES[self.sandbox_mode_index]
            tile_target = self.game_master.game_area[self.y_cursor][self.x_cursor]
            if sandbox_mode == "add red unit":
                if tile_target.town is None:
                    tile_target.add_unit(self.player_red, 1)
            elif sandbox_mode == "add blu unit":
                if tile_target.town is None:
                    tile_target.add_unit(self.player_blu, 1)
            elif sandbox_mode == "add horiz road":
                if tile_target.town is not None:
                    print("Pas de route sur une town")
                else:
                    tile_target.add_road(horiz=True)
            elif sandbox_mode == "add vertic road":
                if tile_target.town is not None:
                    print("Pas de route sur une town")
                else:
                    tile_target.add_road(vertic=True)
            elif sandbox_mode == "add town":
                if tile_target.player_owner is None or tile_target.town is not None:
                    print(
                        "On ne peut construire une ville que sur une case sans ville, mais occupée."
                    )
                    print("Et la construction avance seulement si il y a 16 unités.")
                else:
                    if tile_target.player_owner.tile_building_town is not None:
                        print("Ville déjà en construction pour cette couleur.")
                    else:
                        tile_target.player_owner.tile_building_town = tile_target
            elif sandbox_mode == "red magnet":
                self.player_red.cancel_all_orders()
                if self.player_red.tile_magnet == tile_target:
                    self.player_red.tile_magnet = None
                else:
                    self.player_red.tile_magnet = tile_target
            elif sandbox_mode == "blu magnet":
                self.player_blu.cancel_all_orders()
                if self.player_blu.tile_magnet == tile_target:
                    self.player_blu.tile_magnet = None
                else:
                    self.player_blu.tile_magnet = tile_target
            elif sandbox_mode == "backward conquest":
                if tile_target.town is None:
                    print("Il faut sélectionner une ville pour le backward conquest")
                else:
                    player = tile_target.player_owner
                    player.cancel_all_orders()
                    player.set_town_backward_conquest(tile_target.town)
            elif sandbox_mode == "add grn unit":
                if tile_target.town is None:
                    tile_target.add_unit(self.player_bionature, 1)
            elif sandbox_mode == "conquest up":
                self._conquest(tile_target, 0)
            elif sandbox_mode == "conquest right":
                self._conquest(tile_target, 2)
            elif sandbox_mode == "conquest down":
                self._conquest(tile_target, 4)
            elif sandbox_mode == "conquest left":
                self._conquest(tile_target, 6)
            elif sandbox_mode == "missiles":
                if tile_target.town is None:
                    print("Il faut sélectionner une ville pour balancer des missiles.")
                else:
                    # On vérifie que y'a pas déjà des missiles en construction pour cette town.
                    # TODO : factoriser ce bordel avec la fonction de PlayerIhm.
                    player_owner_missile = tile_target.town.player_owner
                    tiles_gen_missile = tile_target.town.tiles_gen_missile
                    can_launch_missile = True
                    for missile in self.game_master.missiles:
                        if (
                            missile.player_owner == player_owner_missile
                            and missile.current_action == Missile.BUILDING
                            and missile.tile in tiles_gen_missile
                        ):
                            can_launch_missile = False
                            break

                    if can_launch_missile:
                        # C'est bon, on peut lancer les missiles.
                        missile_delays_from_town_size = {
                            1: [None],
                            2: [2, 6],
                            4: [2, 10, 14, 6],
                        }
                        missile_delays = missile_delays_from_town_size[
                            tile_target.town.size
                        ]
                        for tile, delay in zip(tiles_gen_missile, missile_delays):
                            missile = Missile(
                                player_owner_missile, tile, 10, self.game_master, delay
                            )
                            self.game_master.missiles.append(missile)

            elif sandbox_mode == "describe":
                print("-----")
                print(tile_target)
                print("red can generate units", self.player_red.can_generate_unit())
                print("blu can generate units", self.player_blu.can_generate_unit())

            elif sandbox_mode == "switch to interface mode":
                print("switch to interface")
                self.sandboxing = False

            self.sandbox_action = False

        self.game_master.conquest_neutral_roads()
        self.game_master.equilibrate_units_in_suburbs(self.turn_index)
        # FUTURE : Ici il faudrait contrôler si toutes les tiles sont des towns.
        # Si oui, on arrête la génération de units pour tout le monde, et on affiche le score final.

        all_sleeping = (
            self.player_interface_red.sleep_mode
            and self.player_interface_blu.sleep_mode
        )

        for player in self.game_master.players:
            if not player.is_bionature:
                can_generate_unit = player.can_generate_unit()
                player.move_magnetized_units_on_suburb()
                player.process_town_building()
                player.move_units_on_roads(self.turn_index)
                player.move_units_on_bare_tiles(self.turn_index)
                player.process_backward_conquest(self.turn_index)
                if can_generate_unit:
                    player.process_unit_generation_town()
                player.process_town_merging()
                if can_generate_unit:
                    player.process_unit_gen_tile()
                player.process_line_conquest()
                if all_sleeping:
                    player.auto_build_towns()
            else:
                player.process_unit_gen_tile_bionature(self.turn_index)

        missiles_to_remove = []

        for missile in self.game_master.missiles:
            missile.handle()
            if missile.current_action == Missile.FINISHED:
                missiles_to_remove.append(missile)
        for missile_to_rem in missiles_to_remove:
            self.game_master.missiles.remove(missile_to_rem)

        self.turn_index += 1
        # FUTURE : calculer approximativement un délai plus ou moins long selon la quantité de trucs à gérer.
        # Plus on a eu à gérer de trucs durant ce tour, plus on met un délai court.
        # Mais c'est super chaud à estimer, ou alors faudrait regarder avec la date courante à chaque fois,
        # et je préfère m'occuper de ça plus tard (ou jamais).
        # TODO : constants, you stupid.
        if all_sleeping:
            return """ { "delayed_actions": [ {"name": "process_turn", "delay_ms": 10} ] } """
        else:
            return """ { "delayed_actions": [ {"name": "process_turn", "delay_ms": 200} ] } """

    def on_game_event(self, event_name):
        if event_name == "process_turn":
            return self.on_process_turn()
        if self.must_start:
            self.must_start = False
            return """ { "delayed_actions": [ {"name": "process_turn", "delay_ms": 10} ] } """

        if self.sandboxing:

            if event_name == "action_1":
                self.sandbox_mode_index += 1
                if self.sandbox_mode_index >= len(SANDBOX_MODES):
                    self.sandbox_mode_index = 0
                print("mode actuel :", SANDBOX_MODES[self.sandbox_mode_index])
                return
            if event_name == "action_2":
                self.sandbox_action = True
                return
            if event_name in "URDL":
                x_cursor_new, y_cursor_new = coord_move(
                    self.x_cursor, self.y_cursor, event_name
                )
                if 0 <= x_cursor_new < self.w and 0 <= y_cursor_new < self.h:
                    self.x_cursor, self.y_cursor = x_cursor_new, y_cursor_new
                return

        else:

            # TODO : dictionnaire de fonction qui tue.
            if event_name == "U":
                print("back to sandboxing")
                self.sandboxing = True
            elif event_name == "L":
                self.player_interface_red.on_change_action()
            elif event_name == "R":
                self.player_interface_red.on_activate_action()
            elif event_name == "action_1":
                self.player_interface_blu.on_change_action()
            elif event_name == "action_2":
                self.player_interface_blu.on_activate_action()


# TODO : bug dans la conquest line, on peut avoir 4 choix de distance alors qu'on devrait en avoir que 2.

# TODO : bug qui fait planter le truc en cours lorsqu'on choisit une conquête. (ligne 3508)
