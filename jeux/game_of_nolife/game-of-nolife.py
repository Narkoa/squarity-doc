# https://i.postimg.cc/5yYJx4Hq/game-of-nolife-tileset.png (old)
# https://i.postimg.cc/jSp2nF8y/game-of-nolife-tileset.png

"""
{
  "game_area": {
    "nb_tile_width": 60,
    "nb_tile_height": 38
  },
  "tile_size": 4,

  "img_coords": {
    "red_01": [0, 0],
    "red_02": [4, 0],
    "red_03": [8, 0],
    "red_04": [12, 0],
    "red_05": [16, 0],
    "red_06": [20, 0],
    "red_07": [24, 0],
    "red_08": [28, 0],
    "red_09": [32, 0],
    "red_10": [36, 0],
    "red_11": [40, 0],
    "red_12": [44, 0],
    "red_13": [48, 0],
    "red_14": [52, 0],
    "red_15": [56, 0],
    "red_16": [60, 0],
    "red_town_1x1": [68, 0],
    "red_town_2x2_00": [64, 12],
    "red_town_2x2_10": [68, 12],
    "red_town_2x2_01": [64, 16],
    "red_town_2x2_11": [68, 16],
    "red_town_4x4_00": [0, 16],
    "red_town_4x4_10": [4, 16],
    "red_town_4x4_20": [8, 16],
    "red_town_4x4_30": [12, 16],
    "red_town_4x4_01": [0, 20],
    "red_town_4x4_11": [4, 20],
    "red_town_4x4_21": [8, 20],
    "red_town_4x4_31": [12, 20],
    "red_town_4x4_02": [0, 24],
    "red_town_4x4_12": [4, 24],
    "red_town_4x4_22": [8, 24],
    "red_town_4x4_32": [12, 24],
    "red_town_4x4_03": [0, 28],
    "red_town_4x4_13": [4, 28],
    "red_town_4x4_23": [8, 28],
    "red_town_4x4_33": [12, 28],

    "red_select_town_1x1": [64, 24],
    "red_select_town_corner_ul": [60, 20],
    "red_select_town_line_u": [64, 20],
    "red_select_town_corner_ur": [68, 20],
    "red_select_town_line_l": [60, 24],
    "red_select_town_line_r": [68, 24],
    "red_select_town_corner_dl": [60, 28],
    "red_select_town_line_d": [64, 28],
    "red_select_town_corner_dr": [68, 28],
    "red_ihm_selector": [64, 32],
    "red_ihm_conquest_vertic": [56, 32],
    "red_ihm_conquest_horiz": [52, 32],
    "red_ihm_conquest_dst_pot": [48, 32],
    "red_ihm_conquest_nxt_town": [60, 32],

    "red_controls": [64, 0],
    "red_road_horiz": [72, 0],
    "red_road_vertic": [76, 0],
    "red_road_both": [80, 0],
    "red_magnet": [68, 32],
    "red_go_back": [72, 32],

    "red_town_build_00": [0, 12],
    "red_town_build_01": [4, 12],
    "red_town_build_02": [8, 12],
    "red_town_build_03": [12, 12],
    "red_town_build_04": [16, 12],
    "red_town_build_05": [20, 12],
    "red_town_build_06": [24, 12],
    "red_town_build_07": [28, 12],
    "red_town_build_08": [32, 12],
    "red_town_build_09": [36, 12],

    "blu_01": [0, 4],
    "blu_02": [4, 4],
    "blu_03": [8, 4],
    "blu_04": [12, 4],
    "blu_05": [16, 4],
    "blu_06": [20, 4],
    "blu_07": [24, 4],
    "blu_08": [28, 4],
    "blu_09": [32, 4],
    "blu_10": [36, 4],
    "blu_11": [40, 4],
    "blu_12": [44, 4],
    "blu_13": [48, 4],
    "blu_14": [52, 4],
    "blu_15": [56, 4],
    "blu_16": [60, 4],
    "blu_town_1x1": [68, 4],
    "blu_town_2x2_00": [72, 12],
    "blu_town_2x2_10": [76, 12],
    "blu_town_2x2_01": [72, 16],
    "blu_town_2x2_11": [76, 16],
    "blu_town_4x4_00": [16, 16],
    "blu_town_4x4_10": [20, 16],
    "blu_town_4x4_20": [24, 16],
    "blu_town_4x4_30": [28, 16],
    "blu_town_4x4_01": [16, 20],
    "blu_town_4x4_11": [20, 20],
    "blu_town_4x4_21": [24, 20],
    "blu_town_4x4_31": [28, 20],
    "blu_town_4x4_02": [16, 24],
    "blu_town_4x4_12": [20, 24],
    "blu_town_4x4_22": [24, 24],
    "blu_town_4x4_32": [28, 24],
    "blu_town_4x4_03": [16, 28],
    "blu_town_4x4_13": [20, 28],
    "blu_town_4x4_23": [24, 28],
    "blu_town_4x4_33": [28, 28],

    "blu_select_town_1x1": [76, 24],
    "blu_select_town_corner_ul": [72, 20],
    "blu_select_town_line_u": [76, 20],
    "blu_select_town_corner_ur": [80, 20],
    "blu_select_town_line_l": [72, 24],
    "blu_select_town_line_r": [80, 24],
    "blu_select_town_corner_dl": [72, 28],
    "blu_select_town_line_d": [76, 28],
    "blu_select_town_corner_dr": [80, 28],
    "blu_ihm_selector": [64, 36],
    "blu_ihm_conquest_vertic": [56, 36],
    "blu_ihm_conquest_horiz": [52, 36],
    "blu_ihm_conquest_dst_pot": [48, 36],
    "blu_ihm_conquest_nxt_town": [60, 36],

    "blu_controls": [64, 4],
    "blu_road_horiz": [72, 4],
    "blu_road_vertic": [76, 4],
    "blu_road_both": [80, 4],
    "blu_magnet": [68, 36],
    "blu_go_back": [72, 36],

    "blu_town_build_00": [40, 12],
    "blu_town_build_01": [44, 12],
    "blu_town_build_02": [48, 12],
    "blu_town_build_03": [52, 12],
    "blu_town_build_04": [56, 12],
    "blu_town_build_05": [60, 12],
    "blu_town_build_06": [40, 16],
    "blu_town_build_07": [44, 16],
    "blu_town_build_08": [48, 16],
    "blu_town_build_09": [52, 16],

    "town_desactivate": [68, 8],
    "neutral_road_horiz": [72, 8],
    "neutral_road_vertic": [76, 8],
    "neutral_road_both": [80, 8],

    "grn_01": [0, 8],
    "grn_02": [4, 8],
    "grn_03": [8, 8],
    "grn_04": [12, 8],
    "grn_05": [16, 8],
    "grn_06": [20, 8],
    "grn_07": [24, 8],
    "grn_08": [28, 8],
    "grn_09": [32, 8],
    "grn_10": [36, 8],
    "grn_11": [40, 8],
    "grn_12": [44, 8],
    "grn_13": [48, 8],
    "grn_14": [52, 8],
    "grn_15": [56, 8],
    "grn_16": [60, 8],
    "grn_controls": [64, 8],
    "grn_road_horiz": [32, 20],
    "grn_road_vertic": [36, 20],
    "grn_road_both": [40, 20],

    "missile_ur": [32, 16],
    "missile_dl": [36, 16],
    "missile_exploding": [34, 16],

    "missile_build_00": [48, 56],
    "missile_build_01": [52, 56],
    "missile_build_02": [56, 56],
    "missile_build_03": [60, 56],
    "missile_build_04": [64, 56],
    "missile_build_05": [48, 60],
    "missile_build_06": [52, 60],
    "missile_build_07": [56, 60],
    "missile_build_08": [60, 60],
    "missile_build_09": [64, 60],

    "ihm_background": [44, 20],
    "ihm_border_up": [56, 20],
    "ihm_border_left": [56, 16],
    "ihm_border_right": [60, 16],

    "red_ihm_conquest_up": [32, 28],
    "red_ihm_conquest_right": [36, 28],
    "red_ihm_conquest_down": [40, 28],
    "red_ihm_conquest_left": [44, 28],
    "red_ihm_arrow_to_map_1": [48, 24],
    "red_ihm_arrow_to_map_2": [48, 28],

    "blu_ihm_conquest_up": [32, 24],
    "blu_ihm_conquest_right": [36, 24],
    "blu_ihm_conquest_down": [40, 24],
    "blu_ihm_conquest_left": [44, 24],
    "blu_ihm_arrow_to_map_1": [52, 24],
    "blu_ihm_arrow_to_map_2": [52, 28],

    "red_ihm_btn_select_00": [0, 56],
    "red_ihm_btn_select_01": [4, 56],
    "red_ihm_btn_select_02": [8, 56],
    "red_ihm_btn_select_03": [0, 60],
    "red_ihm_btn_select_04": [4, 60],
    "red_ihm_btn_select_05": [8, 60],
    "red_ihm_btn_select_06": [0, 64],
    "red_ihm_btn_select_07": [4, 64],
    "red_ihm_btn_select_08": [8, 64],
    "red_ihm_btn_conq_00": [12, 56],
    "red_ihm_btn_conq_01": [16, 56],
    "red_ihm_btn_conq_02": [20, 56],
    "red_ihm_btn_conq_03": [12, 60],
    "red_ihm_btn_conq_04": [16, 60],
    "red_ihm_btn_conq_05": [20, 60],
    "red_ihm_btn_conq_06": [12, 64],
    "red_ihm_btn_conq_07": [16, 64],
    "red_ihm_btn_conq_08": [20, 64],
    "red_ihm_btn_backw_00": [24, 56],
    "red_ihm_btn_backw_01": [28, 56],
    "red_ihm_btn_backw_02": [32, 56],
    "red_ihm_btn_backw_03": [24, 60],
    "red_ihm_btn_backw_04": [28, 60],
    "red_ihm_btn_backw_05": [32, 60],
    "red_ihm_btn_backw_06": [24, 64],
    "red_ihm_btn_backw_07": [28, 64],
    "red_ihm_btn_backw_08": [32, 64],
    "red_ihm_btn_missile_00": [36, 56],
    "red_ihm_btn_missile_01": [40, 56],
    "red_ihm_btn_missile_02": [44, 56],
    "red_ihm_btn_missile_03": [36, 60],
    "red_ihm_btn_missile_04": [40, 60],
    "red_ihm_btn_missile_05": [44, 60],
    "red_ihm_btn_missile_06": [36, 64],
    "red_ihm_btn_missile_07": [40, 64],
    "red_ihm_btn_missile_08": [44, 64],
    "red_ihm_btn_conqdir_00": [0, 68],
    "red_ihm_btn_conqdir_01": [4, 68],
    "red_ihm_btn_conqdir_02": [8, 68],
    "red_ihm_btn_conqdir_03": [0, 72],
    "red_ihm_btn_conqdir_04": [4, 72],
    "red_ihm_btn_conqdir_05": [8, 72],
    "red_ihm_btn_conqdir_06": [0, 76],
    "red_ihm_btn_conqdir_07": [4, 76],
    "red_ihm_btn_conqdir_08": [8, 76],
    "red_ihm_btn_conqdist_00": [12, 68],
    "red_ihm_btn_conqdist_01": [16, 68],
    "red_ihm_btn_conqdist_02": [20, 68],
    "red_ihm_btn_conqdist_03": [12, 72],
    "red_ihm_btn_conqdist_04": [16, 72],
    "red_ihm_btn_conqdist_05": [20, 72],
    "red_ihm_btn_conqdist_06": [12, 76],
    "red_ihm_btn_conqdist_07": [16, 76],
    "red_ihm_btn_conqdist_08": [20, 76],
    "red_ihm_btn_cancel_00": [24, 68],
    "red_ihm_btn_cancel_01": [28, 68],
    "red_ihm_btn_cancel_02": [32, 68],
    "red_ihm_btn_cancel_03": [24, 72],
    "red_ihm_btn_cancel_04": [28, 72],
    "red_ihm_btn_cancel_05": [32, 72],
    "red_ihm_btn_cancel_06": [24, 76],
    "red_ihm_btn_cancel_07": [28, 76],
    "red_ihm_btn_cancel_08": [32, 76],
    "red_ihm_btn_noorder_00": [36, 68],
    "red_ihm_btn_noorder_01": [40, 68],
    "red_ihm_btn_noorder_02": [44, 68],
    "red_ihm_btn_noorder_03": [36, 72],
    "red_ihm_btn_noorder_04": [40, 72],
    "red_ihm_btn_noorder_05": [44, 72],
    "red_ihm_btn_noorder_06": [36, 76],
    "red_ihm_btn_noorder_07": [40, 76],
    "red_ihm_btn_noorder_08": [44, 76],
    "red_ihm_btn_sleep_00": [48, 68],
    "red_ihm_btn_sleep_01": [52, 68],
    "red_ihm_btn_sleep_02": [56, 68],
    "red_ihm_btn_sleep_03": [48, 72],
    "red_ihm_btn_sleep_04": [52, 72],
    "red_ihm_btn_sleep_05": [56, 72],
    "red_ihm_btn_sleep_06": [48, 76],
    "red_ihm_btn_sleep_07": [52, 76],
    "red_ihm_btn_sleep_08": [56, 76],
    "red_ihm_lit_background": [52, 20],

    "blu_ihm_btn_select_00": [0, 32],
    "blu_ihm_btn_select_01": [4, 32],
    "blu_ihm_btn_select_02": [8, 32],
    "blu_ihm_btn_select_03": [0, 36],
    "blu_ihm_btn_select_04": [4, 36],
    "blu_ihm_btn_select_05": [8, 36],
    "blu_ihm_btn_select_06": [0, 40],
    "blu_ihm_btn_select_07": [4, 40],
    "blu_ihm_btn_select_08": [8, 40],
    "blu_ihm_btn_conq_00": [12, 32],
    "blu_ihm_btn_conq_01": [16, 32],
    "blu_ihm_btn_conq_02": [20, 32],
    "blu_ihm_btn_conq_03": [12, 36],
    "blu_ihm_btn_conq_04": [16, 36],
    "blu_ihm_btn_conq_05": [20, 36],
    "blu_ihm_btn_conq_06": [12, 40],
    "blu_ihm_btn_conq_07": [16, 40],
    "blu_ihm_btn_conq_08": [20, 40],
    "blu_ihm_btn_backw_00": [24, 32],
    "blu_ihm_btn_backw_01": [28, 32],
    "blu_ihm_btn_backw_02": [32, 32],
    "blu_ihm_btn_backw_03": [24, 36],
    "blu_ihm_btn_backw_04": [28, 36],
    "blu_ihm_btn_backw_05": [32, 36],
    "blu_ihm_btn_backw_06": [24, 40],
    "blu_ihm_btn_backw_07": [28, 40],
    "blu_ihm_btn_backw_08": [32, 40],
    "blu_ihm_btn_missile_00": [36, 32],
    "blu_ihm_btn_missile_01": [40, 32],
    "blu_ihm_btn_missile_02": [44, 32],
    "blu_ihm_btn_missile_03": [36, 36],
    "blu_ihm_btn_missile_04": [40, 36],
    "blu_ihm_btn_missile_05": [44, 36],
    "blu_ihm_btn_missile_06": [36, 40],
    "blu_ihm_btn_missile_07": [40, 40],
    "blu_ihm_btn_missile_08": [44, 40],
    "blu_ihm_btn_conqdir_00": [0, 44],
    "blu_ihm_btn_conqdir_01": [4, 44],
    "blu_ihm_btn_conqdir_02": [8, 44],
    "blu_ihm_btn_conqdir_03": [0, 48],
    "blu_ihm_btn_conqdir_04": [4, 48],
    "blu_ihm_btn_conqdir_05": [8, 48],
    "blu_ihm_btn_conqdir_06": [0, 52],
    "blu_ihm_btn_conqdir_07": [4, 52],
    "blu_ihm_btn_conqdir_08": [8, 52],
    "blu_ihm_btn_conqdist_00": [12, 44],
    "blu_ihm_btn_conqdist_01": [16, 44],
    "blu_ihm_btn_conqdist_02": [20, 44],
    "blu_ihm_btn_conqdist_03": [12, 48],
    "blu_ihm_btn_conqdist_04": [16, 48],
    "blu_ihm_btn_conqdist_05": [20, 48],
    "blu_ihm_btn_conqdist_06": [12, 52],
    "blu_ihm_btn_conqdist_07": [16, 52],
    "blu_ihm_btn_conqdist_08": [20, 52],
    "blu_ihm_btn_cancel_00": [24, 44],
    "blu_ihm_btn_cancel_01": [28, 44],
    "blu_ihm_btn_cancel_02": [32, 44],
    "blu_ihm_btn_cancel_03": [24, 48],
    "blu_ihm_btn_cancel_04": [28, 48],
    "blu_ihm_btn_cancel_05": [32, 48],
    "blu_ihm_btn_cancel_06": [24, 52],
    "blu_ihm_btn_cancel_07": [28, 52],
    "blu_ihm_btn_cancel_08": [32, 52],
    "blu_ihm_btn_noorder_00": [36, 44],
    "blu_ihm_btn_noorder_01": [40, 44],
    "blu_ihm_btn_noorder_02": [44, 44],
    "blu_ihm_btn_noorder_03": [36, 48],
    "blu_ihm_btn_noorder_04": [40, 48],
    "blu_ihm_btn_noorder_05": [44, 48],
    "blu_ihm_btn_noorder_06": [36, 52],
    "blu_ihm_btn_noorder_07": [40, 52],
    "blu_ihm_btn_noorder_08": [44, 52],
    "blu_ihm_btn_sleep_00": [48, 44],
    "blu_ihm_btn_sleep_01": [52, 44],
    "blu_ihm_btn_sleep_02": [56, 44],
    "blu_ihm_btn_sleep_03": [48, 48],
    "blu_ihm_btn_sleep_04": [52, 48],
    "blu_ihm_btn_sleep_05": [56, 48],
    "blu_ihm_btn_sleep_06": [48, 52],
    "blu_ihm_btn_sleep_07": [52, 52],
    "blu_ihm_btn_sleep_08": [56, 52],
    "blu_ihm_lit_background": [48, 20],

    "blu_ihm_count_town_rig_1": [64, 40],
    "blu_ihm_count_town_rig_2": [68, 40],
    "blu_ihm_count_town_rig_3": [72, 40],
    "blu_ihm_count_tile_rig_1": [64, 44],
    "blu_ihm_count_tile_rig_2": [68, 44],
    "blu_ihm_count_tile_rig_3": [72, 44],
    "blu_ihm_count_town_lef_1": [64, 48],
    "blu_ihm_count_town_lef_2": [68, 48],
    "blu_ihm_count_town_lef_3": [72, 48],
    "blu_ihm_count_tile_lef_1": [64, 52],
    "blu_ihm_count_tile_lef_2": [68, 52],
    "blu_ihm_count_tile_lef_3": [72, 52],
    "blu_ihm_count_town_full": [76, 40],
    "blu_ihm_count_tile_full": [76, 44],

    "red_ihm_count_town_rig_1": [64, 64],
    "red_ihm_count_town_rig_2": [68, 64],
    "red_ihm_count_town_rig_3": [72, 64],
    "red_ihm_count_tile_rig_1": [64, 68],
    "red_ihm_count_tile_rig_2": [68, 68],
    "red_ihm_count_tile_rig_3": [72, 68],
    "red_ihm_count_town_lef_1": [64, 72],
    "red_ihm_count_town_lef_2": [68, 72],
    "red_ihm_count_town_lef_3": [72, 72],
    "red_ihm_count_tile_lef_1": [64, 76],
    "red_ihm_count_tile_lef_2": [68, 76],
    "red_ihm_count_tile_lef_3": [72, 76],
    "red_ihm_count_town_full": [76, 64],
    "red_ihm_count_tile_full": [76, 68],

    "sandbox_cursor": [56, 24]
  }
}
"""


"""

------------
GAME OF NO-LIFE v0.1
------------

Petite information concernant les commentaires dans le code.

J'essaye d'écrire en inclusif, sans pour autant gonfler tout le monde avec des points médians,
ou des mots à rallonge tel que "le/la joueureuse".
Pour ça, la langue anglaise est assez bien, car la plupart des mots sont neutres.
(Et la personne qui vient me dire que c'est mal d'angliciser la langue française,
je lui mets un punch in his/her face).

Pour désigner la personne qui joue, j'utilise le terme "Player". Et je fais comme si
c'était son prénom. Vous lirez donc des phrases du genre : "Player doit déplacer ses unités",
"la town de Player", etc.

Ça règle pas tout, mais c'est déjà ça.


Vocabulaire spécifique au jeu :

unité/pixel : un petit pixel rouge, bleu ou vert, qui peut se déplacer d'une tile à l'autre.

tile/case : une case du jeu. Ça fait partie du vocabulaire générique de Squarity

bare tile : une tile sur laquelle il n'y a ni ville ni route.
Mais il peut y avoir une ou plusieurs unités.

bionature : les pixels verts, qui ne sont pas contrôlés par un humain, mais par le jeu.

town/ville : une ville, de couleur rouge ou bleue. La bionature ne construit pas de ville.

merge : fusionner un carré de 2x2 ville pour faire une grosse ville,
ou bien fusionner un carré de 2x2 grosses villes pour faire une méga-ville,

shatter : séparer une grosse ville en un carré de 2x2 villes,
ou bien séparer une méga-ville en un carré de 2x2 grosses villes.
On effectue des shatters pour réorganiser les gros paquets de ville, et espérer
les refusionner d'une meilleure manière après.

wardness/direction de conquête : deux booléens indiquant la direction
dans laquelle Player doit aller :
 - rightward : direction horizontale (True:droite, False:gauche)
 - upward : direction verticale (True:bas , False:haut)
Pour red : rightward=True, upward=False. Pour blue, c'est inversé.

La direction de conquête influe sur différents détails : l'ordre des tiles adjacentes où les towns
posent les pixels générés, la direction des missiles bactériologiques, l'ordre de priorité des
merge de town, la direction des backward conquest, etc.

line conquest : construction, à partir d'une ville existante, d'une ligne de route
(horizontale ou verticale), sur une distance prédéfinie. Puis construction, au bout
de cette ligne de route, d'une nouvelle ville.
"""

# TODO : ajouter des commentaires de code dans les parties non documentées.

# TODO : rédiger la doc expliquant comment jouer.
# dans la doc, expliquer que des fois il faut appuyer deux fois sur l'activation pour quitter le mode "dodo",
# à cause d'une mauvaise gestion dans la sélection des villes, mais c'est comme ça.

# Remplacer le mot "False" par "True" dans la ligne de code ci-dessous,
# pour autoriser le mode sandbox.
# Lorsque ce mode est activé, les boutons d'interface des Players ne sont
# plus utilisables. À la place, vous avez un curseur dans la zone de jeu,
# que vous pouvez déplacer avec les flèches.
# Le bouton d'action "1" permet de parcourir les différentes actions,
# et le bouton "2" d'activer l'action sélectionnée.
# Par ex: ajouter un pixel rouge, ajouter une route, construire une ville, ...
# Ce mode sandbox permet de tester différentes situations de jeux,
# et aussi de débugger, si vous avez envie de modifier ce code.
# Pour revenir au mode normal, sélectionner l'action "switch to play mode",
# puis activez-là avec le bouton "2".
# Pour revenir au mode sandbox, appuyez sur la flèche du haut.
AUTHORIZE_SANDBOX_MODE = False

# FUTURE : suppression du backward conquest en cours si une town est merge/shatterée.

import random

# Dimensions, en nombre de cases, de l'aire de la "warzone", c'est à dire le cadre
# dans lequel évoluent les unités, les villes, etc.
WARZONE_WIDTH = 36
WARZONE_HEIGHT = 36
# Décalage de l'affichage de la warzone, par rapport à l'aire de jeu complète.
# Il y a deux lignes de cases vide au-dessus, où on affiche les barres
# rouges et bleus indiquant le nombre de tiles et de towns de chaque Player.
# Il y a douze colonnes de cases à gauche et à droite,
# pour afficher les boutons d'interface.
OFFSET_INTERFACE_X = 12
OFFSET_INTERFACE_Y = 2
# Dimensions, en nombre de cases, du jeu Squarity, en comptant les cases dédiées
# à l'interface.
TOTAL_GAME_WIDTH = WARZONE_WIDTH + 2 * OFFSET_INTERFACE_X
TOTAL_GAME_HEIGHT = WARZONE_HEIGHT + OFFSET_INTERFACE_Y

# Si Player possède un nombre d'unité supérieur à (RATIO_CONTROLLED_TILE_FOR_GENERATION * nombre de tile contrôlées),
# la génération d'unité se met en pause (town et tiles). Ça évite de se retrouver avec un gros tas d'unités
# dont on sait pas quoi faire, et ça rend encore plus importante l'occupation de terrains.
RATIO_CONTROLLED_TILE_FOR_GEN = 3

# La distance jusqu'à laquelle on fait le backward conquest,
# en fonction de la size de la town.
DIST_BACKWARD_CONQUEST = {1: 3, 2: 6, 4: 9}
# Nombre d'unité à envoyer à chaque tour en backward conquest,
# en fonction de la size de la town.
NB_UNIT_TO_SENT_BACKWARD_CONQUEST = {1: 1, 2: 2, 4: 3}

# Nombre de tours de jeu nécessaire pour construire une town.
NB_TURNS_TOWN_BUILDING = 9
# Pour qu'une town soit construite, il faut conserver les 16 unités sur la tile,
# durant toute la construction. Si des unités sont supprimées
# suite à un événement quelconque, la construction est mise en pause.
# La construction de la town s'annule si elle n'est pas terminée
# au bout de "NB_TURNS_TOWN_BUILDING_TIMEOUT" tours.
NB_TURNS_TOWN_BUILDING_TIMEOUT = 25
# Nombre de points que doit accumuler une ville pour générer un pixel.
# La ville gagne un nombre fixe de points à chaque tour, selon sa taille.
# petite : 1, moyenne : 6, grande : 22.
# J'ai mis un nombre assez grand, car ce ne sont pas les villes qui produisent le plus,
# mais le fait de contrôler beaucoup de terrain. Ça devrait (j'espère) rendre le jeu
# plus intéressant.
UNIT_GEN_TOWN_POINT_REQUIRED = 100
# Parfois, une town ne peut pas générer de pixels, parce que toutes les tiles autour d'elle
# sont déjà pleines de pixels. Dans ce cas, la town cumule ses points de génération pour
# plus tard, lorsqu'elle aura de la place autour d'elle.
# Cette variable indique le nombre de points de génération max qu'une town peut cumuler.
UNIT_GEN_TOWN_POINT_MAX_CUMUL = UNIT_GEN_TOWN_POINT_REQUIRED * 2

# Nombre de points à avoir pour générer un pixel par le terrain contrôlé.
# On gagne un point par tour et par tile contrôlée. Une tile est contrôlée si on possède
# au moins une unité dessus.
# Petit calcul pour prouver que c'est plus avantageux de prendre du terrain que de
# construire des villes :
# J'ai 256 pixels, je m'en sers pour conquérir 256 terrains.
# UNIT_GEN_TILE_POINT_REQUIRED / 256 = 3.51.
# Ces 256 terrains vont me générer un pixel tous les 3,51 tours.
# J'ai 256 pixels, ça fait 16 * 4 * 4. Je peux m'en servir pour construire une super grosse ville.
# UNIT_GEN_TOWN_POINT_REQUIRED / 22 = 4.54.
# La super grosse ville me génère un pixel tous les 4,54 tours.
# L'avantage est encore plus flagrant avec les petites villes et les moyennes villes.
UNIT_GEN_TILE_POINT_REQUIRED = 850
# Cumul de points de génération par terrain contrôlé. Pour le cas où on a assez de points
# mais qu'on ne trouve pas de tile sur laquelle poser le pixel généré.
UNIT_GEN_TILE_POINT_MAX_CUMUL = UNIT_GEN_TILE_POINT_REQUIRED * 50
# Nombre de points que la bionature doit avoir pour générer un pixel vert.
# La bionature gagne un point par tour et par tile contrôlée.
# C'est beaucoup plus que UNIT_GEN_TILE_POINT_REQUIRED, car la bionature a beaucoup de terrain
# au départ, et ça embêterait les Players humains d'avoir une bionature qui s'étend trop vite.
UNIT_GEN_TILE_POINT_REQUIRED_BIONATURE = 25000

# Les directions opposées en fonction d'une direction.
# 0:haut, 1:diag haut-droite, 2:droite, etc. ça tourne dans le sens des aiguilles d'une montre.
REVERSE_DIRS = (4, 5, 6, 7, 0, 1, 2, 3)

# Moche, mais ça permet de convertir plus rapidement.
GAMOBJ_NAME_TO_NB_UNIT = tuple(
    "00;01;02;03;04;05;06;07;08;09;10;11;12;13;14;15;16".split(";")
)

# Ratio pour la barre de comptage des tiles et towns, affichée en haut de l'aire de jeu.
# Indique le nombre de tile ou de town contrôlées auquel correspond un pixel de la barre de comptage.
BAR_COUNT_RATIO = (WARZONE_WIDTH * WARZONE_HEIGHT) // (TOTAL_GAME_WIDTH * 4) + 1

# Nombre de tile occupée par une town, en fonction de sa taille. Bon c'est juste la taille au carré.
TOWN_NB_TILES = (0, 1, 4, 9, 16)

# Utile pour les messages affichés dans la console.
COLOR_NAME = {"red": "Rouge", "blu": "Bleue"}


def iterate_on_pseudo_random_boolean():
    """
    Fonction qui sort des booléens random à l'arrache, à partir d'une liste
    de 1000 valeurs booléennes random prédéfinies. C'est de la merde, mais on n'a pas besoin de plus.
    Et ça évitera de faire ralentir le jeu en appelant la vraie fonction random à chaque fois.
    """
    RANDOM_QUANTITY = 1000
    bools = [True] * (RANDOM_QUANTITY // 2) + [False] * (RANDOM_QUANTITY // 2)
    random.shuffle(bools)
    index_bool = 0
    while 1:
        yield bools[index_bool]
        index_bool += 1
        if index_bool >= RANDOM_QUANTITY:
            index_bool = 0


pseudo_random_boolean = iterate_on_pseudo_random_boolean()
# Première itération pour initialiser et shuffler la liste.
# Le booléen renvoyé ne sert à rien. Osef.
next(pseudo_random_boolean)


def pos_in_bounding_rect(b_rect, x, y):
    """
    Renvoie True si la position x, y est dans le rect.
    Le rect à passer en paramètre s'étend de x1 à x2 - 1, et de y1 à y2 - 1.
    """
    x_min, y_min, x_max, y_max = b_rect
    return (x_min <= x < x_max) and (y_min <= y < y_max)


def bounding_rect_overlaps(b_rect_1, b_rect_2):
    """
    Renvoie True si les deux rectangles se chevauchent.
    Les rect à passer en paramètre s'étendent de x1 à x2 - 1, et de y1 à y2 - 1.
    """
    x_min_1, y_min_1, x_max_1, y_max_1 = b_rect_1
    x_min_2, y_min_2, x_max_2, y_max_2 = b_rect_2
    if x_max_1 <= x_min_2 or x_max_2 <= x_min_1:
        return False
    if y_max_1 <= y_min_2 or y_max_2 <= y_min_1:
        return False
    return True


def manhattan_dist(tile_1, tile_2):
    """
    "Tout était monstre à tête de chien".
    (Luke, Manhattan).
    """
    return abs(tile_1.x - tile_2.x) + abs(tile_1.y - tile_2.y)


def directions_from_pos(tile_src, tile_dst):
    """
    Renvoie un tuple de 0, 1 ou 2 directions : 0, 6, 4 ou 2,
    en fonction de la position relative de tile_src par rapport à tile_dst.
    0: up, 2:right, 4:down, 6:left.
    Les directions renvoyées correspondent à celles pour aller de tile_src vers tile_dst.
    Si tile_src et tile_dst sont sur la même ligne ou la même colonne, la fonction ne renverra
    qu'une seule direction.
    L'ordre est déterminé selon la distance. Si les deux tiles sont plus éloigneés en X qu'en Y,
    la première direction du tuple sera la direction horizontale. Sinon, c'est l'inverse.
    (On se sert pas de cette particularité dans le code, mais on sait jamais).
    """
    diff_x = tile_dst.x - tile_src.x
    diff_y = tile_dst.y - tile_src.y
    directions = []
    if diff_x:
        dir_x = 6 if diff_x < 0 else 2
        directions.append(dir_x)
    if diff_y:
        dir_y = 0 if diff_y < 0 else 4
        directions.append(dir_y)

    if abs(diff_x) < abs(diff_y):
        directions = directions[::-1]
    return directions


def is_behind_right_down(tile_ref, tile_test):
    """
    Les fonction is_behind_xxx permettent de savoir si une tile est "derrière" une autre tile,
    par rapport à la direction de conquête de Player (rightward, downward).
    Renvoie True si tile_test est derrière tile_ref.
    """
    return tile_test.x <= tile_ref.x and tile_test.y <= tile_ref.y


def is_behind_left_down(tile_ref, tile_test):
    return tile_test.x >= tile_ref.x and tile_test.y <= tile_ref.y


def is_behind_right_up(tile_ref, tile_test):
    return tile_test.x <= tile_ref.x and tile_test.y >= tile_ref.y


def is_behind_left_up(tile_ref, tile_test):
    return tile_test.x >= tile_ref.x and tile_test.y >= tile_ref.y


def get_town_infos_right_down(town):
    """
    Les fonctions get_town_infos_xxx renvoient un tuple de 3 éléments.

    Les deux premiers éléments correspondent à la coordonnée x, y de la tile la plus
    en arrière, de la town passée en paramètre.
    Si la town a une taille de 1, on n'a pas le choix, ce sera la tile de la town.
    Si la town est plus étendue, la tile la plus arrière se trouve dans un coin.
    Le coin en question dépend de la direction de conquête de Player.
    C'est pour ça qu'il y a 4 fonctions, une par direction de conquête.

    Le dernier élément du tuple renvoyé est un sous-tuple de 2 éléments.
    Il s'agit d'une clé de tri, pour ordonner les villes, en fonction de la direction
    de conquête de Player.
    Les villes doivent être ordonnables, car on doit pouvoir définir une priorité parmi
    les merge/shatter.
    Par exemple, pour Player red, on merge les villes en commençant par le bas et la gauche.
    Les villes qui sont toutes sur la même diagonale ont leur premier index de priorité égal.
    Le deuxième index permet d'ordonner les villes qui sont sur la même diagonale.

    Pour les moyennes et les grosses villes, qui s'étendent sur plusieurs cases, on prend comme
    case de référence celle qui est le plus en arrière possible.
    (Ça correspond aux coordonnées qu'on a renvoyées dans les 2 premiers elems du tuple).
    Par exemple, pour Player red, qui part du coin inférieur gauche de l'aire de jeu,
    la case la plus derrière pour une de ses towns est le coin inférieur gauche de la town.
    """
    x_behind = town.x_left
    y_behind = town.y_up
    return (x_behind, y_behind, (x_behind + y_behind, y_behind))


def get_town_infos_left_down(town):
    x_behind = town.x_left + town.size - 1
    y_behind = town.y_up
    return (x_behind, y_behind, (-x_behind + y_behind, y_behind))


def get_town_infos_right_up(town):
    x_behind = town.x_left
    y_behind = town.y_up + town.size - 1
    return (x_behind, y_behind, (x_behind - y_behind, -y_behind))


def get_town_infos_left_up(town):
    x_behind = town.x_left + town.size - 1
    y_behind = town.y_up + town.size - 1
    return (x_behind, y_behind, (-x_behind - y_behind, -y_behind))


# C'est dégueu d'avoir besoin d'une fonction comme ça.
# Faut vraiment que je fasse des librairies génériques de manipulation de tile et d'arrays.
def tile_from_coords(array_gamobjs, tile):
    return array_gamobjs[tile.y + OFFSET_INTERFACE_Y][tile.x + OFFSET_INTERFACE_X]


# Configuration de tout un tas de variable de Player, en fonction de ses directions de conquête.
# Clé : 2 booléens (rightward, downward), définissant les directions de conquête.
# Valeur : un tuple de 8 éléments :
# - La fonction get_town_infos, permettant de trier les towns en partant du point de départ de Player.
# - La fonction is_behind, permettant de savoir si une tile est derrière une autre,
#   dans la direction de conquête de Player
# - directions forward en diagonale, forward horizontale, forward verticale.
# - directions backward en diagonale, backward horizontale, backward verticale.
# On a besoin de la dernière clé avec les None pour la bionature.
CONFIG_FROM_WARDNESSES = {
    (True, True): (get_town_infos_right_down, is_behind_right_down, 3, 2, 4, 7, 6, 0),
    (True, False): (get_town_infos_right_up, is_behind_right_up, 1, 2, 0, 5, 6, 4),
    (False, True): (get_town_infos_left_down, is_behind_left_down, 5, 6, 4, 1, 2, 0),
    (False, False): (get_town_infos_left_up, is_behind_left_up, 7, 6, 0, 3, 2, 4),
    (None, None): (None, None, None, None, None, None, None, None),
}

# Les différents états possibles lorsqu'on effectue des merge/shatter de town.
# Voir fonction Player.process_town_merging.
TOWN_MERGE_STATE_UNSORTED = 0
TOWN_MERGE_STATE_UNCHECKED = 1
TOWN_MERGE_STATE_STABLE = 2

# Utilisé lorsque Player déclenche une "line conquest".
# Il s'agit du nombre de tours de jeu pour le temps de pause après construction d'une route.
DELAY_ROADIFY = 10


class PlayerHandler:
    """
    Gère les pixels et les towns d'un Player (rouge, bleu ou bionature).
    """

    def __init__(
        self,
        player_id,
        w,
        h,
        color,
        game_master,
        rightward,
        downward,
        is_bionature=False,
    ):
        if is_bionature:
            rightward = None
            downward = None
        else:
            if rightward is None or downward is None:
                raise Exception("Players humains, il faut rightward et downward.")

        self.player_id = player_id
        self.w = w
        self.h = h
        self.color = color
        # Le game master qui gère ce Player, et qui gère aussi tout le jeu.
        self.game_master = game_master
        self.rightward = rightward
        self.downward = downward
        self.is_bionature = is_bionature
        self.gamobj_magnet = self.color + "_magnet"
        self.gamobj_go_back = self.color + "_go_back"
        (
            self.get_town_infos,
            self.is_behind,
            self.dir_forw_diag,
            self.dir_forw_hori,
            self.dir_forw_verti,
            self.dir_back_diag,
            self.dir_back_hori,
            self.dir_back_verti,
        ) = CONFIG_FROM_WARDNESSES[(self.rightward, self.downward)]

        # Liste de tiles contrôlées par Player. Pour contrôler une tile, il faut avoir au moins un pixel dessus,
        # ou bien une town.
        self._controlled_tiles = []
        # Liste de tiles contrôlées par Player, et comportant une route.
        # On a besoin de cette liste pour accélérer les traitements.
        self._controlled_roads = []
        # Liste de tiles aussi. "bare tile" = une tile qui n'a pas de route.
        # On a besoin de cette liste pour accélérer les traitements aussi. En général, on a plein
        # de bare tiles avec une seule unité dessus. Elles ne demandent aucune gestion.
        # Les bare tiles ayant plusieurs unités sont moins nombreuses, mais demandent une gestion.
        # On doit bouger les unités supplémentaires, vers le forward ou le backward.
        # C'est donc avantageux de référencer ces tiles particulières, pour les gérer plus vite,
        # plutôt que de parcourir toute les controlled_tiles à chaque fois.
        self.controlled_bare_tiles_with_many_units = []
        self.towns = []
        # Les towns ayant au moins une tile non-town adjacente. C'est à dire qu'elle peuvent
        # générer des unités et les placer autour d'elles.
        self.active_towns = []
        self.total_units = 0
        # La tile sur laquelle se trouve une ville en construction.
        # On ne peut construire qu'une seule ville à la fois.
        self.tile_building_town = None
        # Nombre de tours écoulés depuis le début de la construction de la ville en cours.
        self.building_time = 0
        # La tile vers laquelle toutes les unités doivent aller.
        # Lorsqu'il n'y a pas de magnet, les unités doivent à-peu-près se répartir sur les routes.
        self.tile_magnet = None
        # La tile qui fait le backward conquest, s'il y en a une.
        # C'est forcément une tile de town. Et c'est la tile de town la plus en arrière possible
        # (dans le cas des towns ayant une size supérieure à 1)
        self.tile_go_backward = None
        # Les unités qui font un backward conquest sont limitées dans un bounding rect.
        # Plus la town ayant lancé la conquest est grande, plus le bounding rect est grand.
        self.bounding_rect_go_back = None
        # Nombre d'unités que la town doit envoyer en backward conquest, tous les 4 tours de jeu.
        # Plus la town est grosse, plus elle en envoie d'un seul coup.
        self.nb_unit_to_send_backward = 0
        # Pour les 3 variables suivantes, voir fonction Player.process_town_merging.
        self.town_merge_state = TOWN_MERGE_STATE_STABLE
        self.towns_to_merge = None
        self.town_to_shatter = None
        # Nombre de points accumulés, pour la génération des unités par terrain contrôlés.
        self.unit_gen_tile = 0
        # Nombre de tours consécutifs durant lesquels on a tenté de placer une unité générée,
        # et qu'on n'a pas pu parce qu'on n'a pas trouvé de tile adéquate.
        self.unit_gen_tile_nb_turn_fail = 0
        # Les 4 variables suivantes servent à la gestion des line conquests.
        # Voir fonction Player.process_line_conquest.
        self.tiles_to_roadify = []
        self.tile_to_townify = None
        self.delay_roadify = 0
        self.is_roadify_horiz = False
        # Ordre de priorité des directions de déplacement, pour les pixels qui sont sur des bare tiles.
        self.bare_tile_move_priorities_from_x_parity = (
            (self.dir_forw_diag, self.dir_forw_hori, self.dir_forw_verti),
            (self.dir_forw_diag, self.dir_forw_verti, self.dir_forw_hori),
        )
        # En mode "dodo", si on ne parvient pas à construire une ville au bout de 50 tours,
        # c'est qu'il y a eu un problème. On choisit un autre emplacement.
        self.nb_turn_auto_build_town = 0
        # Ça y'en a besoin, mais on ne peut que l'initialiser après. Car au moment où on crée l'objet PlayerHandler,
        # l'objet PlayerInterface n'existe pas encore. On a besoin d'une référence dans les deux sens.
        self.player_interface = None

    def __str__(self):
        return "player_%s" % self.player_id

    def set_player_interface(self, player_interface):
        self.player_interface = player_interface

    def add_controlled_tile(self, tile):
        # Pas besoin de trier ces tiles dans le sens dans lequel on les résout.
        # Au début, je croyais, mais en fait non. Avec les histoires de modulo
        # (à chaque tour, on ne gère qu'une tile sur deux, ou une sur quatre),
        # ça se gère bien tout seul.
        self._controlled_tiles.append(tile)

    def remove_controlled_tile(self, tile):
        self._controlled_tiles.remove(tile)

    def add_towns(self, towns):
        """
        Référence une ou plusieurs towns qui viennent d'être construite.
        On ne peut construire qu'une town à la fois. Mais lorsqu'on fait un shatter,
        ça génère plusieurs petites towns d'un seul coup.
        """
        self.towns += towns
        self.update_active_towns()
        # Une nouvelle town vient d'être ajoutée. Il y aura peut-être besoin d'une réorganisation.
        # Il faut donc refaire un cycle de vérification des merge/shatter de towns.
        self.town_merge_state = TOWN_MERGE_STATE_UNSORTED

    def remove_towns(self, towns):
        """
        Supprime une town référencée.
        Dans le jeu, on ne détruit jamais les towns. Mais on les merge.
        Un merge provoque une suppression de plusieurs towns,
        que l'on remplace par une town plus grande.
        """
        for town in towns:
            self.towns.remove(town)
        self.update_active_towns()
        # Il faut refaire un cycle de vérification des merge/shatter de towns.
        self.town_merge_state = TOWN_MERGE_STATE_UNSORTED

    def add_controlled_road(self, tile):
        self._controlled_roads.append(tile)

    def remove_controlled_road(self, tile):
        self._controlled_roads.remove(tile)

    def move_unit_without_check(self, tile_source, tile_dest, qty=1):
        """
        Cette fonction ne doit être utilisée que quand on est sûr de ce qu'on fait.
        Elle permet de déplacer des unités d'une tile vers une autre.
        Toutes les conditions suivantes doivent être réunies :
         - tile_source et tile_dest sont toutes les deux contrôlées par Player.
         - il y a au moins une route sur tile_source et au moins une route sur tile_dest.
         - les unités déplacées ne vont pas supprimer toutes les unités de tile_source
         - les unités déplacés ne vont pas aboutir à avoir plus de 16 unités sur tile_dest.

        Le déplacement d'unités est très rapide, car on ne fait aucun check.
        Pas de mise à jour des listes de tiles
        (_controlled_tiles, _controlled_roads, controlled_bare_tiles_with_many_units).
        Pas de vérification des owners de tile_source et tile_dest.

        On utilise cette fonction pour équilibrer les unités entre deux routes adjacentes,
        ou entre deux tiles d'un même suburb, contrôlées par Player.
        """
        tile_source.nb_unit -= qty
        tile_dest.nb_unit += qty
        tile_source.update_linked_gamobjs()
        tile_dest.update_linked_gamobjs()

    def cancel_all_orders(self):
        """
        Supprime tous les ordres en cours que Player a pu envoyer :
        les constructions de routes et ville d'une line conquest, magnétisation,
        backward conquest, etc.
        """
        self.tile_magnet = None
        self.tile_go_backward = None
        self.bounding_rect_go_back = None
        self.nb_unit_to_send_backward = 0
        self.tiles_to_roadify = []
        self.tile_to_townify = None

    def _spread_units_on_one_road(self, tile):
        """
        Répartit les unités qui d'une tile, vers les tiles adjacentes.
        On sort au maximum une seule unité par tile adjacente.
        On sort une unité lorsque les conditions suivantes sont respectées :
         - la tile de départ et la tile adjacente sont connectées par une route.
         - les deux tiles sont contrôlées par Player.
         - la tile a plus de deux unités dessus. Car on considère qu'il faut toujours
           au moins deux unités sur une road pour en garder le contrôle.
           (en vrai, on contrôle toujours la tile si on a une seule unité dessus,
           mais on peut pas la bouger).
         - il y a plus de une unité de plus entre la tile de départ et la tile adjacente.
           Exemple : 7 unités sur la tile de départ, 5 sur la tile adjacente -> on en déplace une.
           mais avec 6 unités sur la tile de départ, 5 sur la tile adjacente -> on déplace pas.
           C'est ce qui fait qu'au fur et à mesure qu'on s'éloigne d'une ville, on a en général
           de moins en moins d'unités.

        Pour gérer tout ça, la fonction utilise la variable Tile.road_adjacencies_same_player.
        Cette variable est mise à jour lors des déplacements d'unités.
        Voir la classe Tile.
        """
        nb_unit_source = tile.nb_unit
        # Le slice "[::2]" permet d'itérer sur les 4 cases autour, et non pas sur les 8.
        # On ne fait pas les diagonales, car il n'existe pas de routes diagonales.
        for adj_tile, adj_connexion_type in zip(
            tile.adjacencies[::2], tile.road_adjacencies_same_player[::2]
        ):
            if (
                adj_tile is not None
                and adj_connexion_type == 1
                and nb_unit_source > 2
                and nb_unit_source - adj_tile.nb_unit > 1
            ):
                self.move_unit_without_check(tile, adj_tile)
                nb_unit_source = tile.nb_unit

    def _move_units_to_magnet(self, tile):
        """
        Déplace une unité d'une tile ayant une route, vers une tile adjacente,
        dans le cas ou Player a une magnétisation.
        Ça ne fait pas du vrai pathfinding, mais osef. L'unité est déplacée vers une tile
        adjacente (horizontale ou verticale), dans la direction de la tile magnetisée.
        Et tant pis si à la fin ça mène vers un cul-de-sac ou vers une tile qui ne permet pas
        d'atteindre la tile magnetisée. (Player a qu'à gérer son réseau routier correctement !)
        La tile source et la tile dest doivent être connectées par une route.
        On permet des déplacements vers des tiles non contrôlées, ou même des tiles appartenant
        à l'autre Player. Dans ce dernier cas, l'unité sera détruite.
        Ça permet d'éliminer des unités adverses pour gagner du terrain.

        On ne déplace pas d'unité si la tile en possède 2 ou moins. En accord avec le principe
        qu'il faut laisser 2 unités sur une tile de road avant de pouvoir en déplacer.
        """
        nb_unit_source = tile.nb_unit
        if nb_unit_source <= 2:
            return
        dirs = directions_from_pos(tile, self.tile_magnet)
        # Cette variable contiendra toutes les directions possibles vers lesquelles on peut déplacer une unité.
        # C'est à dire 0, 1 ou 2 directions possibles.
        # Si il y en a 2, on en sélectionnera une seule, au hasard.
        possible_tiles_dest = []
        for direc in dirs:
            tile_dest = tile.adjacencies[direc]
            if tile_dest is not None:
                if tile_dest.player_owner == self and tile_dest.nb_unit >= 16:
                    # La tile de destination est déjà pleine au max. Pas de déplacement.
                    continue
                if not tile.is_road_connected(direc, tile_dest):
                    # Pas de connexion de route. Pas de déplacement.
                    continue
                if (
                    tile.suburb_owner is not None
                    and tile.suburb_owner == tile_dest.suburb_owner
                ):
                    # Là, ce serait un déplacement d'unité entre deux tiles d'un même suburb.
                    # Ça sert à rien, le suburb gère lui-même ses répartitions d'unités.
                    continue
                # Voilà. On a fait toutes les vérifs qu'il faut. On pourra déplacer dans cette direction.
                possible_tiles_dest.append(tile_dest)

        if not possible_tiles_dest:
            return

        if len(possible_tiles_dest) == 1:
            selected_tile_dest = possible_tiles_dest[0]
        else:
            selected_index = int(next(pseudo_random_boolean))
            selected_tile_dest = possible_tiles_dest[selected_index]

        # Soit c'est un déplacement sans aucun check, car les deux tiles sont contrôlés
        # par Player. Soit c'est un déplacement avec tous les check nécessaires.
        if selected_tile_dest.player_owner == self:
            self.move_unit_without_check(tile, selected_tile_dest)
        else:
            tile.remove_unit()
            selected_tile_dest.add_unit(self)

    def can_generate_unit(self):
        limit_total_units = len(self._controlled_tiles) * RATIO_CONTROLLED_TILE_FOR_GEN
        # Dans tous les cas, on autorise à générer au moins 16 unités, même si Player
        # ne contrôle que très peu de terrain. Sinon, ce n'est même pas possible de construire
        # une autre ville pour étendre son territoire.
        limit_total_units = max(16, limit_total_units)
        return self.total_units < limit_total_units

    def move_units_on_roads(self, turn_index):
        """
        Gestion de tous les déplacements d'unités qui sont sur des routes,
        en tenant compte de l'éventuelle magnétisation.

        Pour toutes les tiles ayant des routes et contrôlées par Player,
        on en parcourt une sur deux. Ce "un sur deux" est géré d'une manière spécifique.
        L'aire de jeu est considéré comme ça :
        ABABAB...
        BABABA...
        ABABAB...
        BABABA...
        ...
        La tile en haut à gauche est "A", celle à droite est "B", celle encore à droite est "B",
        et ainsi de suite.
        Sur la ligne en-dessous, c'est pareil, sauf que la tile tout à gauche est "B".

        Cette fonction gère, soit toutes les tiles "A", soit toutes les "B".
        Le choix est déterminé par le paramètre turn_index (numéro du tour de jeu actuel).
        Si turn_index est pair, on gère tous les "A", sinon, tous les "B".

        Ça permet de diminuer les traitements à faire à chaque tour, et surtout, ça permet
        de montrer les pixels qui se déplacent progressivement. Si on gère toutes les tiles
        à chaque tour, on prend le risque d'avoir une unité qui se déplace tout le long
        d'une route. Ça donne l'impression qu'elle s'est téléportée. C'est moche.

        Si Player est en train de construire une ville, on ne gère pas la tile sur laquelle
        a lieu la construction. Cette tile ne déplace pas ses unités ailleurs,
        ni en répartition, ni en magnet.
        Sinon, on prendrait le risque d'enlever les 16 unités de la tile sur laquelle
        se construit la ville.
        """
        if self.tile_magnet is None:
            function_move = self._spread_units_on_one_road
        else:
            function_move = self._move_units_to_magnet
        select_tile = turn_index & 1

        for tile in self._controlled_roads:
            # La tile qui construit une ville ne transfère pas ses unités aux autres.
            # Et on fait une tile sur deux, répartie dans l'arène.
            if (tile.x + tile.y) & 1 == select_tile and not tile.town_building_step:
                function_move(tile)

    def move_magnetized_units_on_suburb(self):
        """
        Gère les déplacement d'unités interne au suburb dans lequel se trouve la tile magnetisée.
        """
        if self.tile_magnet is None:
            return
        if self.tile_magnet.suburb_owner is None:
            return
        if self.tile_magnet.town is not None:
            # Il y a une magnétisation, et elle est dans un suburb. Mais la tile magnetisée est
            # sur une town. Dans ce cas, on ne fait aucun déplacement dans le suburb
            # lui-même, parce qu'on ne peut pas placer des unités sur une town.
            return
        magnetized_suburb = self.tile_magnet.suburb_owner
        # Les déplacements internes à un suburb doivent être assez rapides. Pour toutes les tiles
        # du suburb pour lesquelles on peut prélever une unité, on le fait et on la place
        # directement sur la tile magnetisée. Les tiles prélevables sont celles contrôlées par
        # Player, et qui comportent plus que deux unités.
        for suburb_tile in magnetized_suburb.real_suburb_tiles:
            if self.tile_magnet.player_owner == self and self.tile_magnet.nb_unit >= 16:
                # La tile magnetisée est déjà pleine au max des unités de Player.
                # Il n'y a plus besoin de déplacer d'unités.
                return
            if suburb_tile.player_owner == self and suburb_tile.nb_unit > 2:
                # Déplacement d'une unité vers la tile magnetisée.
                # On ne fait pas de move_unit_without_check, car les deux tiles ne
                # sont pas forcément adjacentes. Cela dit ça marcherait peut-être,
                # ça n'a pas été testé.
                suburb_tile.remove_unit()
                self.tile_magnet.add_unit(self)

    def process_town_building(self):
        """
        Gère la town en cours de construction, s'il y en a une.
        Rappel : Player ne peut construire qu'une town à la fois.
        """
        if self.tile_building_town is None:
            return
        self.building_time += 1
        if self.building_time >= NB_TURNS_TOWN_BUILDING_TIMEOUT:
            # La construction de la ville a pris trop de temps.
            # Parce que les unités qui sont dessus n'ont pas arrêté de se faire éliminer.
            # Tant pis, on arrête la construction.
            self.tile_building_town.cancel_town_building()
            self.building_time = 0
            self.tile_building_town = None
            return

        if self.tile_building_town.nb_unit >= 16:
            # Pas de problème, il y a toujours 16 unités dans la ville en construction.
            # On avance la construction de 1.
            self.tile_building_town.advance_town_building()
            if self.tile_building_town.town_building_step >= NB_TURNS_TOWN_BUILDING:
                # On a réussi à faire avancer la construction jusqu'au bout.
                # On peut poser la ville ! La fonction build_town s'occupe de tout ça.
                self.tile_building_town.build_town()
                # Arrêt de la construction en cours, puisqu'on a fini.
                # et démagnetisation de la tile.
                self.building_time = 0
                if self.tile_magnet == self.tile_building_town:
                    self.tile_magnet = None
                self.tile_building_town = None
            return

    def update_active_towns(self):
        """
        Mise à jour des towns actives.
        À faire après une construction, un merge ou un shatter.
        """
        if self.player_interface is not None:
            # On prévient l'interface de jeu de ce Player que la liste des town active
            # va changer. C'est nécessaire, car l'interface devra éventuellement mettre à
            # jour la town sélectionnée par Player. Et elle doit aussi retrier les towns,
            # selon l'ordre spécifique à l'interface. (De gauche à droite et de haut en bas).
            self.player_interface.dirtify_town_list()
        self.active_towns = [town for town in self.towns if town.is_active]

    def process_unit_generation_town(self):
        """
        Effectue la génération des unités pour toutes les towns actives.
        """
        for town in self.active_towns:
            town.process_unit_generation()

    def move_units_on_bare_tiles(self, turn_index):
        """
        Gère les déplacements des unités qui sont sur des bare tiles.
        Seule les bare tiles ayant plus de 1 unité font des déplacements. Sinon ce serait
        un déplacement qui déclencherait la perte de contrôle d'une tile, et c'est un peu idiot.
        On connait directement les tiles concernées, grâce à la liste
        self.controlled_bare_tiles_with_many_units, mise à jour à chaque déplacement d'unité.

        À chaque tour, on gère une tile sur 4, selon presque le même principe que dans la fonction
        move_units_on_roads (avec les "ABAB...").
        Mais pour cette fonction, on fait comme ça :
        ABCDABCDABCD...
        CDABCDABCDAB...
        ABCDABCDABCD...
        CDABCDABCDAB...
        ...
        Si on avait géré avec juste les ABAB, ça aurait fait des diagonales de "A"
        et des diagonales de "B". Ce qui est embêtant, car justement les unités se
        déplacent en diagonales ! On aurait eu des grands déplacements qui auraient
        ressemblé à de la téléportation.
        """
        select_tile = turn_index & 3
        for tile in self.controlled_bare_tiles_with_many_units:
            # Le y est multiplié par 2, pour pouvoir faire le "ABCD / CDAB" décrit en docstring.
            if (tile.x + tile.y * 2) & 3 == select_tile:
                self.move_units_on_one_bare_tile(tile)

    def move_units_on_one_bare_tile(self, tile):
        """
        Gère les déplacements des unités sur une seule bare tile.

        Si la tile est dans la zone de "backward conquest", les unités sont déplacées en diagonale,
        vers l'arrière (par rapport à la direction de conquête de Player). On permet les
        déplacements sur des tiles non contrôlées ou contrôlées par d'autres.
        Les unités s'élimineront, c'est le but de la conquête.
        On déplacera ainsi progressivement les unités vers l'arrière, jusqu'à arriver à la limite
        de la zone, ou bien jusqu'à une tile avec route.
        On attend d'avoir au moins 4 unités sur la tile, et on en déplace 3 d'un coup.
         - une en diagonale arrière.
         - une en horizontal arrière.
         - une en vertical arrière.

        Si la tile est en dehors de backward conquest, on déplace les unités vers l'avant,
        mais uniquement sur des tiles contrôlées.
        On ne déplace qu'une seule unité à chaque fois.
        On prend le premier déplacement possible parmi les 3 dispo :
        diagonal avant, horizontal avant, vertical avant.
        Juste pour ajouter un peu de variété, on alterne l'ordre horizontal/vertical dans ces
        déplacements possibles, en fonction de x (abscisse).
        Ce comportement devrait ramener progressivement les unités vers une route
        (en général, à proximité de la town qui a précédemment lancé une backward conquest).
        Il est possible que les unités se déplaçant de cette manière se retrouvent coincées
        dans un cul de sac. C'est le problème de Player, qui n'a qu'à bien gérer ses terrains.
        """
        check_go_back = self.bounding_rect_go_back is not None
        if check_go_back and pos_in_bounding_rect(
            self.bounding_rect_go_back, tile.x, tile.y
        ):
            if tile.nb_unit <= 3:
                return
            # Backward, en mode conquest. On envoie 3 unités dans 3 directions différentes.
            for direction in (
                self.dir_back_diag,
                self.dir_back_hori,
                self.dir_back_verti,
            ):
                tile_dest = tile.adjacencies[direction]
                # Les tests obligatoires avant de déplacer une unité :
                # il faut que la tile existe, que y'ait pas de town dessus,
                # et qu'elle ne soit pas déjà pleine avec les unités de Player.
                if (
                    tile_dest is not None
                    and tile_dest.town is None
                    and (tile_dest.player_owner != self or tile_dest.nb_unit < 16)
                ):
                    tile.remove_unit()
                    tile_dest.add_unit(self)
        else:
            # Forward, en mode move. On déplace une seule unité, dans la 1ère direction acceptable.
            possible_direcs = self.bare_tile_move_priorities_from_x_parity[tile.x & 1]
            for direction in possible_direcs:
                tile_dest = tile.adjacencies[direction]
                # Même genre de tests obligatoires que ci-dessus, mais avec une contrainte en plus.
                # On ne se déplace pas sur vers tile qu'on ne contrôle pas. Car c'est un mouvement,
                # et pas une conquête.
                if (
                    tile_dest is not None
                    and tile_dest.town is None
                    and tile_dest.player_owner == self
                    and tile_dest.nb_unit < 16
                ):
                    # On ne peut pas utiliser la fonction move_unit_without_check,
                    # parce qu'on n'est pas sur des tiles de routes. Et que justement, ces
                    # déplacements changent le contenu de controlled_bare_tiles_with_many_units
                    tile.remove_unit()
                    tile_dest.add_unit(self)
                    return

    def set_town_backward_conquest(self, town):
        """
        Déclenche une backward conquest sur une town. Cette fonction met à jour
        self.tile_go_backward et self.bounding_rect_go_back.
        Cette fonction magnétise également la town qui backward conquest (self.tile_magnet).
        """
        self.tile_magnet = None
        self.tile_go_backward = None
        if town is None:
            return
        self.nb_unit_to_send_backward = NB_UNIT_TO_SENT_BACKWARD_CONQUEST[town.size]
        # Définition de la tile qui fait le backward. Ça correspond à la town.
        # Pour les towns ayant size > 1, on prend la tile la plus derrière
        # (par rapport à la direction de conquête).
        self.tile_go_backward = town.tile_go_backward_diag
        if self.tile_go_backward.adjacencies[self.dir_back_diag] is None:
            # On essaie de backwarder avec une town qui est sur un bord arrière de l'aire de jeu,
            # ça sert à rien. On laisse tomber.
            return

        # Détermination de la zone de backward conquest (self.bounding_rect_go_back).
        # C'est un carré, dont l'un des coins est tile_go_backward,
        # et l'autre coin se trouve "en arrière", à une distance prédéfinie.
        cur_tile = self.tile_go_backward
        for _ in range(DIST_BACKWARD_CONQUEST[town.size]):
            # On recule cur_tile en diagonale, de la distance nécessaire.
            # Mais si on rencontre un bord de l'aire de jeu, on s'arrête avant.
            # C'est un peu pourri, car on aurait pu faire "glisser" cur_tile
            # sur le bord, horizontalement ou verticalement. Et on le fait pas. Tant pis !
            # Cela dit, qui s'amuse à faire des backward conquest sur les bords ?
            if cur_tile.adjacencies[self.dir_back_diag] is None:
                break
            else:
                cur_tile = cur_tile.adjacencies[self.dir_back_diag]

        # Création du rectangle (je dirais même plus : du carré).
        tile_bounding_rect_opposite = cur_tile
        rect_xs = sorted([self.tile_go_backward.x, tile_bounding_rect_opposite.x])
        rect_ys = sorted([self.tile_go_backward.y, tile_bounding_rect_opposite.y])
        self.bounding_rect_go_back = (
            rect_xs[0],
            rect_ys[0],
            rect_xs[1] + 1,
            rect_ys[1] + 1,
        )
        self.tile_magnet = self.tile_go_backward

    def process_backward_conquest(self, turn_index):
        """
        Gère l'envoi d'unité pour la tile de town qui fait le backward conquest.
        La town elle-même n'a pas d'unité. Elle va piocher dans son suburb.

        On envoit une ou plusieurs unités tous les 4 tours de jeu, selon le param turn_index.
        """
        if not self.bounding_rect_go_back:
            return
        tile_dest = self.tile_go_backward.adjacencies[self.dir_back_diag]
        if tile_dest.town is not None:
            return
        select_tile = turn_index & 3
        # Ici, pas besoin de y*2 comme pour la fonction move_units_on_bare_tiles.
        # Les town ne sont pas tracées sur des diagonales.
        # On fait comme on veut, du coup on fait au plus simple.
        if (self.tile_go_backward.x + self.tile_go_backward.y) & 3 != select_tile:
            return
        if tile_dest.player_owner == self and tile_dest.nb_unit >= 16:
            return
        if self.tile_go_backward.suburb_owner is None:
            raise Exception("tile_go_back town sans Suburb. Not supposed to happen.")
        # Arrivé ici, on a fait tous les checks nécessaires.
        # C'est le bon tour de jeu et la tile de destination peut accueillir le pixel.
        # Il n'y a plus qu'à trouver des pixels consentants dans le suburb et les envoyer !
        nb_unit_sent = 0
        for tile_src in self.tile_go_backward.suburb_owner.real_suburb_tiles:
            if tile_src.player_owner == self and tile_src.nb_unit >= 2:
                tile_src.remove_unit()
                nb_unit_sent += 1
                if nb_unit_sent == self.nb_unit_to_send_backward:
                    break
        tile_dest.add_unit(self, nb_unit_sent)

    def merge_town(self, towns_to_remove, size_new_town):
        """
        Fusionne une town.
        Supprime les towns de la liste towns_to_remove, et crée à la place une nouvelle town
        ayant la taille de size_new_town.
        Il n'y a pas de check de cohérence entre les towns supprimées et celle créée. Il faut
        avoir fait les vérifs avant.

        La fonction met à jour les trucs qu'il faut (lien de tile vers town, etc), mais elle
        ne fait rien concernant les suburbs, car il n'y a rien à faire.
        Un merge ou un shatter de town n'ont aucune influence sur la façon dont sont organisés
        les suburbs. Car ça ne change rien au niveau des tiles. Les tiles ayant une town en ont
        toujours une, les tiles n'en ayant pas n'en ont toujours pas.

        La nouvelle town récupère les points de génération d'unités de toutes les towns supprimées.
        """
        x_new_town = []
        y_new_town = []
        unit_gen_points = 0
        # Le coin supérieur gauche de la nouvelle town correspondra au coin supérieur gauche
        # de la town supprimée qui est le plus en haut à gauche. Si les params sont cohérents,
        # la nouvelle town sera créée au bon endroit.
        for town in towns_to_remove:
            x_new_town.append(town.x_left)
            y_new_town.append(town.y_up)
            unit_gen_points += town.unit_gen_points
        self.remove_towns(towns_to_remove)
        x_new_town = min(x_new_town)
        y_new_town = min(y_new_town)
        new_town = Town(
            x_new_town, y_new_town, size_new_town, self, self.game_master, False
        )
        new_town.unit_gen_points = unit_gen_points
        self.add_towns([new_town])
        # Mise à jour des liens vers les towns, qui sont dans les tiles concernées.
        for tile in new_town.tiles_position:
            tile.town = new_town
            tile.update_linked_gamobjs()
        # Maintenant que tout a été bien fini (suppressions et ajouts de town),
        # on fait un dernier petit dirtify, pour prévenir l'interface que faut refaire
        # une dernière fois les vérifs liées à la town sélectionnée.
        self.player_interface.dirtify_town_list()

    def shatter_town(self, town_to_shatter, size_new_town):
        """
        Le nom de la fonction ressemble à Chatterton. Lolilol !

        Détruit une town et crée 4 towns plus petite à la place.
        Le param size_new_town doit être égal à la taille de la town à supprimer,
        divisée par deux. Sinon ça donnerait n'importe quoi.

        Les points de génération de la town détruite sont divisés en 4
        et donnés à chaque nouvelle town. Il peut y avoir de la perte, car on fait
        une divison entière. C'est comme ça. La réurbanisation, ça coûte des ressources.

        Comme pour merge_town, on ne fait rien dans les suburbs, car un shatter ne modifie
        pas l'organisation des suburbs.
        """
        unit_gen_points_new_towns = town_to_shatter.unit_gen_points // 4
        x_left = town_to_shatter.x_left
        y_up = town_to_shatter.y_up
        self.remove_towns([town_to_shatter])
        coord_new_towns = (
            (x_left, y_up),
            (x_left + size_new_town, y_up),
            (x_left, y_up + size_new_town),
            (x_left + size_new_town, y_up + size_new_town),
        )
        new_towns = []
        for x, y in coord_new_towns:
            new_town = Town(x, y, size_new_town, self, self.game_master, False)
            new_town.unit_gen_points = unit_gen_points_new_towns
            for tile in new_town.tiles_position:
                tile.town = new_town
                tile.update_linked_gamobjs()
            new_towns.append(new_town)
        self.add_towns(new_towns)
        # Maintenant que tout a été bien fini (suppressions et ajouts de town),
        # on fait un dernier petit dirtify, pour prévenir l'interface que faut refaire
        # une dernière fois les vérifs liées à la town sélectionnée.
        self.player_interface.dirtify_town_list()

    def check_town_size_1_merge(self, cur_town):
        """
        Vérifie si il faut merger 4 towns de size 1, ou bien si il faut shatterer
        une town (de n'importe quelle taille) afin de pouvoir ensuite merger
        4 towns de size 1 à un emplacement meilleur.

        Renvoie False si il n'y a rien à faire.
        Renvoie True si on a retenu quelque chose à faire, c'est à dire si on a
        modifié self.town_to_shatter ou self.towns_to_merge.
        """
        tile_of_town = cur_town.tiles_position[0]
        tiles_aside = [
            tile_of_town.adjacencies[self.dir_forw_hori],
            tile_of_town.adjacencies[self.dir_forw_verti],
            tile_of_town.adjacencies[self.dir_forw_diag],
        ]
        if None in tiles_aside:
            # La town est sur un bord de l'aire de jeu. Pas de merge possible.
            return False
        towns_aside = [tile.town for tile in tiles_aside]
        if None in towns_aside:
            # Il n'y a pas de carré de 2x2 towns.
            return False
        if any((town.player_owner != self for town in towns_aside)):
            # Il y a un carré de towns, mais certaines towns appartiennent à l'autre Player.
            return False

        can_modify = True
        potential_towns_to_shatter = []
        for town in towns_aside:
            if town.size != 1:
                # Dans le carré de 2x2 towns, certaines ne sont pas des petites towns
                # de taille 1.
                if cur_town.sorting_key < town.sorting_key:
                    # On a trouvé dans ce carré une grosse town, qui est moins prioritaire
                    # que la town courante au niveau des merges.
                    # Il faudra donc shatterer cette town.
                    potential_towns_to_shatter.append(town)
                else:
                    # On a trouvé dans ce carré une grosse town, qui est plus prioritaire
                    # au niveau des merges. On ne doit pas toucher à cette grosse town.
                    # Donc on ne peut rien merger de plus.
                    can_modify = False

        if not can_modify:
            return False

        if potential_towns_to_shatter:
            # Il va falloir shatterer une ou plusieurs towns. On ne retient que la première.
            # On retrouvera les éventuelles autres towns à shatterer au prochain tour de
            # vérification. Ça permet de prendre en compte en direct les éventuelles
            # nouvelles construction de towns, et ça permet aussi de montrer dans le jeu
            # que les réorganisations se font progressivement.
            self.town_to_shatter = potential_towns_to_shatter[0]
            return True
        else:
            # Si on est arrivé jusqu'ici, on a fait toutes les vérifs nécessaires.
            # On est maintenant sûr qu'on peut merger cette town. Youpi !
            # On conserve cette town pour faire le merge au tour suivant.
            self.towns_to_merge = [cur_town] + towns_aside
            return True

    def check_town_size_2_merge(self, cur_town):
        """
        Vérifie si la town passée en paramètre, qui doit avoir une size de 2, peut être fusionnée
        avec 3 autres towns de size 2 bien placée. Si c'est le cas, la variable membre
        self.towns_to_merge sera définie.
        Vérifie aussi si cette town devrait déclencher un shatter d'une town de size 4, pour
        pouvoir refaire un merge à un autre endroit.
        Une town de size 1 peut déclencher un shatter de towns de size 2 et 4.
        Une town de size 2 ne peut déclencher un shatter que pour les towns de size 4.

        Si un carré de 2x2 town de size 1 ne peut être fusionné à cause d'un mauvais placement
        d'une town de size 2, cette fonction n'a pas à le gérer. C'est le shatter dû à des towns
        de size 1 qui le fera.

        On checke que 3 cases. Celles où on est censé avoir le left_up
        des 3 villes avec lesquelles on merge.
        Pour trouver ces 3 cases, on avance 2 fois en forward pour chacune d'elle.
        (forward diag, forward horiz, forward vertic).
        Si, sur l'une de ces 3 cases, on a :
         - une ville de taille 4,
         - avec des modulos de left_up égaux à ceux de cur_town,
         - qui est située plus loin selon le tri par sort_key_xxx,
         - et qu'on a aucune ville de taille 4 située avant selon le tri par sort_key_xxx,
        alors on shatter cette ville de taille 4 qui est située plus loin.
        Si tout ça n'est pas réuni, on shatter rien du tout, car ça risque de tout pourrir.
        """
        tile_of_town = cur_town.tiles_position[0]
        # Récupération des 3 cases que l'on checke : tile_diag_2, tile_forw_hori, tile_forw_verti.
        tile_diag_1 = tile_of_town.adjacencies[self.dir_forw_diag]
        if tile_diag_1 is None:
            return False
        tile_diag_2 = tile_diag_1.adjacencies[self.dir_forw_diag]
        if tile_diag_2 is None:
            return False
        # On n'a pas touché les bords de l'aire de jeu en allant 2 fois en diagonale.
        # On peut maintenant déterminer les 2 autres cases, sans faire de vérif.
        # Car on sait qu'on ne touchera pas les bords en allant 2 fois horizontalement
        # ou 2 fois verticalement.
        tile_forw_hori = tile_of_town.adjacencies[self.dir_forw_hori]
        tile_forw_hori = tile_forw_hori.adjacencies[self.dir_forw_hori]
        tile_forw_verti = tile_of_town.adjacencies[self.dir_forw_verti]
        tile_forw_verti = tile_forw_verti.adjacencies[self.dir_forw_verti]
        tiles_aside = [tile_forw_verti, tile_forw_hori, tile_diag_2]
        # Récupération des 3 towns associées à ces 3 cases.
        # Si on n'a pas 3 towns, ou si l'une d'elle a une taille de 1, pas de merge/shatter possible.
        # On s'en va.
        towns_aside = [tile.town for tile in tiles_aside]
        if None in towns_aside:
            return False
        if 1 in [town.size for town in towns_aside]:
            return False

        x_modu_cur_town = cur_town.x_left % 2
        y_modu_cur_town = cur_town.y_up % 2
        for town in towns_aside:
            if town.x_left % 2 != x_modu_cur_town or town.y_up % 2 != y_modu_cur_town:
                # L'une des towns de taille 2 n'est pas placée au bon endroit
                # par rapport à cur_town. Pas de merge/shatter possible.
                return False
        if any((town.player_owner != self for town in towns_aside)):
            # Tout est bien placé, mais au moins une des towns n'appartient pas à Player.
            return False

        can_modify = True
        potential_towns_to_shatter = []
        for town in towns_aside:
            if town.size == 4:
                if cur_town.sorting_key < town.sorting_key:
                    # Il y a une town de taille 4 qui gêne, et elle est placée après.
                    # On pourra peut-être la shatterer.
                    potential_towns_to_shatter.append(town)
                else:
                    # Il y a une town de taille 4 qui gêne, mais elle est placée avant.
                    # C'est elle qui a la priorité. On ne la shatter pas.
                    # Et donc, pas de merge/shatter possible.
                    # La ville cur_town va rester comme elle est.
                    can_modify = False
        if not can_modify:
            return False

        if potential_towns_to_shatter:
            # Il faudrait shatterer une ou plusieurs towns pour faire un merge ultérieur.
            # Pas besoin de se souvenir de tout ce qu'il faut shatterer.
            # On signale juste la première.
            # Lors d'une prochaine exécution de la fonction process_town_merging, on retrouvera
            # les éventuelles autres towns à shatterer, et on s'en occupera.
            self.town_to_shatter = potential_towns_to_shatter[0]
            return True
        else:
            # Youpi ! On peut faire un merge !
            self.towns_to_merge = [cur_town] + towns_aside
            return True

    def process_town_merging(self):
        """
        Gère tous les merge/shatter des towns. Cette gestion est décomposée en plusieurs
        petites étapes, on en effectue une seule à chaque tour. Ça permet de ne pas faire de
        gros traitements qui ralentirait le jeu, et ça permet aussi de montrer les étapes
        intermédiaires de merge/shatter. On voit petit à petit les villes se réorganiser,
        et je trouve ça cool.

        L'étape en cours est renseignée par les variables membres
        town_merge_state, towns_to_merge et town_to_shatter.

        Ça se passe comme ça :

        town_merge_state == TOWN_MERGE_STATE_STABLE : on a tout vérifié récemment,
        il n'y a rien à faire.
        Dès qu'une nouvelle town est construite par Player, on entame un
        cycle de vérification, avec TOWN_MERGE_STATE_UNSORTED.

        town_merge_state == TOWN_MERGE_STATE_UNSORTED : on trie la liste self.towns, selon l'ordre
        town.sorting_key (un tuple précalculé pour chaque town), qui permet de savoir quelles towns
        doivent être mergées en priorité. (voir fonction get_town_infos_right_down).

        town_merge_state = TOWN_MERGE_STATE_UNCHECKED : on parcourt toutes les towns.
        Dès qu'on en trouve une qui doit être mergée, ou shatterée, on arrête le parcours,
        et on retient ce qu'on a trouvé. Soit self.towns_to_merge devient différent de None,
        soit self.town_to_shatter devient différent de None.
        Si on n'a rien trouvé à faire, town_merge_state prend la valeur TOWN_MERGE_STATE_STABLE,
        et on met la gestion en pause, jusqu'à la prochaine construction de ville,
        où on revérifiera tout.
        À priori, la vérification complète de toutes les villes ne prend pas beaucoup de temps.
        On peut donc se permettre de tout vérifier en un seul tour.

        towns_to_merge is not None : on merge les town qui ont été retenues comme étant à merger.
        Cette action modifie la liste de towns, donc on revient à l'étape TOWN_MERGE_STATE_UNSORTED
        et on refait tout un processus de vérification.

        self.town_to_shatter si not None : on shatter la town retenue comme étant à shatterer,
        puis on revient à l'étape TOWN_MERGE_STATE_UNSORTED pour refaire le processus.

        Cette gestion a la garantie qu'on n'aura jamais de cycle infini de merge/shatter, grâce
        au fait qu'on ait ordonné les villes (avec town.sorting_key).
        Il suffit d'instaurer ces règles :
         - on merge tout ce qu'on peut merger.
         - on shatter une town uniquement si elle empêche un merge, et uniquement si la
           première town du merge empêché se trouve avant la town à shatterer.
        """
        if self.town_merge_state == TOWN_MERGE_STATE_STABLE:
            return

        if self.town_merge_state == TOWN_MERGE_STATE_UNSORTED:
            self.towns.sort(key=lambda town: town.sorting_key)
            self.town_merge_state = TOWN_MERGE_STATE_UNCHECKED
            return

        if self.towns_to_merge:
            self.merge_town(self.towns_to_merge, self.towns_to_merge[0].size * 2)
            self.towns_to_merge = None
            return

        if self.town_to_shatter:
            self.shatter_town(self.town_to_shatter, self.town_to_shatter.size // 2)
            self.town_to_shatter = None
            return

        if self.town_merge_state == TOWN_MERGE_STATE_UNCHECKED:
            for cur_town in self.towns:

                # Vérification des merge/shatter pour les villes ayant une size de 1
                if cur_town.size == 1:
                    if self.check_town_size_1_merge(cur_town):
                        return
                # Vérification des merge/shatter pour les villes ayant une size de 2
                elif cur_town.size == 2:
                    if self.check_town_size_2_merge(cur_town):
                        return

            # On a vérifié toutes les towns, aucun merge ni aucun shatter à faire.
            # On se remet dans l'état stable, et on est en pause.
            self.town_merge_state = TOWN_MERGE_STATE_STABLE

    def process_unit_gen_tile(self):
        """
        Gère la génération des unités produites par la possession de terrain.
        Les unités produites ainsi sont placées au hasard, sur n'importe quelle tile
        contrôlée par Player et pouvant accueillir une unité (une road ou une bare tile).
        Si l'unité atterrit sur une bare tile, elle se déplacera progressivement
        en forward, jusqu'à rejoindre une route (ou pas si le chemin est bloqué,
        mais c'est le problème de Player).

        Le choix de la tile sur laquelle placer l'unité est fait d'abord au hasard.
        Si au bout de 10 tours de jeu, on ne trouve pas de tile réceptrice
        (par exemple, si Player a beaucoup de villes et beaucoup de tiles pleines),
        alors on parcourt toutes les tiles contrôlées par Player et on prend la
        première qui va bien.
        Ça veut dire qu'il peut y avoir un décalage dans la génération des units.
        Elles arrivent plus tard que prévu.
        C'est le problème de Player, qui n'a qu'à mieux gérer son expansion territoriale.
        """
        if self.unit_gen_tile < UNIT_GEN_TILE_POINT_MAX_CUMUL:
            self.unit_gen_tile += len(self._controlled_tiles)
        if self.unit_gen_tile < UNIT_GEN_TILE_POINT_REQUIRED:
            return

        tile_target = None
        if self.unit_gen_tile_nb_turn_fail < 10:
            tile_target = random.choice(self._controlled_tiles)
            if tile_target.town is not None or tile_target.nb_unit >= 16:
                # On ne peut pas ajouter de unit sur la tile choisie.
                # On s'en ira direct, et on retentera sa chance au prochain tour.
                tile_target = None
        else:
            # Ça fait 10 tours de jeu qu'on n'arrive pas à placer la unit générée.
            # On cherche une tile où c'est possible et on prend la première
            # qui va bien. Ça évite de se retrouver à exécuter un random.choice
            # à chaque tour de jeu pour rien.
            for pot_tile_target in self._controlled_tiles:
                if pot_tile_target.town is None and pot_tile_target.nb_unit < 16:
                    tile_target = pot_tile_target
                    break

        if tile_target is None:
            self.unit_gen_tile_nb_turn_fail += 1
        else:
            # Youpi, on a trouvé une tile où poser l'unité à générer.
            # On l'ajoute, on décrémente le compteur de génération
            # et on réinitialise le compteur d'échec de posage d'unité.
            tile_target.add_unit(self)
            self.unit_gen_tile -= UNIT_GEN_TILE_POINT_REQUIRED
            self.unit_gen_tile_nb_turn_fail = 0

    def process_unit_gen_tile_bionature(self, turn_index=0):
        """
        Gère la génération des unités produites par la possession de terrain, dans le cas
        où Player est de type "bionature" (les pixels verts).
        Les unités de bionature peuvent être placées sur une tile déjà contrôlée par la bionature,
        ou sur une tile adjacente si elle n'est contrôlée par personne.

        On permet donc à la bionature de s'étendre progressivement, mais jamais de conquérir
        des tiles occupées par d'autres Player, ni d'éliminer d'autres unités.
        Comme ça, la bionature n'embête pas trop les autres Player,
        tout en ayant quand même des possibilités d'envahissement.

        On choisit d'abord une tile contrôlée par la bionature et pouvant accueillir une unité
        de plus, ensuite on regarde les tiles autour qui sont vides, et on choisi parmi celles-ci.
        Ça fait une probabilité plus grande de choisir une tile vide plutôt qu'une tile déjà
        occupée. Ça fait une bionature qui va avoir tendance à s'étendre, et c'est cool.
        """
        if self.unit_gen_tile < UNIT_GEN_TILE_POINT_MAX_CUMUL:
            self.unit_gen_tile += len(self._controlled_tiles)
        if self.unit_gen_tile >= UNIT_GEN_TILE_POINT_REQUIRED_BIONATURE:
            if not self._controlled_tiles:
                return
            tile_target = random.choice(self._controlled_tiles)
            # Là c'est un peu pourri. Si toutes les tiles de la bionature sont au max,
            # avec 16 pixels, alors on ne peut plus choisir de tile de départ.
            # Donc on ne peut même plus s'étendre sur les autres tiles.
            # On ne gère pas ce cas, car il est très rare, et il se règle tout seul
            # dès qu'on élimine une seule unité de bionature.
            if tile_target.town is not None or tile_target.nb_unit >= 16:
                return
            potential_tiles = [
                tile
                for tile in tile_target.adjacencies
                if tile is not None and tile.player_owner is None and tile.town is None
            ]
            potential_tiles.append(tile_target)
            # On choisit la potential tile avec un faux random à la turn_index.
            # Pas besoin de faire du vrai random pour ça.
            tile_target_final = potential_tiles[turn_index % len(potential_tiles)]
            tile_target_final.add_unit(self)
            self.unit_gen_tile -= UNIT_GEN_TILE_POINT_REQUIRED_BIONATURE

    def process_line_conquest(self):
        """
        Gère les "line conquest", permettant à Player de s'étendre sur l'aire de jeu.
        Une line conquest est gérée par les variables membres suivantes :
         - self.tiles_to_roadify : liste de tiles (censées être disposées sur une ligne),
           sur lesquelles on doit construire des roads.
         - self.is_roadify_horiz : Booléean indiquant s'il faut construire des roads horizontales
           ou verticales.
         - self.tile_to_townify : une tile, censée être au bout de la ligne de roads.
           Il faut construire une ville sur cette tile, après les roads.
           Pour que ça fonctionne bien, il faut que le dernier élément de tiles_to_roadify
           soit égal à tile_to_townify. (On peut aussi avoir tile_to_townify à None, si on ne
           veut pas construire de ville à la fin de la ligne).

        Cette fonction est exécutée à chaque tour de jeu, elle effectue un peu de construction
        et/ou un peu de vérification à chaque tour. Ça permet de montrer progressivement
        la conquête de Player, et de pas surcharger les traitements, comme d'hab'.

        La méthode est la suivante :
         - Vérifier la présence de la route à construire sur la première case de tiles_to_roadify.
         - Si pas de route, on la construit, même si la tile contient des unités appartenant
           à l'autre Player.
         - Si il a fallu construire la route, on se met en pause durant "DELAY_ROADIFY" tours.
           Ça permet de donner l'impression que les routes mettent un peu de temps à se construire.
           Le temps de pause restant est stocké dans self.delay_roadify.
         - magnétiser la tile sur laquelle on vient de construire la route.
         - attendre que cette tile soit contrôlée par Player, avec au moins 2 unités dessus.
           Cela peut prendre plus ou moins de temps, selon les unités qui sont déjà dessus, la
           quantité d'unité que peut mobiliser Player, etc.
         - enlever cette tile de tiles_to_roadify et passer à la suivante.

        Cette méthode gère correctement le cas où Player déclenche une line conquest sur des roads
        déjà construite, dont certaines tiles sont déjà contrôlée par Player.
        Dans ce cas, on passe très vite (en quelques tours) sur les tiles
        déjà construites et contrôlées, et on s'occupe comme il faut de conquérir les autres tiles,
        grâce à la magnétisation.

        Lorsqu'il n'y a plus de tiles_to_roadify, on passe à la construction de la town.
        La méthode est la suivante :
         - magnétiser tile_to_townify.
         - attendre que la tile soit contrôlée par Player, avec 16 unités dessus.
         - lancer la construction de la ville. Le reste du code se charge d'amener la construction
           jusqu'au bout, si c'est possible.

        FUTURE : faudrait gérer le cas où l'autre Player construit une ville
        en plein pendant que Player fait une line conquest. Pour l'instant osef.
        """
        if not self.tiles_to_roadify and not self.tile_to_townify:
            return
        if self.delay_roadify:
            self.delay_roadify -= 1
            return
        if self.tiles_to_roadify:
            # --- Construction de la ligne de route ---
            first_tile = self.tiles_to_roadify[0]
            if self.tile_magnet != first_tile:
                self.tile_magnet = first_tile
            if first_tile.town is not None:
                # Il y a une ville sur une tile où on doit construire une road.
                # On passe cette tile. (C'est pas trop censée arriver,
                # sauf si on se fait couper la route par une construction de ville.
                # Ça fera une situation un peu bizarre, mais c'est pas grave.)
                self.tiles_to_roadify.pop(0)
                return
            # Construction de la route, horizontale ou verticale.
            if self.is_roadify_horiz and not first_tile.road_horiz:
                first_tile.add_road(horiz=True)
                self.delay_roadify = DELAY_ROADIFY
                return
            if not self.is_roadify_horiz and not first_tile.road_vertic:
                first_tile.add_road(vertic=True)
                self.delay_roadify = DELAY_ROADIFY
                return
            # La tile_to_roadify actuelle possède la route qu'il faut, et elle
            # est contrôlée par Player et elle a 2 unités dessus. On peut passer
            # à la tile suivante (qui sera géré au prochain appel de cette fonction).
            if first_tile.player_owner == self and first_tile.nb_unit > 2:
                self.tiles_to_roadify.pop(0)
                return
        else:
            # --- Construction de la town ---
            if self.tile_magnet != self.tile_to_townify:
                self.tile_magnet = self.tile_to_townify
            if (
                self.tile_to_townify.player_owner == self
                and self.tile_to_townify.nb_unit >= 16
            ):
                # On a assez d'unité, et il n'y a pas d'autres construction en cours,
                # on lance la construction.
                if self.tile_building_town is None:
                    self.tile_building_town = self.tile_to_townify
                    self.tile_to_townify = None

    def init_first_units_and_town(self):
        """
        À exécuter au début d'une partie.
        Crée la première ville et ajoute les premiers pixels de Player.
        La ville est créée dans le coin "arrière" de l'aire de jeu,
        en fonction de la direction de conquête de Player.
        16 unités sont ajoutées sur les 4 cases adjacentes à la ville.
        Puis 14 unités sont ajoutées sur la cases diagonale arrière de la ville.

        Ça fait un bon petit capital d'unités, permettant de construire assez vite
        une ou deux autres towns.
        """
        # La town n'est pas tout à fait créée dans le coin arrière.
        # Mais à une case de distance (en diagonale) du coin arrière).

        # Détermination des coordonnées de la tile où placer la town, en fonction
        # de rightward et downward. J'ai déjà fait ce genre de bout de code,
        # mais là j'ai la flemme de le factoriser.
        if self.rightward:
            x_first_town = 1
        else:
            x_first_town = self.w - 2
        if self.downward:
            y_first_town = 1
        else:
            y_first_town = self.h - 2
        # Placement de 16 unités, puis construction de la town sur cette tile.
        tile_first_town = self.game_master.game_area[y_first_town][x_first_town]
        tile_first_town.add_unit(self, 16)
        tile_first_town.build_town()

        # Placement de 16 unités sur les 4 tile adjacentes.
        for tile_adj in tile_first_town.town.adjacent_tiles:
            tile_adj.add_road(True, True)
            tile_adj.add_unit(self, 16)
        # Placement de 14 unités sur la tile diagonale arrière.
        # J'ai décidé d'en mettre 14 et pas 16, pour ne pas faire complètement
        # des gros carrés tout rouge ou tout bleu. Avec un peu de chance,
        # ça aide un peu les personnes qui découvrent le jeu à comprendre
        # son fonctionnement.
        tile_back = tile_first_town.adjacencies[self.dir_back_diag]
        tile_back.add_unit(self, 14)

    def auto_build_towns(self):
        """
        Fonction utilisée pour le mode "dodo".
        Déclenche automatiquement la construction d'une town, sur une tile
        voisine d'une town existante, choisie au hasard.
        """
        if self.tile_building_town is not None:
            return

        if self.tile_to_townify is not None and self.tile_to_townify.town is not None:
            # Town en construction, mais sur une tile comportant déjà une town.
            # Ça arrive lorsque les deux Players tentent de construire sur
            # la même tile. La première construction qui se termine a gagné,
            # l'autre Player abandonne et tentera une construction ailleurs.
            self.tile_to_townify = None
            return

        self.nb_turn_auto_build_town += 1
        if self.nb_turn_auto_build_town == 50:
            # Ça fait 50 tours qu'on a demandé une construction sur une tile,
            # et il n'y a toujours pas de town sur cette tile.
            # Ça peut arriver pour tout un tas de raison (pas assez d'unités
            # pouvant aller sur cette tile, concurrence avec l'autre Player, ...)
            # Pour ne pas rester bloqué, on annule, et au prochain tour
            # on tentera une construction ailleurs.
            self.tile_to_townify = None

        if self.tile_to_townify is None and self.active_towns:
            # C'est bon, on n'a rien en cours.
            # On choisit au hasard une town active, on prend la première
            # tile vide adjacente, et on lance une construction dessus.
            selected_town = random.choice(self.active_towns)
            if selected_town.unit_gen_tiles:
                self.nb_turn_auto_build_town = 0
                self.tile_to_townify = selected_town.unit_gen_tiles[0]


class Town:
    """
    Une ville, placée sur une seule tile, ou qui s'étend sur un carré de 2x2 ou 4x4 tiles.

    Les villes sont imprenables et indestructibles (ça simplifie le jeu), mais elles peuvent
    être fusionnées/shatterées avec d'autres villes de la même couleur.

    Lorsqu'une town est créée, elle construit automatiquement des route horizontales + verticales
    (des croisements) autour d'elle. Ça se passe progressivement :
    Tous les 5 tours de jeu, on vérifie si toutes les cases adjacentes qui sont des croisements
    sont contrôlées par Player. Si oui, on construit un croisement supplémentaire,
    jusqu'à ce que toutes les cases adjacentes comportent des croisements.
    Ces actions sont effectuées par la fonction process_unit_generation, qui s'occupe également
    de générer les pixels. C'est pas génial parce qu'une même fonction fait 2 choses.
    Mais bon c'est comme ça.

    C'est aussi pour ça qu'au début, les towns ne construisent pas forcément leurs croisements.
    Parce que la génération d'unités est bloquée, car il y a beaucoup d'unités et peu de terrain
    contrôlée. (Voir constante RATIO_CONTROLLED_TILE_FOR_GEN).

    Le fait de construire un croisement adjacent place automatiquement la tile dans le suburb de
    la town. Or les unités d'un même suburb se répartissent équitablement. Donc une town qui a
    suffisamment d'unités autour d'elle va rapidement construire un croisement, en prendre le
    contrôle, ce qui permet de construire le croisement suivant, et ainsi de suite.
    """

    # clé : un tuple. (taille town, rightward, downward)
    # valeur : les index, dans la liste self.tiles_position, des tiles
    #          qui génèrent des missiles.
    # Il n'y a pas la taille de town = 1, car pour cette tile, la liste se déduit très facilement.
    DICT_INDEX_MISSILE_TILES = {
        (2, False, False): (1, 2),
        (2, True, True): (2, 1),
        (2, False, True): (0, 3),
        (2, True, False): (3, 0),
        (4, False, False): (3, 6, 9, 12),
        (4, True, True): (12, 9, 6, 3),
        (4, False, True): (0, 5, 10, 15),
        (4, True, False): (15, 10, 5, 0),
    }

    def __init__(
        self, x_left, y_up, size, player_owner, game_master, create_suburb=True
    ):
        """
        Les towns sont toujours intégrées dans un suburb (plus ou moins grand).
        Lorsqu'on instancie une nouvelle town, il faut créer son suburb.

        Lorsqu'on instancie une town suite à merge ou un shatter, pas besoin de créer
        de nouveau suburb. Dans ce cas, le param create_suburb est False.
        """
        # Coordonnées du coin supérieur gauche de la ville.
        self.x_left = x_left
        self.y_up = y_up
        self.size = size
        self.player_owner = player_owner
        # Le game master qui gère tout le jeu.
        self.game_master = game_master
        # Une town est active si elle a au moins une tile non-town adjacente.
        # C'est à dire qu'elle peut générer des unités et les placer autour d'elle.
        self.is_active = True
        self.unit_gen_points = 0
        # Formule compliquée, juste pour dire :
        # size 1 : 1 point de génération. size 2 : 6. size 4 : 22.
        self.unit_gen_speed = size ** 2 + size * 2 * (size > 1)

        # Liste des tiles sur lesquelles est placée la town. La première tile est toujours celle
        # du coin supérieur gauche, quelle que soit la direction de conquête de Player.
        self.tiles_position = []
        for y in range(y_up, y_up + size):
            for x in range(x_left, x_left + size):
                self.tiles_position.append(self.game_master.game_area[y][x])

        self._compute_unit_gen_tiles()
        self.adjacent_tiles = tuple([tile for tile in self.unit_gen_tiles])
        self.update_unit_gen_tiles()
        self.built_all_adjacent_roads = False
        x_behind, y_behind, self.sorting_key = self.player_owner.get_town_infos(self)
        # tile_go_backward_diag est la tile de town qui est la plus backward possible.
        # C'est elle qui sera utilisée pour envoyer les units lors d'une backward conquest.
        self.tile_go_backward_diag = self.game_master.game_area[y_behind][x_behind]
        # Détermination de la liste des tiles générant des missiles.
        if self.size == 1:
            self.tiles_gen_missile = self.tiles_position
        else:
            missile_tile_indexes_key = (
                self.size,
                self.player_owner.rightward,
                self.player_owner.downward,
            )
            self.tiles_gen_missile = [
                self.tiles_position[index]
                for index in Town.DICT_INDEX_MISSILE_TILES[missile_tile_indexes_key]
            ]
        # Si c'est une town qui vient d'être construite, on lui crée tout de suite son petit suburb
        # (qui sera éventuellement fusionné avec d'autres juste après).
        # Si c'est une town créée suite à des merge/shatter, il y a déjà un suburb.
        if create_suburb:
            suburb_of_this_town = Suburb(self, self.game_master)

    def get_suburb_owner(self):
        """
        Renvoie le suburb auquel appartient cette town.
        """
        # Toutes les tiles d'une même town ont le même suburb owner. Puisque c'est la même town.
        # Donc on se prend pas la tête, on renvoie le suburb owner de la première tile de la town.
        # Pas besoin de checker les autres ni de vérifier que c'est le même suburb owner pour
        # tout le monde.
        return self.tiles_position[0].suburb_owner

    def _apply_coord_offsets_and_filter(self, x_base, y_base, offsets):
        """
        Renvoie une liste de tile en fonction d'une coordonnée de départ et d'une liste
        d'offset (x, y). Au passage, on filtre : on vérifie que les coordonnées
        ne dépassent pas les bords de l'aire de jeu.
        Ça pourrait être une fonction plus générique. Mais je m'en sers que dans la town,
        alors je la laisse là.
        """
        return [
            self.game_master.game_area[y_base + y_offset][x_base + x_offset]
            for (x_offset, y_offset) in offsets
            if 0 <= x_base + x_offset < self.game_master.w
            and 0 <= y_base + y_offset < self.game_master.h
        ]

    def _compute_unit_gen_tiles(self):
        """
        Calcule la variable unit_gen_tiles. C'est la liste de tiles où on pose les units.
        L'ordre des tiles est donnée avec le horiz en priorité, puis le vertic.
        L'ordre est en accord avec la direction de conquête de Player.
        Faudrait faire un schéma, mais pfouuuu...

        Pour la génération des unités, cet ordre n'est pas si important, puisque ça se
        répartit automatiquement dans le suburb.
        Mais on utilise ce même ordre dans l'interface, lorsque Player doit choisir
        une direction de conquête.
        """
        size = self.size
        wardnesses = (self.player_owner.rightward, self.player_owner.downward)
        if wardnesses == (True, False):
            unit_gen_offsets = (
                [(size, size - 1 - offset) for offset in range(size)],
                [(offset, -1) for offset in range(size)],
                [(-1, size - 1 - offset) for offset in range(size)],
                [(offset, size) for offset in range(size)],
            )
        elif wardnesses == (False, True):
            unit_gen_offsets = (
                [(-1, offset) for offset in range(size)],
                [(size - 1 - offset, size) for offset in range(size)],
                [(size, offset) for offset in range(size)],
                [(size - 1 - offset, -1) for offset in range(size)],
            )
        elif wardnesses == (True, True):
            unit_gen_offsets = (
                [(size, offset) for offset in range(size)],
                [(offset, -1) for offset in range(size)],
                [(-1, offset) for offset in range(size)],
                [(offset, size) for offset in range(size)],
            )
        elif wardnesses == (False, False):
            unit_gen_offsets = (
                [(-1, size - 1 - offset) for offset in range(size)],
                [(size - 1 - offset, -1) for offset in range(size)],
                [(size, size - 1 - offset) for offset in range(size)],
                [(size - 1 - offset, size) for offset in range(size)],
            )
        else:
            raise Exception("Bad wardnesses. Not supposed to happen.")

        # On filtre d'abord. Et ensuite on additionne les listes.
        (horiz_first, vertic_first, horiz_second, vertic_second) = unit_gen_offsets
        horiz_first = self._apply_coord_offsets_and_filter(
            self.x_left, self.y_up, horiz_first
        )
        vertic_first = self._apply_coord_offsets_and_filter(
            self.x_left, self.y_up, vertic_first
        )
        horiz_second = self._apply_coord_offsets_and_filter(
            self.x_left, self.y_up, horiz_second
        )
        vertic_second = self._apply_coord_offsets_and_filter(
            self.x_left, self.y_up, vertic_second
        )

        self.unit_gen_tiles = horiz_first + vertic_first + horiz_second + vertic_second

    def update_unit_gen_tiles(self):
        """
        Met à jour la liste self.unit_gen_tiles, ainsi que self.is_active,
        en fonction des towns autour.
        Cette mise à jour ne fait que des suppressions dans self.unit_gen_tiles.
        On enlève les tiles au fur et à mesure que des towns adjacentes se construisent.
        """
        self.unit_gen_tiles = [
            tile for tile in self.unit_gen_tiles if tile.town is None
        ]

        if not self.unit_gen_tiles:
            # La town est entourée de town. Elle ne peut plus générer d'unité.
            # On la désactive, et on met à jour la liste des towns active de Player.
            self.is_active = False
            # La town garde ses points de génération de unit.
            # Ils seront réutilisés si la town est fusionnée avec d'autres.
            # Et si c'est une town de size max et qu'elle est désactivée, eh bien
            # ces points ne servent plus à rien. Player avait qu'à mieux gérer son urbanisme.
            self.player_owner.update_active_towns()
            # Il faut updater la liste des gamobjects de chaque tile de la town,
            # car lorsque la town est désactivée, on l'affiche en plus foncée.
            for tile in self.tiles_position:
                tile.update_linked_gamobjs()

    def process_unit_generation(self):
        """
        Gère la construction des routes autour d'une town,
        ainsi que la génération d'unités par les towns.
        Une town crée de temps en temps une unité, sur une de ses cases adjacentes.
        """
        self.unit_gen_points += self.unit_gen_speed
        self.unit_gen_points = min(self.unit_gen_points, UNIT_GEN_TOWN_POINT_MAX_CUMUL)

        if not self.built_all_adjacent_roads:
            if self.unit_gen_points % 5 == 0:

                if all(
                    [
                        tile.road_horiz and tile.road_vertic
                        for tile in self.unit_gen_tiles
                    ]
                ):
                    # On croyait qu'on n'avait pas construit toutes les routes autour,
                    # et en fait si. On met à jour le booléen.
                    # Tout va bien, au prochain tour, on ne passera plus par ces vérifs.
                    self.built_all_adjacent_roads = True
                    # On s'en va tout de suite. Ce qui signifie qu'on ne produit pas
                    # forcément l'unité que la ville devrait produire.
                    # Ce n'est pas trop grave, ça décale la production juste pour un tour.
                    # De toutes façons les points de production unit_gen_points sont conservés.
                    return

                # À la fin du traitement, ce booléen vaudra True si toutes les tiles
                # adjacentes qui sont des croisements de route sont contrôlées par Player.
                # on ne vérifie pas les tiles n'ayant pas les deux routes.
                all_roads_are_controlled = True
                for tile in self.unit_gen_tiles:
                    if (
                        tile.road_horiz
                        and tile.road_vertic
                        and self.player_owner != tile.player_owner
                    ):
                        # Toutes les tiles de routes autour de la town
                        # ne sont pas contrôlées par Player.
                        all_roads_are_controlled = False
                        break

                if all_roads_are_controlled:
                    # On n'a pas encore construit toutes les routes autour de la town,
                    # mais les cases ayant des routes sont toutes contrôlées par Player.
                    # On peut donc se permettre de construire une route de plus.
                    # Ça va automatiquement étendre le suburb de la town, ce qui permettra
                    # de répartir les unités de Player sur plus de tiles
                    # (si Player a assez d'unités).
                    for tile in self.unit_gen_tiles:
                        if not tile.road_horiz or not tile.road_vertic:
                            tile.add_road(True, True)
                            # On a construit une route. C'est bien assez pour ce tour, on s'en va.
                            # Même remarque que précédemment, ça peut décaler la production
                            # d'unité pour un tour, mais juste une seule fois,
                            # puisque les unit_gen_points sont conservés.
                            return

        if self.unit_gen_points > UNIT_GEN_TOWN_POINT_REQUIRED:
            # On ajoute une unité sur la première tile qui va bien, osef.
            # Le suburb s'occupera de les répartir comme il faut.
            for tile in self.unit_gen_tiles:
                if self.player_owner != tile.player_owner or tile.nb_unit < 16:
                    tile.add_unit(self.player_owner)
                    self.unit_gen_points -= UNIT_GEN_TOWN_POINT_REQUIRED
                    return

            # Si on est arrivé à la fin de la boucle, on aurait du générer une unit,
            # mais on n'a aucun endroit où la placer. Tant pis, on testera au prochain tour.
            # C'est pour ça qu'on peut cumuler plus de points de génération que le coût de
            # création d'une unit. Ça permet d'avoir un petit délai dans la génération,
            # sans perdre de points.


class Suburb:
    """
    Un suburb est constitué de l'ensemble des tiles ayant une route, adjacentes
    à des towns qui sont voisines. Un suburb peut englober des towns de différents players.
    Ils sont neutres et sont gérés pas le game_master. Les Players n'ont aucun contrôle dessus.
    Les suburbs servent uniquement à répartir les unités sur leurs tiles.
    Lorsque deux suburbs ont une tile de route en commun, on les fusionne (merge).

    Variables membres importantes des suburbs :
     - town_tiles : liste de tiles contenant les towns appartenant à ce suburb.
       une town est toujours dans un et un seul suburb.
     - real_suburb_tiles : toutes les tiles ayant une route du suburb.
     - potential_tiles : les tiles non-road et non-ville, adjacentes à une town du suburb.
       Elles ne sont pas dans le suburb, mais pourraient y être si on construisait
       une road dessus.
     - bounding_rect : rectangle englobant toutes les tiles et potential tiles du suburb.
       (On s'en sert uniquement pour accélerer les traitements).

    Lorsqu'une ville est créée sur une potential ou real tile d'un suburb existant, on crée
    le mini-suburb autour de la nouvelle ville, et on le fusionne tout de suite
    avec le suburb existant.

    Lorsqu'une route est créée, il faut vérifier si la tile n'appartient pas aux potential tiles
    de un ou plusieurs suburbs. Lorsque c'est le cas, on transfère cette tile de potential à real.
    Si on l'a fait pour plusieurs suburbs, on fusionne tous ces suburbs ensemble.

    On n'a besoin que de deux choses pour gérer l'évolution des suburbs :
     - la fonction de merge,
     - une petite fonction, dans la classe Town, qui va créer un mini-suburb de 4 tiles
       potentielles autour d'elle-même.

    L'intérêt d'un suburb, c'est que les unités se répartissent équitablement entre ses
    real_suburb_tiles.
    S'il y a des unités de couleurs différentes dans le suburb, elles s'éliminent
    automatiquement une par une, jusqu'à ce qu'il ne reste qu'une couleur.
    """

    def __init__(self, initial_town, game_master):
        self.game_master = game_master
        if initial_town.size != 1:
            raise Exception("Pas de création de suburb à partir de grandes towns.")
        self.town_tiles = list(initial_town.tiles_position)
        for tile in self.town_tiles:
            tile.suburb_owner = self
        all_suburb_tiles = [
            tile for tile in initial_town.adjacent_tiles if tile.town is None
        ]
        # Lorsqu'on crée un suburb, normalement, il faut mettre à jour les connexions
        # de routes entre les tiles
        # (c'est à dire les variables road_adjacencies_same_player des Tiles).
        # Car on n'a plus besoin de retenir que deux tiles adjacentes sont connectées
        # par une route, si elles font partie d'un même suburb.
        # Ici, on ne fait pas les vérifications de connexions à couper.
        # Ça n'arrive jamais, car les nouveaux suburbs ne sont créés que avec des
        # towns ayant une size de 1. Donc ils ne comportent pas de routes adjacentes.
        # Si on avait voulu pinailler, il aurait fallu exécuter
        # update_all_road_adjacencies à chaque tile de route.
        # Dans les faits, il est fort possible que ce mini-suburb soit immédiatement
        # mergé avec un suburb voisin. Et là on exécutera cette fonction.
        self.real_suburb_tiles = []
        self.potential_tiles = []
        for tile in all_suburb_tiles:
            if tile.road_horiz or tile.road_vertic:
                self.real_suburb_tiles.append(tile)
                tile.suburb_owner = self
            else:
                self.potential_tiles.append(tile)
        self._update_bounding_rect()
        self.game_master.suburbs.append(self)

    def _update_bounding_rect(self):
        """
        Définit self.bounding_rect. Une liste de 4 int (x1, y1, x2, y2),
        qui englobe toutes les tiles du suburb.
        Comme d'hab' en python, le rect s'étend de x1 à x2 - 1, et de y1 à y2 - 1.
        C'est comme la fonction "range".
        """
        all_tiles = self.town_tiles + self.real_suburb_tiles + self.potential_tiles
        xs = [tile.x for tile in all_tiles]
        ys = [tile.y for tile in all_tiles]
        self.bounding_rect = (min(xs), min(ys), max(xs) + 1, max(ys) + 1)

    def transfer_potential_road(self, tile):
        """
        Transfert une tile de la liste self.potential_tiles vers la liste self.real_suburb_tiles,
        car une route (ou les deux routes) ont été construites dessus.
        """
        if tile not in self.potential_tiles:
            return
        if not tile.road_horiz and not tile.road_vertic:
            return
        self.potential_tiles.remove(tile)
        self.real_suburb_tiles.append(tile)
        tile.suburb_owner = self
        # Il faut mettre à jour les connexions de routes entre tiles, c'est à dire
        # mettre éventuellement la valeur "2" dans road_adjacencies_same_player.
        # C'est la classe Tile qui s'en charge.

    def merge(self, other_suburb):
        """
        Fusionne ce suburb avec un autre suburb passé en paramètre.
        Après la fusion, tout est dans le suburb self. Le other_suburb sera retiré du jeu.
        """
        roads_other_suburb = other_suburb.real_suburb_tiles
        # On met en commun toutes les tiles des deux suburbs et on en fait une grosse liste.
        # Et ensuite, on répartit ces tiles dans les 3 listes :
        # (town_tiles, real_suburb_tiles, potential_tiles), en fonction de ce qu'il y a dessus.
        # On élimine les doublons et on met à jour les liens suburb_owner dans les tiles.
        all_tiles_two_suburbs = (
            self.potential_tiles
            + self.real_suburb_tiles
            + self.town_tiles
            + other_suburb.potential_tiles
            + other_suburb.real_suburb_tiles
            + other_suburb.town_tiles
        )
        self.town_tiles = []
        self.real_suburb_tiles = []
        self.potential_tiles = []

        for tile in all_tiles_two_suburbs:
            if tile.town is not None:
                tile.suburb_owner = self
                if tile not in self.town_tiles:
                    self.town_tiles.append(tile)
            elif tile.road_horiz or tile.road_vertic:
                tile.suburb_owner = self
                if tile not in self.real_suburb_tiles:
                    self.real_suburb_tiles.append(tile)
            else:
                if tile not in self.potential_tiles:
                    self.potential_tiles.append(tile)

        for road_tile in roads_other_suburb:
            # On met des connexions à 2 entre les routes d'un même suburb.
            # C'est à dire qu'on coupe ces connexions, car la répartition des
            # unités sera gérée par le suburb lui-même.
            # Il faut checker toutes les routes du suburb mergé.
            # D'où l'intérêt de prendre le plus gros suburb et d'exécuter sa fonction merge,
            # avec le plus petit suburb en paramètre. Et non pas le contraire.
            # Sinon on se retrouve à rechecker plein de connexions déjà annulées.
            road_tile.update_all_road_adjacencies()

        self._update_bounding_rect()
        self.game_master.suburbs.remove(other_suburb)

    def __str__(self):
        coords_towns = [(tile.x, tile.y) for tile in self.town_tiles]
        coords_real = [(tile.x, tile.y) for tile in self.real_suburb_tiles]
        coords_poten = [(tile.x, tile.y) for tile in self.potential_tiles]
        return (
            f"Suburb. bounding rect : {self.bounding_rect}\n"
            f"Towns: {coords_towns}"
            f"Real : {coords_real}"
            f"Poten: {coords_poten}"
        )


class Tile:
    """
    Une tile. Une case dans la "warzone"
    (la zone où se passe le jeu, c'est à dire la zone de pas-interface).

    Une Tile est toujours contrôlée par zéro ou un seul Player.
    """

    # Nom des game objects de background à afficher, en fonction
    # des roads. Il faut ensuite préfixer ces noms par la couleur
    # de Player ayant le contrôle de la tile.
    GAMOBJ_BACKGROUND_FROM_ROADS = {
        (False, False): "_controls",
        (True, False): "_road_horiz",
        (False, True): "_road_vertic",
        (True, True): "_road_both",
    }

    def __init__(self, x, y, linked_gamobjs, game_master):
        self.x = x
        self.y = y
        # linked_gamobjs est une liste de string. La classe Tile doit en modifier le contenu.
        # Elle contient les game objects à afficher à l'écran, pour représenter
        # le contenu de la tile.
        self.linked_gamobjs = linked_gamobjs
        self.game_master = game_master
        # Contiendra des références vers les tiles adjacentes à cette tile.
        # (C'est le game master qui initialise cette liste, après avoir créé toutes les tiles)
        # Certains éléments de cette liste pourront rester à None, si la tile est sur un bord
        # de l'aire de jeu.
        self.adjacencies = [None for _ in range(8)]
        # self.road_adjacencies_same_player indique si la route est adjacente avec une autre route
        # contrôlée aussi par Player.
        # 0 : non
        # 1 : Oui. On doit transférer automatiquement des unités d'une tile à l'autre,
        #     dans le cas où la répartition est trop désequilibrée.
        # 2 : Il y a une connexion, mais c'est entre deux routes d'un même suburb.
        #     Dans ce cas, on n'équilibre pas par les routes.
        #     Ça s'équilibre tout seul par le suburb.
        # Dans cette liste, toutes les adjacences diagonales (1, 3, 5, 7) sont toujours à zéro.
        # Mais je laisse comme ça pour être homogène avec la gestion d'adjacences, qui utilise
        # systématiquement les nombres de 0 à 7.
        self.road_adjacencies_same_player = [0 for _ in range(8)]
        # Indique si la tile comporte des routes ou pas.
        self.road_vertic = False
        self.road_horiz = False
        # Player qui contrôle la tile.
        self.player_owner = None
        self.nb_unit = 0
        # Référence éventuelle vers la town qui occupe cette tile. Pour les towns de size > 1,
        # plusieurs tiles auront cette référence vers une même town.
        self.town = None
        # La variable suburb_owner est définie par les Suburb.
        # Soit lors de la création d'un nouveau suburb, soit lors d'un merge.
        self.suburb_owner = None
        # Indique si une town est en cours de construction sur cette tile.
        self.town_building_step = 0

    def update_linked_gamobjs(self):
        """
        Grosse fonction, qui met à jour tous les game objects que possède cette tile, pour
        afficher à l'écran ce qu'il ya dessus.
        Cette fonction doit être appelée à chaque fois qu'on effectue un changement sur la tile :
        ajout/suppression d'unité, ajout de road, avancement de la construction d'une ville,
        merge/shatter de ville, etc.

        La fonction recalcule tous les game objects qui doivent être présents. C'est ensuite mis
        en cache, pour pouvoir faire un redraw rapide du jeu à l'écran.
        Trop la classe, on a l'impression de faire du double buffering.

        Lorsqu'on modifie des éléments d'interface (Player sélectionne une town,
        on affiche une line conquest, etc.), il ne faut pas modifier le contenu
        de la tile elle-même, donc pas besoin d'appeler cette fonction.
        """

        if self.player_owner is None:
            # détermination du background (avec route ou pas) dans le cas d'une tile contrôlée
            # par aucun Player. Pas grand chose à faire dans ce cas, car si aucun Player
            # ne contrôle la tile, il n'y a que le background à afficher.
            if self.road_horiz or self.road_vertic:
                gamobj_bg_suffix = Tile.GAMOBJ_BACKGROUND_FROM_ROADS[
                    (self.road_horiz, self.road_vertic)
                ]
                gamobj_background = "neutral" + gamobj_bg_suffix
                self.linked_gamobjs[:] = [gamobj_background]
            else:
                self.linked_gamobjs[:] = []
            return

        gamobjs = []
        color = self.player_owner.color
        if self.town:
            # Détermination du game object de la town.
            # Soit c'est une town de size 1, et on sait tout de suite lequel c'est.
            # Soit c'est une town plus étendu, il faut faire un petit calcul pour savoir
            # où se trouve la tile par rapport au coin supérieur gauche de la town.
            town_size = self.town.size
            if town_size == 1:
                gamobj_town_suffix = "_town_1x1"
            else:
                # On met des fonctions "min" juste au cas où.
                # En réalité y'a pas besoin. Le décalage entre la tile et
                # le coin supérieur gauche de la town ne dépasse jamais la size.
                offset_x = min(self.x - self.town.x_left, town_size - 1)
                offset_y = min(self.y - self.town.y_up, town_size - 1)
                gamobj_town_suffix = (
                    f"_town_{town_size}x{town_size}_{offset_x}{offset_y}"
                )
            gamobjs.append(color + gamobj_town_suffix)
            if not self.town.is_active:
                gamobjs.append("town_desactivate")
        else:
            # Détermination du background (avec route ou pas) dans le cas d'une tile
            # contrôlée par un/une Player.
            gamobj_bg_suffix = Tile.GAMOBJ_BACKGROUND_FROM_ROADS[
                (self.road_horiz, self.road_vertic)
            ]
            gamobj_background = color + gamobj_bg_suffix
            gamobjs.append(gamobj_background)
            # Détermination du game object affichant le nombre d'unités présentes sur la tile.
            if self.nb_unit:
                # Il ne devrait jamais y avoir plus de 16 unités sur une même tile,
                # mais on sait jamais. Donc on met un min.
                str_nb_unit = GAMOBJ_NAME_TO_NB_UNIT[min(self.nb_unit, 16)]
                gamobjs.append(f"{color}_{str_nb_unit}")
            if self.town_building_step:
                gamobjs.append(f"{color}_town_build_{self.town_building_step:02d}")
        self.linked_gamobjs[:] = gamobjs

    def __str__(self):
        str_roads = "|" * self.road_vertic + "-" * self.road_horiz
        return (
            f"Tile x: {self.x} y: {self.y} player_owner: {self.player_owner} "
            f"nb_unit: {self.nb_unit} town: {self.town} road: {str_roads} "
            f"road_adjacencies_same_player {self.road_adjacencies_same_player} "
            f"suburb_owner: {self.suburb_owner}"
        )

    def is_road_connected(self, direction, other_tile):
        """
        Vérifie si deux tiles adjacentes sont connectées par une route.
        Attention, les paramètres doivent être cohérents entre eux,
        ils ne sont pas contrôlés par cette fonction.
        C'est à dire que other_tile doit être la tile adjacente à celle-ci, dans la direction donnée.
        Pour résumer : self.adjacencies[direction] == other_tile
        """
        if direction in (2, 6):
            return self.road_horiz and other_tile.road_horiz
        if direction in (0, 4):
            return self.road_vertic and other_tile.road_vertic
        return False

    def _update_road_adjacency(self, direction):
        """
        Met à jour un élément de la variable road_adjacencies_same_player, pour la direction
        indiquée en param.
        En même temps, on met à jour l'élément opposé de road_adjacencies_same_player de la
        tile adjacente.
        Rappel : chaque élément de road_adjacencies_same_player peut valoir :
         - 0 : pas de route, ou alors une route, mais les deux tiles adjacentes
               appartiennent à deux Players différent(e)s.
         - 1 : une route qui connecte, et les deux tiles sont contrôlées par Player.
         - 2 : les deux tiles appartiennent au même suburb. Il y a une connexion,
               mais on s'en fiche. On ne s'occupera pas de cette connexion
               lorsqu'on effectuera des répartitions de pixels sur les routes.
        """
        other_tile = self.adjacencies[direction]
        if other_tile is None:
            # C'est une tile sur un bord d'écran.
            self.road_adjacencies_same_player[direction] = 0
            return

        # Pas de pre-check. On fixe systématiquement à 0, 1 ou 2 selon l'état en cours.
        # Si ça redéfinit à la même valeur, osef.
        # Comme ça on gère automatiquement le passage de 2 à 0, lorsqu'on construit une ville
        # à l'endroit où il y avait une route de suburb.
        if self.town is not None or other_tile.town is not None:
            # Jamais de connexion de route entre une town et une tile adjacente.
            # Même si il y a une road sur la tile adjacente.
            # L'équilibrage des unités dans ce cas est géré par le suburb.
            connection_type = 0
        elif (
            self.suburb_owner is not None
            and self.suburb_owner == other_tile.suburb_owner
        ):
            # C'est pas une vraie connexion.
            # Il y a des routes, mais on considère qu'elles ne sont pas connectées.
            # Dans ce cas aussi, l'équilibrage des unités est géré par le suburb.
            connection_type = 2
        else:
            roads_ok = self.is_road_connected(direction, other_tile)
            connection_ok = all(
                (
                    roads_ok,
                    self.player_owner is not None,
                    self.player_owner == other_tile.player_owner,
                )
            )
            connection_type = int(connection_ok)

        self.road_adjacencies_same_player[direction] = connection_type
        reversed_direction = REVERSE_DIRS[direction]
        # Mise à jour de la connexion opposée, pour la tile adjacente à cette tile.
        other_tile.road_adjacencies_same_player[reversed_direction] = connection_type

    def update_all_road_adjacencies(self):
        """
        Mise à jour de toute la liste road_adjacencies_same_player, en fonction
        des roads et des tiles contrôlées.
        Pas de mise à jour sur les adjacences diagonales, car pas de routes diagonales.
        """
        self._update_road_adjacency(0)
        self._update_road_adjacency(2)
        self._update_road_adjacency(4)
        self._update_road_adjacency(6)

    def _update_all_road_adjacencies_with_current_roads(self):
        """
        Comme on ne peut que ajouter des routes et pas en détruire (sauf dans le cas spécial
        où on construit une ville), les seules mises à jour d'adjacences utiles
        sont pour les directions où on a la route correspondante.
        Sinon, les autres adjacences, ça va rester à zéro, pas besoin d'updater.
        """
        if self.road_horiz:
            self._update_road_adjacency(2)
            self._update_road_adjacency(6)
        if self.road_vertic:
            self._update_road_adjacency(0)
            self._update_road_adjacency(4)

    def add_unit(self, player, qty=1):
        """
        Ajoute une ou plusieurs unités sur la tile, appartenant à Player, indiqué en param.
        Cette fonction effectue tous les checks nécessaires et toutes les mises à jour
        des listes d'indexation, de comptage, de contrôle, etc.

        Si on ajoute des unités de Player A, alors qu'il y a déjà des unités de Player B,
        les unités s'annulent. On peut avoir 3 cas possibles :
         - moins d'unité de A que de B : ça fait diminuer un peu les unités de B, c'est tout.
         - autant d'unités de A et de B : toutes les unités s'éliminent. La tile n'est plus
           contrôlée par personne.
         - plus d'unités de A que de B : on enlève d'abord toutes les unités de B.
           On met à jour tout ce qu'il faut par rapport au fait que B perd le contrôle
           d'une tile, puis on ajoute ce qu'il reste des unités de A. Et on fait
           à nouveau des mises à jour par rapport au fait que A gagne le contrôle d'une tile.
        """
        if not qty:
            return
        if self.town is not None:
            raise Exception(
                "Ajout de unit sur une ville. Not supposed to happen." + str(self)
            )

        initial_nb_unit = self.nb_unit
        must_check_road_adjacencies = True
        if self.player_owner == player:
            # Pas de check pour vérifier que ça dépasse pas 16. Faut l'avoir fait avant.
            self.nb_unit += qty
            player.total_units += qty
            # Même couleur entre les unités déjà sur la tile et celles qu'on ajoute.
            # Ça change rien au niveau des routes, des contrôles, etc.
            must_check_road_adjacencies = False
        elif self.player_owner is None:
            self.player_owner = player
            player.add_controlled_tile(self)
            if self.road_vertic or self.road_horiz:
                player.add_controlled_road(self)
                self.game_master.uncontrolled_roads.remove(self)
            self.nb_unit += qty
            player.total_units += qty
        else:
            if qty < self.nb_unit:
                # On élimine un peu d'unité de l'autre Player, et on s'arrête là.
                self.remove_unit(qty)
            else:
                qty_unit_left_after = qty - self.nb_unit
                # On enlève toutes les unités de l'autre Player. La fonction remove_unit
                # gère toutes les mises à jour de listes, index, etc., dans le cas d'une
                # suppression.
                self.remove_unit(self.nb_unit)
                # Ha ha. Récursivité. La fonction add_unit s'appelle elle-même.
                # Mais ce re-appel ne peut arriver qu'une seule fois maximum.
                # car quand on en arrive là, la tile n'est plus contrôlée par personne.
                self.add_unit(player, qty_unit_left_after)

        # C'est quand même dangereux cette histoire de récursivité. Car le bout de code
        # ci-dessous s'exécute deux fois, dont une qui n'a jamais d'effet.
        # Mais bon, euh... ça passe. On laisse comme ça.
        if (
            not self.road_vertic
            and not self.road_horiz
            and self.town is None
            and self.nb_unit > 1
            and initial_nb_unit <= 1
        ):
            # On est passé de 0 ou 1 unités à plusiers unités, et il n'y a pas de routes.
            # Cette tile doit donc être référencée dans la liste des bare tiles ayant
            # plus de une unité.
            self.player_owner.controlled_bare_tiles_with_many_units.append(self)

        if must_check_road_adjacencies:
            # L'ajout d'unité a provoqué un changement important.
            # Par exemple, la tile a changé d'owner.
            # Il faut donc vérifier tous les contrôles et les adjacences de routes.
            self._update_all_road_adjacencies_with_current_roads()
        self.update_linked_gamobjs()

    def remove_unit(self, qty=1):
        """
        Supprime une ou plusieurs unités sur une tile, quel que soit Player qui contrôle la tile.
        Comme pour add_unit, cette fonction effectue tous les checks nécessaires,
        et toutes les mises à jour des listes d'indexation, de comptage, de contrôle, etc.

        Si on essaye d'enlever plus d'unité qu'il n'y en a déjà, on fait tomber le nombre d'unité
        à zéro (on n'émet pas d'erreur ni d'avertissement).
        Lorsque le nombre d'unité tombe à zéro, Player perd le contrôle de cette tile.
        """
        if not qty:
            return
        if self.player_owner is None:
            raise Exception("Not supposed to happen.")

        initial_nb_unit = self.nb_unit
        qty = min(qty, self.nb_unit)
        self.nb_unit -= qty
        self.player_owner.total_units -= qty

        if (
            not self.road_vertic
            and not self.road_horiz
            and self.town is None
            and self.nb_unit <= 1
            and initial_nb_unit > 1
        ):
            # On est passé de plusieurs unités à 0 ou 1 unités.
            # On enlève la tile de la liste des bare tiles ayant plus d'une unités.
            self.player_owner.controlled_bare_tiles_with_many_units.remove(self)

        if self.nb_unit == 0:
            self.player_owner.remove_controlled_tile(self)
            if self.road_vertic or self.road_horiz:
                self.player_owner.remove_controlled_road(self)
                self.game_master.uncontrolled_roads.append(self)
            self.player_owner = None
            # La suppression d'unité a provoqué un changement important. Il n'y a plus d'owner.
            # Il faut donc vérifier tous les contrôles et les adjacences de routes.
            self._update_all_road_adjacencies_with_current_roads()

        self.update_linked_gamobjs()

    def add_road(self, horiz=False, vertic=False):
        """
        Ajoute une route (horizontale, verticale, ou les deux) sur la tile.
        Effectue tous les checks qu'il faut et met à jour toutes les listes et les références.
        En particulier, les opérations à faire sur les suburbs.
        La construction d'une route à côté d'une ville fait transférer la tile de
        "potential_tiles" vers "real_suburb_tiles", ce qui peut déclencher la fusion
        de plusieurs suburbs, car la route les connecte entre eux.
        """
        if not (horiz or vertic):
            return
        adj_towns = [
            adj_tile.town
            for adj_tile in self.adjacencies[::2]
            if adj_tile is not None and adj_tile.town is not None
        ]
        if adj_towns:
            # Si c'est à côté d'une ville, on ajoute obligatoirement les deux routes.
            # C'est un pouvoir spécial des towns. Elles transforment en croisement
            # toutes les routes qui passent à côté d'elles.
            horiz = True
            vertic = True

        if horiz == self.road_horiz and vertic == self.road_vertic:
            # Les routes qu'on veut ajouter sont déjà présentes. Pas de changement.
            return
        if self.town is not None:
            raise Exception("Ajout de road sur une town. Not supposed to happen.")

        previous_road_qty = self.road_horiz + self.road_vertic
        self.road_horiz = self.road_horiz or horiz
        self.road_vertic = self.road_vertic or vertic
        current_road_qty = self.road_horiz + self.road_vertic
        self._update_all_road_adjacencies_with_current_roads()
        # Si on a ajouté des routes alors qu'il n'y en avait pas du tout au départ,
        # il y a diverses listes à mettre à jour, pour le game_master et pour Player.
        if previous_road_qty == 0 and current_road_qty > 0:
            if self.player_owner is None:
                self.game_master.uncontrolled_roads.append(self)
            else:
                self.player_owner.add_controlled_road(self)
                if self.nb_unit > 1:
                    self.player_owner.controlled_bare_tiles_with_many_units.remove(self)

        # Gestion des suburbs, que cet ajout de route peut modifier.
        # Si on a une ou plusieurs villes à côté de la tile, alors il se passe des trucs au
        # niveau des suburbs. Sinon, ce n'est pas une tile potentielle de suburb.
        if adj_towns:
            # Récupération de tous les suburbs adjacents. Plusieurs tiles adjacentes peuvent
            # appartenir au même suburb. On gère ce cas avec le "set".
            adj_suburbs = set((town.get_suburb_owner() for town in adj_towns))
            for suburb in adj_suburbs:
                # Dans le ou les suburbs concernés, la construction de route transfère la tile
                # des potential_tiles vers real_suburb_tiles.
                suburb.transfer_potential_road(self)
            if len(adj_suburbs) > 1:
                # Ce transfert de tile peut faire merger un ou plusieurs suburbs.
                # La fonction check_suburb_merging_by_list vérifie tous les merges posibles,
                # et effectue ceux qui doivent être fait.
                self.game_master.check_suburb_merging_by_list(list(adj_suburbs))
            # Maintenant qu'on a fait des merges, on met à jour les connexions entre route.
            # On en annulera certaines (on met des "2" dans road_adjacencies_same_player),
            # car ce sont devenues des routes d'un même suburb.
            self.update_all_road_adjacencies()
        self.update_linked_gamobjs()

    def _remove_all_roads(self):
        """
        Supprime toutes les routes de la tile.
        Il n'y a pas de fonction pour supprimer une seule des deux routes, car pas besoin.
        Le seul moment où on supprime des routes, c'est pour mettre une ville à la place.
        Du coup, la suppression de roads ne provoque jamais de diminution ou de split de suburb,
        donc on gère pas ça non plus, et ça va très bien.
        """
        if not self.road_vertic and not self.road_horiz:
            return
        self.road_vertic = False
        self.road_horiz = False
        # Quelques listes à mettre à jour, et les adjacencies. Mais rien concernant les suburbs.
        if self.player_owner is None:
            self.game_master.uncontrolled_roads.remove(self)
        else:
            self.player_owner.remove_controlled_road(self)
        self.update_all_road_adjacencies()
        self.update_linked_gamobjs()

    def advance_town_building(self):
        """
        Fait avancer de 1 point la construction en cours de la town sur cette tile.
        """
        if self.town_building_step >= NB_TURNS_TOWN_BUILDING:
            return
        self.town_building_step += 1
        # Faut updater les gamobjs, car on affiche à l'écran la construction en cours.
        self.update_linked_gamobjs()

    def cancel_town_building(self):
        """
        Annule la construction en cours de la town sur cette tile.
        Soit à cause d'un timeout, soit parce que Player a donné d'autres ordres, qui annulent
        les diverses actions en cours.
        Une annulation de construction n'a aucune conséquence pour Player. Pas de perte d'unités,
        ni de tile contrôlée. Player a juste perdu quelques tours à construire
        une town pour finalement ne pas la terminer.
        """
        self.town_building_step = 0
        self.update_linked_gamobjs()

    def build_town(self):
        """
        Crée immédiatement une town de size 1 sur cette tile.
        Les 16 unités présentes sur la tile, qui ont été nécessaires durant tout le temps de
        construction de la town, sont automatiquement supprimées.
        La fonction fait tous les checks qu'il faut, la suppression des unités existantes,
        l'ajout dans les listes, etc.
        Pas besoin de spécifier Player. On prend player_owner actuel de la tile.
        Si pas de player_owner, on balance une exception.

        La fonction ne fait rien concernant les merge/shatter de town. C'est le game_master
        qui s'occupe de ça, quand c'est le moment.
        Dans cette fonction, on se contente de modifier l'état de vérif des merge/shatter,
        pour prévenir le game_master qu'il doit relancer tout un cycle de vérification.
        """
        if self.player_owner is None:
            raise Exception("Town without owner. Not supposed to happen.")

        if self in self.player_owner.controlled_bare_tiles_with_many_units:
            self.player_owner.controlled_bare_tiles_with_many_units.remove(self)
        self._remove_all_roads()

        # Pour enlever les units, on aurait dû passer par la fonction remove_unit.
        # Mais on va pas le faire, parce que ça mettrait player_owner à None.
        self.player_owner.total_units -= self.nb_unit
        self.nb_unit = 0
        # Création effective de la town.
        self.town = Town(self.x, self.y, 1, self.player_owner, self.game_master)
        self.player_owner.add_towns([self.town])
        # On ajoute une town. Donc toutes les towns adjacentes ne peuvent plus générer
        # leurs unités sur cette tile. Elles doivent donc remettre à jour leurs listes
        # de génération, voire remettre à jour leur booléen is_active.
        for tile_adj in self.adjacencies[::2]:
            if tile_adj is not None and tile_adj.town is not None:
                tile_adj.town.update_unit_gen_tiles()
        # L'ajout d'une town a automatiquement créé son petit suburb autour d'elle.
        # Il faut immédiatement vérifier si ce suburb ne peut pas être mergé avec
        # un ou plusieurs autres. De cette manière, ça déclenchera les éventuels merges
        # de suburb existants qui doivent être mergés.
        self.game_master.check_suburb_merging_with_all_others(
            self.town.get_suburb_owner()
        )
        self.update_linked_gamobjs()


class Missile:
    """
    Les missiles se déplacent en diagonale, dans une direction prédéfinie.
    Ils sont gérés directement par le Game Master et non pas par Player,
    car une fois qu'un missile est construit, il est (presque) neutre.

    C'est "presque", car un missile possède la variable "player_owner",
    définissant qui l'a construit. Ce qui permet de déduire l'autre Player.

    Cette classe gère la construction, le déplacement et l'explosion du missile.

    Lorsqu'un missile passe au-dessus d'une tile contrôlée par l'autre Player,
    il explose. Mais ils ont une portée limitée, et dans tous les cas ils
    finissent par exploser.

    Les missiles ne détruisent pas les towns, puisque de toutes façons les
    towns sont invincibles. Mais ils explosent si ils passent au-dessus d'une
    town ennemie.

    Lorsqu'un missile explose il génère des unités de bionature sur les tiles
    autour de lui, durant 4 tours, 5 unités à chaque fois.
    Les unités sont placées selon le pattern suivant :
         |  .  |     |     |
      .  |     |  .. | .   |
    . X. | .X .|  X. | .X  |
         |  .  | .   |  .. |
      .  |     |     |     |

    X correspond à la tile d'explosion (on place une unité dessus à chaque fois),
    les points correspondent à des tiles autour sur lesquelles on place une unité
    les "|" sont les séparateurs pour montrer les 4 tours.

    Si une tile ne peut pas prendre une unité de bionature (il y a une town dessus,
    ou déjà 16 bionature), le missile place l'unité sur la tile suivante dans le
    rayon d'action. Ça décale tout le pattern de dump, mais c'est pas grave.

    Un missile place donc 20 bionatures au total, sauf si toutes les tiles dans le
    rayon d'action sont déjà pleines. Dans ce cas les bionature en trop sont perdues.

    C'est assez rentable de lancer des missiles, car ils coûtent 10 unités de Player.
    10 unités -> 20 bionature, c'est plutôt pas mal.
    """

    # Délai (en nombre de tours) entre deux déplacements du missile,
    # sauf pour le premier déplacement où le délai peut être différent.
    DELAY_MOVE = 2
    # Coût de construction en unités.
    UNIT_COST = 10
    # Nombre de tours total pour construire le missile.
    # On fait avancer ce temps à chaque tour (que la construction ait avancée ou pas).
    # Si ce timeout est atteint, la construction est annulée et on remet
    # dans le suburb les unités qui ont été dépensées.
    TIMEOUT = UNIT_COST * 3

    # -- Les états successifs de la vie du missile. --
    # En construction
    BUILDING = 0
    # En train de se déplacer
    MOVING = 1
    # Définition des tiles dans lesquelles on peut placer la bionature
    DEFINING_DUMP_TILES = 2
    # Explosion, placement des bionatures.
    EXPLODING = 3
    # Fini, suppression du missile.
    FINISHED = 4

    # Listes de directions de déplacement, par rapport à la tile où le missile a explosé,
    # permettant de déduire les tiles où placer la bionature.
    # Les directions sont définies comme d'habitude : 0:haut, 2:droite, 4:bas, 6 gauche.
    # Certaines sous-listes sont vides, indiquant qu'il n'y a pas de déplacement à appliquer.
    # Dans ce cas, ça signifie qu'il faut placer une bionature directement
    # sur la tile d'explosion.
    # J'aime bien Black, mais quand il formate du code comme ça, je le trouve relou.
    DIRECTIONS_DUMP_TILES = (
        (),
        (0,),
        (2,),
        (6, 6),
        (4, 4),
        (),
        (6,),
        (4,),
        (2, 2),
        (0, 0),
        (),
        (0,),
        (2,),
        (0, 2),
        (6, 4),
        (),
        (6,),
        (4,),
        (0, 6),
        (2, 4),
    )

    # clé : taille de la town qui va générer le ou les missiles.
    # valeur : tuple de 2 elems.
    #  - portée du missile
    #  - sous-tuple. nombre de tour pour le delay initial des missiles.
    #    (Le nombre d'eléments de la liste indique le nombre de missiles à générer).
    #    Le délai initial est différent, car c'est plus amusant de voir des missiles
    #    partir les uns après les autres depuis une grosse ville,
    #    plutôt que tous en même temps.
    GEN_INFOS_FROM_TOWN_SIZE = {
        1: (WARZONE_HEIGHT // 2, (2,)),
        2: (WARZONE_HEIGHT // 1.5, (2, 6)),
        4: (WARZONE_HEIGHT, (2, 10, 14, 6)),
    }

    def __init__(
        self,
        player_owner,
        tile,
        duration,
        game_master,
        initial_delay_move=2,
        direction=None,
        player_to_spawn=None,
    ):
        # Player qui a généré le missile.
        self.player_owner = player_owner
        self.tile = tile
        # La portée du missile.
        self.duration = duration
        # Indique la prochaine tile sur laquelle on doit dumper une bionature.
        self.index_dump_tile = 0
        # Nombre d'unités de bionature à dumper.
        self.payload_qty = 20
        # Quantité que l'on dumpe à chaque tour.
        self.dumps_per_turn = 5
        self.game_master = game_master
        # Délai avant le premier déplacement.
        self.initial_delay_move = initial_delay_move
        # La direction du missile correspond à la direction de conquête diagonale
        # de Player qui le génère.
        self.direction = (
            self.player_owner.dir_forw_diag if direction is None else direction
        )
        # Indique la couleur des unités dumpées par le missile.
        # (C'est la bionature, mais on pourrait choisir autre chose si on veut).
        self.player_to_spawn = (
            self.game_master.player_bionature
            if player_to_spawn is None
            else player_to_spawn
        )
        self.suburb_owner = self.tile.suburb_owner
        if self.suburb_owner is None:
            raise Exception(
                "Construction d'un missile sur une zone sans suburb. Not supposed to happen."
            )
        # Directions de "glissement". Si le missile arrive sur un bord de l'écran,
        # il va se déplacer horizontalement ou verticalement le long du bord, pour
        # continuer d'aller le plus loin possible. Éventuellement jusqu'au coin
        # opposé de l'aire de jeu.
        self.slide_dir_1 = (self.direction + 1) % 8
        self.slide_dir_2 = (self.direction - 1) % 8
        # Progression de la construction en cours.
        self.build_step = 0
        # Temps restant pour la construction du missile, avant de l'annuler.
        self.time_before_timeout = Missile.TIMEOUT
        self.current_action = Missile.BUILDING
        self.gamobj = f"missile_build_{self.build_step:02}"

    def handle(self):
        """
        La fonction principale de gestion du missile.
        Elle appelle la bonne fonction selon l'état actuel du missile.
        """
        function_from_action = {
            Missile.BUILDING: self.build,
            Missile.MOVING: self.move,
            Missile.DEFINING_DUMP_TILES: self.define_dump_tiles,
            Missile.EXPLODING: self.dump_payload,
            Missile.FINISHED: self.finished,
        }
        function_from_action[self.current_action]()

    def build(self):
        """
        Fait avancer la construction du missile, en échange d'unités
        piochées dans le suburb où se trouve le missile.

        À chaque tour, on prend une unité de chaque tile du suburb, jusqu'à ce que
        la construction soit atteinte. Ça signifie que les grands suburbs construisent
        leurs missiles plus vite que les petits. Et c'est un fonctionnement plutôt logique.

        Si une tile de suburb n'a plus qu'une unité, on ne s'en sert pas pour construire
        le missile, car cela ferait perdre le contrôle de la tile.

        Si pas d'unité dispo dans le suburb, on n'avance pas la construction.
        Dans tous les cas, on avance le timeout. Si il est atteint,
        on remet les unités investies dans le suburb, le missile passe directement
        à l'état FINISHED et il n'est pas construit.
        """
        self.time_before_timeout -= 1
        # On enlève une unité pour chaque tile du suburb qui peut en donner une.
        # Chaque unité fait avancer la construction du missile.
        for suburb_tile in self.suburb_owner.real_suburb_tiles:
            if (
                suburb_tile.player_owner == self.player_owner
                and suburb_tile.nb_unit > 1
            ):
                suburb_tile.remove_unit(1)
                self.build_step += 1
                if self.build_step >= Missile.UNIT_COST:
                    # Construction terminée. On peut quitter la boucle.
                    # Plus besoin de prélever d'unités.
                    break

        if self.build_step < Missile.UNIT_COST:
            self.gamobj = f"missile_build_{self.build_step:02}"
        else:
            # Construction terminée, le missile passe dans l'état "déplacement",
            # avec tout de même son délai initial avant le premier déplacement.
            self.delay_move = self.initial_delay_move
            # Détermination du game object représentant le missile, en fonction
            # de sa direction de déplacement.
            # Je n'ai pas prévu de sprite pour des missiles qui se déplaceraient
            # en diagonale bas-droite ou en diagonale haut-gauche. Faites-les vous-même
            # si vous en avez besoin.
            self.gamobj = "missile_ur" if self.direction == 1 else "missile_dl"
            self.current_action = Missile.MOVING

        if not self.time_before_timeout:
            # Échec de la construction du missile.
            # On rend les unités investies, elles sont replacées dans le suburb.
            # On fait le bourrin, et on remet toutes les unités investies dans
            # une seule tile du suburb. Elles se répartiront automatiquement
            # durant les tours suivants, grâce à la gestion des suburbs.
            for suburb_tile in self.suburb_owner.real_suburb_tiles:
                if (
                    suburb_tile.player_owner != self.player_owner
                    or suburb_tile.nb_unit + self.build_step <= 16
                ):
                    suburb_tile.add_unit(self.player_owner, self.build_step)
                    break
            # Il est possible que l'on ait parcouru toutes les tiles, sans en trouver une
            # ayant suffisameunt peu d'unités pour pouvoir replacer toutes celles investies.
            # Dans ce cas, elles sont définitivement perdues.
            # Ce n'est pas censé arriver, car si il y a des unités dans le suburb, alors on aurait
            # pu avancer la construction du missile et on en serait pas arrivé à là.
            self.current_action = Missile.FINISHED

    def move(self):
        """
        Déplacement du missile, ou diminution du délai de déplacement.
        Passage à l'étape suivante (définition des tiles de dump) si on arrive
        sur une tile contrôlée par Player ennemie.
        Sinon, passage à l'étape suivante lorsque le missile a atteint sa portée.
        """
        self.delay_move -= 1
        if self.delay_move:
            # Pas de déplacement, mais on a diminué le délai actuel.
            # Il s'agit du délai initial ou bien du délai entre deux déplacements,
            # c'est géré pareil dans les deux cas.
            return

        if self.tile.player_owner is not None and self.tile.player_owner not in (
            self.player_owner,
            self.player_to_spawn,
        ):
            # Le missile survole une case appartenant à Player-ennemi.
            # (Plus précisément, pas Player-owner et pas Player-bionature,
            # donc forcément Player-ennemie).
            # On termine la durée de vie du missile pour exploser tout de suite. Ha ha !
            self.duration = 0

        if self.duration == 0:
            # Passage à l'étape suivante. C'est pas tout de suite l'explosion.
            # Il faut une petite étape intermédiaire, qui ne prend qu'un seul tour :
            # la détermination des tiles dans lesquelles on peut dumper de la bionature.
            self.current_action = Missile.DEFINING_DUMP_TILES
            self.gamobj = "missile_exploding"
            return

        # Si on est arrivé jusqu'ici, c'est qu'il faut déplacer le missile d'une case.
        # Rénitialisation du délai de déplacement, diminution de la durée de vie.
        self.delay_move = Missile.DELAY_MOVE
        self.duration -= 1
        # Déplacement en diagonale dans la direction de conquête, si on peut.
        # Sinon, déplacement horizontal ou vertical, toujours dans la direction de conquête,
        # le long d'un bord de l'écran.
        next_tile = self.tile.adjacencies[self.direction]
        if next_tile is None:
            next_tile = self.tile.adjacencies[self.slide_dir_1]
        if next_tile is None:
            next_tile = self.tile.adjacencies[self.slide_dir_2]
        if next_tile is None:
            # On n'a pas pu faire de déplacement du tout. Ça veut dire qu'on a atteint
            # le coin opposé de l'écran. Dans ce cas, ce n'est plus la peine de rester
            # dans l'état MOVING. On met la durée de vie à zéro, et dans quelques tours
            # le missile passera aux étapes suivantes.
            self.duration = 0
            return

        self.tile = next_tile

    def define_dump_tiles(self):
        """
        Petite étape de calcul nécessaire avant de dumper la bionature.
        On liste les tiles dans le rayon d'action du missile qui sont susceptibles
        de recevoir de la bionature.

        On vérifie juste que les tiles existent et qu'il n'y a pas de town dessus.
        On ne vérifie pas qu'il y ait moins de 16 unités de bionature dessus,
        parce que c'est quelque chose qui peut changer.
        """
        self.dump_tiles = []
        for direction_sequence in Missile.DIRECTIONS_DUMP_TILES:
            # On part à chaque fois de la tile du missile (là où il a explosé),
            # on se déplace dans les directions données autant de fois qu'il faut,
            # et ça donne une tile potentielle appartenant au rayon d'action du missile.
            cur_tile = self.tile
            for direction in direction_sequence:
                cur_tile = cur_tile.adjacencies[direction]
                if cur_tile is None:
                    break
            if cur_tile is not None and cur_tile.town is None:
                self.dump_tiles.append(cur_tile)

        if not self.dump_tiles:
            # Il n'y a aucune tile de dispo sur laquelle on pourrait poser de la bionature.
            # On enlève la payload. Au prochain tour, la fonction dump_payload
            # mettra automatiquement l'état en FINISHED.
            # Je ne met pas directement l'état en FINISHED, comme ça, le dessin du missile
            # qui explose reste un peu plus longtemps. Pour bien montrer que le missile était
            # quand même là, même si il n'a eu aucun effet.
            self.payload_qty = 0
        # Et on passe tout de suite à l'étape suivante. Cette étape ne dure qu'un tour.
        self.current_action = Missile.EXPLODING

    def dump_payload(self):
        """
        Balance 5 unités de bionature dans le rayon d'action du missile,
        là où on peut.

        Si il n'y a plus de place nul part pour mettre la bionature,
        on passera directement à l'étape suivante, les unités de bionature seront perdues.
        """
        if not self.payload_qty:
            # Y'a plus de payload. Soit on a tout dumpé, soit on n'a plus de place
            # pour dumper. On passe à la dernière étape.
            self.current_action = Missile.FINISHED
            return

        self.dumps_made = 0
        nb_times_resetted_index = 0
        while (
            self.dumps_made < self.dumps_per_turn
            and self.payload_qty
            and nb_times_resetted_index <= 2
        ):
            # On avance dans les self.dump_tiles. À chaque fois qu'on en trouve une de dispo
            # on y met une unité de bionature et on diminue la payload.
            # Si on dumpe la quantité prévue pour chaque tour, on s'arrête et on continuera
            # au tour suivant.
            # Si on arrive au bout de la liste de self.dump_tiles, on revient au début. Ça
            # permet de dumper toute la payload sur les tiles disponible.
            # Si on revient plusieurs fois au début de la liste dans le même tour, il y a eu
            # un problème, il n'y a plus de place, faudra annuler le dumping.
            dump_tile = self.dump_tiles[self.index_dump_tile]
            if dump_tile.town is None and (
                dump_tile.player_owner != self.player_to_spawn or dump_tile.nb_unit < 16
            ):
                # On a trouvé une tile de disponible. On dumpe une bionature dessus.
                dump_tile.add_unit(self.player_to_spawn)
                self.payload_qty -= 1
                self.dumps_made += 1

            self.index_dump_tile += 1
            if self.index_dump_tile >= len(self.dump_tiles):
                self.index_dump_tile = 0
                nb_times_resetted_index += 1
                if nb_times_resetted_index == 2 and self.dumps_made == 0:
                    # Ça fait deux fois qu'on repasse par l'index numéro 0.
                    # Ça veut dire qu'on a fait le tour du compteur (et même un peu plus)
                    # sans avoir réussi à placer une seule unité verte.
                    # C'est pas la peine d'essayer d'en replacer d'autres. Il n'y a plus
                    # de tile disponible (elles sont peut-être déjà toute remplie de vert).
                    # On annule la payload, , même si il en restait à dumper. Tant pis !
                    self.payload_qty = 0

    def finished(self):
        """
        Lorsque le missile est dans l'état FINISHED, il n'y a plus rien à faire.
        Le Game Master s'occupe de supprimer tous les missiles qui sont dans cet état.

        On est quand même obligé de définir une fonction pour ça, car il faut mettre
        quelque chose dans le dictionnaire de correspondance entre l'état du missile et
        la fonction à exécuter.
        J'aurais pu mettre une lambda à l'arrache qui ne fait rien. Mais je trouve ça
        un peu plus classe de définir une vraie fonction.
        """
        pass


class GameMaster:
    """
    Le maître du jeu. La classe qui dirige tout le bazar, qui contient les Players, l'aire de jeu,
    qui ordonnance les actions, etc.

    Le GameMaster gère aussi les suburbs (merge, équilibrage des unités), et les missiles,
    car ce sont des éléments neutres du jeu.
    """

    def __init__(self, w, h):
        self.w = w
        self.h = h
        # Tableau à 2 dimensions contenant des objets Tile
        self.game_area = []
        # Tableau à 2 dimensions contenant des game_objects (c'est à dire des listes de strings)
        # Lorsqu'on veut rafraîchir ce qui est affiché à l'écran, on prend des tiles
        # de game_area, on update leurs game_objects, et on les mets dans
        # les cases correspondantes de gamobjs_to_export.
        # De cette manière, on n'a pas besoin de recalculer les apparences de toutes les tiles
        # lorsqu'il faut redessiner l'aire de jeu à l'écran.
        self.gamobjs_to_export = []
        # Initialisation de ces deux tableaux.
        for y in range(self.h):
            line = []
            line_gamobjs = []
            for x in range(self.w):
                cell_gamobjs = []
                line_gamobjs.append(cell_gamobjs)
                tile = Tile(x, y, cell_gamobjs, self)
                line.append(tile)
            self.gamobjs_to_export.append(tuple(line_gamobjs))
            self.game_area.append(tuple(line))
        # On convertit tout en tuple. Parce qu'on ne change pas la disposition des éléments
        # dans les tableaux. On ne change que le contenu de chacun des éléments.
        self.game_area = tuple(self.game_area)
        self.gamobjs_to_export = tuple(self.gamobjs_to_export)

        # Définition des adjacences. Chaque objet Tile a une variable membre "adjacencies",
        # contenant des références vers les tiles adjacentes, selon les directions.
        for y in range(self.h):
            for x in range(self.w):
                adjacencies = self._make_adjacencies(x, y)
                self.game_area[y][x].adjacencies = adjacencies

        # Tous les objets Suburbs de l'aire de jeu.
        self.suburbs = []
        # On a besoin de ça pour savoir où vérifier les conquêtes de roads.
        # C'est assez rare qu'il y ait des routes inoccupées, mais quand c'est le cas,
        # faut boucler dessus pour voir si on peut y propager des unités.
        self.uncontrolled_roads = []
        # Les Players (rouge, bleu, bionature)
        self.players = None
        # Player spécifique qui gère la bionature (les pixels verts).
        self.player_bionature = None
        self.missiles = []

    def init_all_players(self, real_players, player_bionature):
        """
        real_players est une liste contenant tous les "vrais" PlayerHandlers,
        dirigés par des humains.
        player_bionature est un seul PlayerHandler, dirigé par le jeu.
        """
        # Initialisation des PlayerHandler.
        for player in real_players:
            player.init_first_units_and_town()
        self.init_bionature_units(player_bionature)
        self.players = real_players + [player_bionature]
        self.player_bionature = player_bionature

    def _make_adjacencies(self, x, y):
        """
        Renvoie les tiles adjacentes à la tile située aux coordonnées x, y.
        On renvoie toujours une liste de 8 éléments (les 8 directions), mais certains éléments
        peuvent être None, si les coordonnées x, y sont sur un bord de l'aire de jeu.
        """
        adjacencies = (
            self.game_area[y - 1][x] if 0 <= y - 1 else None,
            self.game_area[y - 1][x + 1] if 0 <= y - 1 and x + 1 < self.w else None,
            self.game_area[y][x + 1] if x + 1 < self.w else None,
            self.game_area[y + 1][x + 1] if y + 1 < self.h and x + 1 < self.w else None,
            self.game_area[y + 1][x] if y + 1 < self.h else None,
            self.game_area[y + 1][x - 1] if y + 1 < self.h and 0 <= x - 1 else None,
            self.game_area[y][x - 1] if 0 <= x - 1 else None,
            self.game_area[y - 1][x - 1] if 0 <= y - 1 and 0 <= x - 1 else None,
        )
        return adjacencies

    def conquest_neutral_roads(self):
        """
        Lorsqu'une tile de road n'a pas de owner, et qu'elle est connectée à une road adjacente,
        et que cette road est contrôlée par quelqu'un,
        alors on déplace automatiquement une unité dessus pour la conquérir.
        Si les tiles adjacentes sont contrôlées par plusieurs Players, on ne fait rien.
        """
        if not self.uncontrolled_roads:
            return

        # On fait une copie de la liste,
        # car elle risque de changer pendant qu'on boucle dessus.
        uncontrolled_roads_copy = list(self.uncontrolled_roads)
        for tile in uncontrolled_roads_copy:

            # Liste des tiles adjacentes qui pourraient conquérir cette tile non contrôlée.
            conqueror_tiles = []
            # Liste des Players qui pourraient conquérir cette tile.
            conqueror_players = set()

            if tile.road_vertic:
                for adj_tile in (tile.adjacencies[0], tile.adjacencies[4]):
                    if (
                        adj_tile is not None
                        and adj_tile.player_owner is not None
                        # Si Player a fait une magnetisation, il/elle ne conquiert
                        # pas les routes neutres, du moins, pas via cette fonction.
                        # Player va automatiquement conquérir les routes
                        # qui lui permettent d'accéder à sa tile magnetisée.
                        and adj_tile.player_owner.tile_magnet is None
                        and adj_tile.nb_unit > 1
                        and adj_tile.road_vertic
                    ):
                        conqueror_tiles.append(adj_tile)
                        conqueror_players.add(adj_tile.player_owner)

            if tile.road_horiz:
                for adj_tile in (tile.adjacencies[2], tile.adjacencies[6]):
                    if (
                        adj_tile is not None
                        and adj_tile.player_owner is not None
                        and adj_tile.player_owner.tile_magnet is None
                        and adj_tile.nb_unit > 1
                        and adj_tile.road_horiz
                    ):
                        conqueror_tiles.append(adj_tile)
                        conqueror_players.add(adj_tile.player_owner)

            # Si plusieurs Player peuvent conquérir la tile, on ne fait rien.
            if len(conqueror_players) == 1:
                # Player peut conquérir la tile. On prend la première tile adjacente
                # qui peut faire la conquête, et on déplace une unité, de la tile adjacente,
                # vers cette tile. Rien de plus à faire. L'équilibrage des unités entre
                # cette tile nouvellement conquise et les tiles adjacentes se fera tout
                # seul, au prochain tour, grâce à la fonction Player._spread_units_on_one_road.
                conqueror_tile = conqueror_tiles[0]
                conqueror_player = list(conqueror_players)[0]
                conqueror_tile.remove_unit()
                tile.add_unit(conqueror_player)

    def check_two_suburbs_merge(self, suburb_1, suburb_2):
        """
        Renvoie True ou False, selon que les deux suburbs passés en paramètre doivent être
        mergés, ou pas.

        On merge si la town d'un suburb se trouve sur n'importe quelle tile de l'autre suburb
        (potential tile, real tile, town tile).

        On merge aussi si les deux suburbs ont une real tile en commun.
        Ce cas arrive si on construit une route entre deux villes, qui merge les
        suburb de ces deux villes.
        """
        suburb_1_all_tiles = (
            suburb_1.town_tiles + suburb_1.real_suburb_tiles + suburb_1.potential_tiles
        )
        if not set(suburb_1_all_tiles).isdisjoint(set(suburb_2.town_tiles)):
            return True
        suburb_2_all_tiles = (
            suburb_2.town_tiles + suburb_2.real_suburb_tiles + suburb_2.potential_tiles
        )
        if not set(suburb_2_all_tiles).isdisjoint(set(suburb_1.town_tiles)):
            return True

        if not set(suburb_2.real_suburb_tiles).isdisjoint(
            set(suburb_1.real_suburb_tiles)
        ):
            return True
        return False

    def check_suburb_merging_by_list(self, many_suburbs):
        """
        Vérifie si tous les suburbs de la liste many_suburbs doivent être mergés en un seul
        gros suburb, ou pas. Si oui, effectue ces merges.

        Attention, cette fonction ne peut gérer que deux cas :
         - soit faut tout merger en un seul, et on le fait.
         - soit il ne faut merger aucun suburb entre eux, et on ne fait rien.

        Par exemple, si on passe une liste de suburbs [A, B, C, D], et qu'il faudrait merger
        A+B et C+D, mais pas A+B+C+D : la fonction ne va pas savoir gérer ça, et les
        actions effectuées seront plus ou moins n'importe quoi.

        Il faut donc faire attention à ce qu'on a mis dans many_suburbs.
        """
        # On trie les suburbs, du plus grand au plus petit.
        # Plus un suburb possède de "real_suburb_tiles", plus il est grand.
        # Comme ça, on merge le plus grand suburb avec les autres,
        # C'est plus rapide que de merger un petit suburb avec d'autres.
        many_suburbs.sort(
            key=lambda suburb: len(suburb.real_suburb_tiles), reverse=True
        )
        first_suburb = many_suburbs.pop(0)
        while many_suburbs:
            other_suburb = many_suburbs.pop(0)
            # À priori, il n'y aurait besoin de faire la vérification que entre les deux
            # premiers suburbs. Mais je préfère la faire à chaque fois.
            if self.check_two_suburbs_merge(first_suburb, other_suburb):
                first_suburb.merge(other_suburb)

    def check_suburb_merging_with_all_others(self, one_suburb):
        """
        Vérifie si il faut merger le suburb passé en paramètre, avec tous
        les autres suburb existants.
        L'ordre de vérif n'est pas important, car les merge sont transitifs.
        Si A doit être mergé avec B et D, mais pas avec C,
        on peut faire (A verif B), puis (A verif D), ou l'inverse. Ça reviendra au même.
        Dans cet exemple, B pourrait être mergé directement avec D, ou pas. Ça dépend de la
        disposition des suburbs. Mais on ne s'occupe pas de ces cas, car le but est uniquement
        de merger A avec le reste.
        """
        suburbs_to_merge = []
        # D'abord on vérifie tout ce qui doit être mergé.
        for other_suburb in self.suburbs:
            if one_suburb == other_suburb:
                continue
            # Une première vérif rapide, en utilisat les bounding rect.
            if bounding_rect_overlaps(
                one_suburb.bounding_rect, other_suburb.bounding_rect
            ):
                # Et ensuite la vraie vérif qui prend un peu plus de temps.
                if self.check_two_suburbs_merge(one_suburb, other_suburb):
                    suburbs_to_merge.append(other_suburb)

        # On merge tout ce qui doit être mergé.
        # En commençant par les plus grands, pour optimiser.
        suburbs_to_merge.sort(
            key=lambda suburb: len(suburb.real_suburb_tiles), reverse=True
        )
        for other_suburb in suburbs_to_merge:
            one_suburb.merge(other_suburb)

    def _equilibrate_units_in_one_suburb(self, suburb, turn_index):
        """
        Répartit toutes les unités qui sont présentes dans un même suburb,
        ou bien élimine des unités différentes si plusieurs Players ont des unités sur ce suburb.

        Quand on répartit les unités, on ne le fait que "ponctuellement". On prend la tile
        qui en a le plus et celle qui en a le moins, on calcule la différence,
        et on transfère la moitié de la différence de la plus peuplée à la moins peuplée.

        Ça ne fait pas une répartition parfaite. Mais au prochain tour de jeu, on refera
        la même petite action ponctuelle. Progressivement, ça finira par se répartir
        équitablement. Ça fait moins de traitement
        à exécuter à chaque tour, et ça montre à l'écran la répartition progressive.

        On applique la même idée de "progressivitude" lorsqu'il y a des unités
        de différentes couleurs. On n'en élimine que deux, une de chaque couleur.
        On élimine pas tout d'un coup. Ça finit par se nettoyer tout seul tour après tour.
        """
        # most_unequilibrateds est un dictionnaire enregistrant les tiles les plus déséquilibrées
        # (en nombre d'unités)
        # Clé : Player ayant des unités dans ce suburb.
        # Valeur : tuple de 2 éléments : tile avec le max d'unité, tile avec le min d'unité.
        # ça peut être deux fois la même si Player ne contrôle qu'une seule tile dans ce suburb.
        most_unequilibrateds = {}
        # Une tile du suburb contrôlée par personne. On prend la première qu'on trouve.
        # Ça peut rester None si toutes les tiles sont contrôlées.
        un_owned_tile = None
        func_get_unit = lambda tile: tile.nb_unit
        # Définition des variables most_unequilibrateds et un_owned_tile
        for tile in suburb.real_suburb_tiles:
            player_tile = tile.player_owner
            if player_tile is None:
                if un_owned_tile is None:
                    un_owned_tile = tile
            else:
                if player_tile not in most_unequilibrateds:
                    most_unequilibrateds[player_tile] = [tile, tile]
                else:
                    tile_unit_min, tile_unit_max = most_unequilibrateds[player_tile]
                    # Il y a peut-être plusieurs tile ayant le même max d'unités, et plusieurs
                    # tile ayant le même min. C'est pas important. On prend n'importe quel max
                    # et n'importe quel min.
                    most_unequilibrateds[player_tile] = [
                        min(tile_unit_min, tile, key=func_get_unit),
                        max(tile_unit_max, tile, key=func_get_unit),
                    ]
        if not most_unequilibrateds:
            # Il n'y a personne dans ce suburb ! (c'est rare). On ne fait rien.
            return

        if len(most_unequilibrateds) == 1:
            # Il n'y a qu'une seule personne dans ce suburb. On fait de la répartition d'unités,
            # si c'est nécessaire et possible.
            player_tile, tile_extrems = next(iter(most_unequilibrateds.items()))
            tile_unit_min, tile_unit_max = tile_extrems
            if tile_unit_max.nb_unit > 2:
                if un_owned_tile:
                    # Il y a une tile non contrôlée dans le suburb. C'est plus prioritaire
                    # de contrôler toutes les tiles que de se répartir dans celles
                    # qu'on contrôle. Donc on déplace une unité de la tile où on en a le plus,
                    # vers la tile non contrôlée.
                    # Il y a peut-être d'autres tiles non contrôlées,
                    # on s'en occupera au prochain tour.
                    tile_unit_max.remove_unit()
                    un_owned_tile.add_unit(player_tile)
                else:
                    # Toutes les tiles du suburb sont contrôlées par Player.
                    # On peut faire une répartition.
                    if (
                        player_tile.tile_magnet is not None
                        and player_tile.tile_magnet.suburb_owner == suburb
                    ):
                        # La tile magnétisée de Player est dans ce suburb, on ne répartit rien.
                        # Player veut rassembler toutes ses unités au même endroit,
                        # si on fait une répartition, ça va gêner ce rassemblement.
                        pass
                    else:
                        diff = tile_unit_max.nb_unit - tile_unit_min.nb_unit
                        if diff > 1:
                            # Maintenant qu'on a tout vérifié, et qu'on sait qu'une répartition
                            # est nécessaire, on peut vraiment la faire.
                            player_tile.move_unit_without_check(
                                tile_unit_max, tile_unit_min, diff // 2
                            )
        elif len(most_unequilibrateds) == 2:
            # Il y a plusieurs personnes dans ce suburb. On élimine une unité à chacune,
            # en les prenant à partir de leurs tiles ayant le maximum d'unité.
            tile_extrems = list(most_unequilibrateds.values())
            tile_extrems_1, tile_extrems_2 = tile_extrems
            tile_unit_max_1 = tile_extrems_1[1]
            tile_unit_max_2 = tile_extrems_2[1]
            tile_unit_max_1.remove_unit()
            tile_unit_max_2.remove_unit()
        else:
            # Il y a plus que 2 players, il faut déterminer équitablement quelles unités on élimine.
            # On prend 2 players dans la liste, à qui on élimine une unité.
            # Il faut choisir ces 2 Players de façons à ce que ce soit équitable :
            # on ne doit pas prendre les 2 mêmes à chaque tour.
            # Pour faire ça, on fait un espèce de round-robin basé sur le numéro de tour de jeu.
            id_and_tile_extrems = [
                (player.player_id, one_tile_extrems)
                for player, one_tile_extrems in most_unequilibrateds.items()
            ]
            tile_extrems = [
                one_tile_extrems
                for p_id, one_tile_extrems in sorted(id_and_tile_extrems)
            ]
            # Round-robin de la mort.
            turn_index_mod = turn_index % len(tile_extrems)
            select_index_1 = turn_index_mod
            select_index_2 = turn_index_mod % (len(tile_extrems) - 1)
            if select_index_2 >= select_index_1:
                select_index_2 += 1
            # C'est bon, on a round-robiné. Il n'y a plus qu'à prendre les tiles concernées
            # et leur enlever une unité à chacune.
            tile_extrems_1 = tile_extrems[select_index_1]
            tile_extrems_2 = tile_extrems[select_index_2]
            tile_unit_max_1 = tile_extrems_1[1]
            tile_unit_max_2 = tile_extrems_2[1]
            tile_unit_max_1.remove_unit()
            tile_unit_max_2.remove_unit()

    def equilibrate_units_in_suburbs(self, turn_index):
        """
        Équilibrage/élimination d'unités dans tous les suburbs de l'aire de jeu.
        """
        for suburb in self.suburbs:
            self._equilibrate_units_in_one_suburb(suburb, turn_index)

    def init_bionature_units(self, player_bionature):
        """
        Place les unités de la bionature dans l'aire de jeu, au début d'une partie.

        On place deux unités sur toutes les tiles de la diagonale qui va de haut-gauche à bas-droit,
        et une à quelques cases de distance de cette diagonale.
        On en place également à quelques cases de distance plus grande de cette diagonale.
        Pour que ça transitionne doucment de 0 vers 1 puis 1 vers 2 au fur et à mesure qu'on est
        proche de la diagonale.

        En plus de ça, on place quelques "épicentres" au hasard, à quelques cases de distance
        de cette diagonale. On peut avoir plusieurs épicentres sur une même tile.

        Ensuite, on détermine, pour chaque tile, un min et un max d'unités de bionature.
        Plus on est proche de la diagonale, et plus on est proche des épicentres, plus
        le min et le max augmente.
        Pour finir, on choisit au hasard le nombre d'unités de bionature entre ce min et ce max.
        """
        nb_epicentre = 15
        min_size = min(self.w, self.h)
        rand_epi = min_size // 5
        epicentres = []
        # Placement des épicentres.
        for _ in range(nb_epicentre):
            # D'abord on le place au hasard sur la diagonale.
            x_epi = random.randint(0, min_size)
            y_epi = x_epi
            # Et ensuite on le déplace un peu, avec du hasard.
            x_epi += random.randint(-rand_epi, rand_epi)
            y_epi += random.randint(-rand_epi, rand_epi)
            epicentres.append((x_epi, y_epi))

        for x in range(self.w):
            for y in range(self.h):

                # Détermination du min et du max initial, en fonction de la distance
                # par rapport à la diagonale.
                dist_main_diag = abs(x - y)
                min_unit = max(0, (3 - dist_main_diag / 2))
                max_unit = 10 - dist_main_diag * 3
                # Ajout de quantité en min et en max, en fonction des épicentres proches.
                epi_adds = [
                    20 - (x - x_epi) ** 2 - (y - y_epi) ** 2
                    for x_epi, y_epi in epicentres
                ]
                epi_adds = [val for val in epi_adds if val > 0]
                max_unit += sum(epi_adds)
                min_unit += len(epi_adds)
                # Augmentation du max en dernier recours, si la tile est proche de la diagonale
                # mais qu'on n'a pas eu de bol et qu'on n'a pas assez de min et max.
                if max_unit <= 0:
                    if dist_main_diag < 10:
                        max_unit = 2
                    elif dist_main_diag < 20:
                        max_unit = 1
                # Des fois, avec tous ces savants calcul, max_unit est plus petit que min_unit.
                # Dans ce cas, on redéfinit max_unit.
                max_unit = max(min_unit, max_unit)

                # Finalement, on choisit un nombre d'unité au hasard entre le min et le max,
                # et on pose ça sur la tile.
                if max_unit > 0:
                    nb_bionature_unit = random.randint(int(min_unit), int(max_unit))
                    if nb_bionature_unit > 16:
                        nb_bionature_unit = 16
                    tile = self.game_area[y][x]
                    if tile.town is None:
                        tile.add_unit(player_bionature, nb_bionature_unit)


class IhmMode:
    """
    Les différents états de l'IHM de Player.
    """

    # En train de sélectionner une option dans le menu principal
    MAIN_MENU = 0
    # Sélection d'une ville
    SELECT_TOWN = 1
    # Sélection d'un point de départ (adjacent à la ville sélectionnée)
    # et d'une direction, pour la prochaine conquest line.
    SELECT_CONQUEST_LINE = 2
    # Sélection de la longueur de la prochaine conquest line.
    SELECT_CONQUEST_DEST = 3
    # Activation d'une "backward conquest" à partir de la town sélectionnée.
    BACKWARD_CONQUEST = 4
    # En train de sélectionner une sous-option dans le sous-menu des annulations.
    SUBMENU_CANCEL = 5
    # Annulation du dernier ordre donné (conquest line ou backward conquest)
    CANCEL_CURRENT_ORDERS = 6
    # Activation du mode "dodo".
    SLEEP_MODE = 7
    # Lancement d'un ou plusieurs missiles à partir de la town sélectionnée.
    LAUNCH_MISSILE = 8


class PlayerInterface:
    """
    Interface Human-Machine permettant à un Player de jouer.
    Chaque PlayerHandler humain possède sa propre PlayerInterface.

    Cette classe s'occupe des choses suivantes :
     - Afficher les boutons sur un bord de l'aire de jeu,
       et du bouton actuellement sélectionné.
     - Afficher les éléments de sélection dans la warzone
       (highlight de la ville sélectionnée, choix de la conquest line,
       indicateur de backward conquest, ...).
     - Prendre en compte les ordres envoyés par Player. Il n'y a que
       deux ordres possibles :
        * changement du choix actuel (flèche gauche ou bouton "1"),
        * validation du choix actuel (flèche droite ou bouton "2").
    """

    # Définition des boutons de l'interface. Chaque élément est un sous-tuple de 4 élément :
    #  - nom de base des gamobjs permettant de dessiner le bouton.
    #    Il faudra préfixer par la couleur et suffixer par les coordonnée des fragments d'image,
    #    chaque bouton est représenté par un carré de 3x3 gamobjs.
    #  - position X du bouton, en "unités de bouton".
    #    une unité de bouton = 4 gamobjs (3 pour le bouton, 1 pour la marge).
    #  - position Y, en unités de bouton.
    #  - indication des liens.
    #    "R" : il faut dessiner un lien vers la droite.
    #    "D" : il faut dessiner un lien vers le bas.
    #    Les liens sont représentés par un simple gamobj carré de couleur gris foncé.
    BUTTON_DEFINITIONS = (
        ("ihm_btn_select", 0, 0, "D"),
        ("ihm_btn_conq", 0, 1, "DR"),
        ("ihm_btn_backw", 0, 2, "D"),
        ("ihm_btn_missile", 0, 3, "D"),
        ("ihm_btn_conqdir", 1, 1, "R"),
        ("ihm_btn_conqdist", 2, 1, ""),
        ("ihm_btn_noorder", 0, 4, "R"),
        ("ihm_btn_noorder", 1, 4, "D"),
        ("ihm_btn_sleep", 1, 5, ""),
    )

    # Dictionnaire indiquant le bouton à mettre en surbrillance, selon l'état d'ihm de Player.
    # clé : tuple de 2 éléments :
    #  - mode en cours (current_mode)
    #  - mode suivant (next_mode), ça correspond à peu près au mode
    #    qui s'activerait dans le cas où Player cliquerait sur le bouton de validation d'action.
    # valeur : un index dans la liste BUTTON_DEFINITIONS,
    #          correspondant au bouton à mettre en surbrillance.
    INDEX_LIT_BUTTONS = {
        (IhmMode.MAIN_MENU, IhmMode.SELECT_TOWN): 0,
        (IhmMode.SELECT_TOWN, IhmMode.SELECT_TOWN): 0,
        (IhmMode.MAIN_MENU, IhmMode.SELECT_CONQUEST_LINE): 1,
        (IhmMode.MAIN_MENU, IhmMode.BACKWARD_CONQUEST): 2,
        (IhmMode.MAIN_MENU, IhmMode.LAUNCH_MISSILE): 3,
        (IhmMode.MAIN_MENU, IhmMode.SUBMENU_CANCEL): 6,
        (IhmMode.SUBMENU_CANCEL, IhmMode.CANCEL_CURRENT_ORDERS): 7,
        (IhmMode.SUBMENU_CANCEL, IhmMode.SLEEP_MODE): 8,
        (IhmMode.SELECT_CONQUEST_LINE, IhmMode.SELECT_CONQUEST_DEST): 4,
        (IhmMode.SELECT_CONQUEST_DEST, IhmMode.MAIN_MENU): 5,
    }

    # dict. clé : taille de la town.
    # valeur : liste de tuple de 2 elems :
    #  - nom du gamobj à placer pour montrer que la town est sélectionnée.
    #  - index de la tile de town où placer ce gamobj.
    # Il faut préfixer le gamobj avec blu ou red, comme d'hab'.
    TOWN_SELECTORS = {
        1: (("select_town_1x1", 0),),
        2: (
            ("select_town_corner_ul", 0),
            ("select_town_corner_ur", 1),
            ("select_town_corner_dl", 2),
            ("select_town_corner_dr", 3),
        ),
        4: (
            ("select_town_corner_ul", 0),
            ("select_town_line_u", 1),
            ("select_town_line_u", 2),
            ("select_town_corner_ur", 3),
            ("select_town_line_l", 4),
            ("select_town_line_r", 7),
            ("select_town_line_l", 8),
            ("select_town_line_r", 11),
            ("select_town_corner_dl", 12),
            ("select_town_line_d", 13),
            ("select_town_line_d", 14),
            ("select_town_corner_dr", 15),
        ),
    }

    # Liste des game objects (à préfixer par la couleur) utilisés pour afficher
    # la barre indiquant le nombre de tile et de towns d'un player.
    # Cette barre s'étend à droite et à gauche au fur et à mesure que les quantités à
    # afficher augmentent.
    # Toutes les 8 quantités, on insère deux gamobjs de ligne pleine au milieu de la barre.
    # Cette liste indique les gamobjs à afficher en fonction de "quantité % 8".
    # Il y a donc 7 éléments. Chacun contient deux éléments :
    # le gamobj à afficher du côté gauche de la barre, et celui à afficher du côté droit.
    GAMOBJS_SUFFIX_BAR_EXTREMITIES = (
        ("", ""),
        ("", "rig_1"),
        ("lef_1", "rig_1"),
        ("lef_1", "rig_2"),
        ("lef_2", "rig_2"),
        ("lef_2", "rig_3"),
        ("lef_3", "rig_3"),
        ("lef_3", "full"),
    )

    # Ces noms permettent de générer les gamobjs d'ihm utilisés pour sélectionner
    # la direction d'une conquest line.
    DIRECTION_NAMES = ("up", "", "right", "", "down", "", "left", "")

    # Type des barre d'interface affichant le nombre de tile contrôlée et
    # le nombre de town en haut de l'aire de jeu.
    BAR_COUNT_TYPE_TILE = 0
    BAR_COUNT_TYPE_TOWN = 1

    def __init__(
        self,
        game_master,
        player_me,
        player_enemy,
        player_bionature,
        offset_btn_coords,
        ihm_right_side,
    ):
        # Le Game Master et tous les Player.
        self.game_master = game_master
        # Player géré par cette classe PlayerInterface
        self.player_me = player_me
        # L'autre Player, qui n'est pas géré par cette classe.
        self.player_enemy = player_enemy
        # Player qui gère la bionature.
        self.player_bionature = player_bionature
        # Position, en nombre de tile, du coin supérieur gauche dans l'aire de jeu,
        # indiquant où il faut dessiner les boutons de ce PlayerInterface.
        self.offset_btn_x, self.offset_btn_y = offset_btn_coords
        # Est-ce que les boutons d'interface sont à droite, ou pas.
        # (Ça change certains détails dans les affichages de certains éléments d'interface).
        self.ihm_right_side = ihm_right_side

        # "arrow_map" est un triangle affiché dans l'interface,
        # à côté du bouton de sélection d'une town.
        # Il est visible lorsque Player est en train de sélectionner une nouvele town.
        # Il permet d'indiquer aux personnes qui ne connaissent pas très bien le jeu
        # de déduire que dans cet état, c'est la warzone qu'il faut regarder,
        # et pas les boutons.
        # Cet arrow_map permet de différencier l'état où on est dans le menu
        # principal, avec le bouton "select_town" sélectionné, et l'état où en a activé
        # ce mode "select_town", et où on est en train de faire cycler les différentes
        # town que l'on possède.
        self.arrow_map_y = OFFSET_INTERFACE_Y + self.offset_btn_y + 2
        if self.ihm_right_side:
            self.arrow_map_x = OFFSET_INTERFACE_X + WARZONE_WIDTH
        else:
            self.arrow_map_x = OFFSET_INTERFACE_X - 1

        self.color = self.player_me.color
        # current_mode et next_mode permettent de savoir où on en est dans l'interface.
        self.current_mode = IhmMode.MAIN_MENU
        self.next_mode = IhmMode.SELECT_TOWN
        self.sleep_mode = False
        # Index de la town sélectionnée, dans la liste self.sorted_towns.
        self.index_selected_town = 0
        # Sauf qu'on n'a pas encore initialisée self.sorted_towns, alors
        # on prend la town sélectionnée directement à partir de Player.
        # De toutes façons au début du jeu il n'y a qu'une seule ville, on ne peut
        # pas se tromper.
        self.selected_town = self.player_me.active_towns[self.index_selected_town]

        # -- Toutes les variables ci-dessous servent à gérer la conquest line. --
        # Index, dans la liste des tiles adjacentes à la town sélectionnée,
        # de la tile sélectionnée pour faire la prochaine conquest line.
        self.index_conquest_start = 0
        # Tile adjacente à une town, indiquant le départ d'une conquest line.
        # Si pas de conquest line en cours, cette variable vaut None.
        self.tile_conquest_start = None
        # Les différentes conquest lines que l'on peut choisir à partir de
        # self.tile_conquest_start. En général il y en a 3. Une qui s'arrête
        # à la tile juste après, une 3 tiles plus loin et une 7 tiles plus loin.
        # Mais si il y a une autre town qui barre le chemin, on peut avoir
        # moins de conquest lines possibles.
        self.conquest_lines = None
        # Index dans self.conquest_lines de la conquest line sélectionnée
        self.index_conquest_line = 0
        # Direction de la conquest line.
        self.conquest_dir = None
        # Game object utilisé pour afficher le choix de conquest line dans la warzone.
        # Ce sont les traits pointillés orange ou cyan foncé.
        # Pour une couleur donnée, il y en a 2 possibles, selon que la conquest line
        # est horizontale ou verticale.
        self.gamobj_conquest_line = None
        # Les tiles d'arrivée des différentes conquest lines de self.conquest_lines.
        # On s'en sert pour afficher, dans la warzone, un petit carré orange ou cyan,
        # sur chacun d'elles.
        self.conquest_dest_pot_tiles = []
        # La conquest line en cours, une fois qu'elle a été entièrement sélectionnée
        # (direction et distance).
        self.current_conquest_line = None
        # Tile d'arrivée de la conquest line actuelle. On s'en sert pour afficher
        # un petit game object dans la warzone, pour indiquer où la conquest line
        # va s'arrêter
        self.tile_next_town = None

        # Indique si la liste des towns est "dirty". C'est à dire si il y a eu des changements
        # dans cette liste causée par le jeu (construction, merge, shatter).
        # Lorsque ça arrive, la classe PlayerHandler doit avertir PlayerInterface.
        # Car il y a des choses à faire : retrier la liste sorted_towns, vérifier que
        # la town sélectionnée existe toujours (elle a peut-être été mergée ou shatterée),
        # etc.
        self.is_town_list_dirty = True
        # Juste un pauvre booléen pour afficher une seule fois
        # le message d'explication dans la console, à propos du mode "dodo".
        self.must_tell_msg_sleep_mode = True
        # Liste des game objects utilisés pour afficher les deux barres de comptage
        # en haut de l'aire de jeu : nombre de tiles contrôlées, nombre de towns.
        self.bar_count_tiles = [""] * TOTAL_GAME_WIDTH
        self.bar_count_towns = [""] * TOTAL_GAME_WIDTH

        self.precalculate_ihm_gamobj_names()
        self.pre_render_ihm_btn()
        self.refresh_town_list()

    def iterate_for_button(self, array_gamobjs, corner_x, corner_y):
        """
        Juste une petite fonction pour itérer sur un carré de 3x3 tiles,
        à l'intérieur d'un array de tile plus grand.
        J'en ai besoin pour gérer l'affichage des boutons, qui ont tous cette taille.
        """
        index_tile = 0
        for offset_y in range(3):
            for offset_x in range(3):
                tile_current = array_gamobjs[corner_y + offset_y][corner_x + offset_x]
                yield index_tile, tile_current
                index_tile += 1

    def pre_render_ihm_btn(self):

        array_gamobjs = []
        for y in range(WARZONE_HEIGHT):
            line = []
            for x in range(OFFSET_INTERFACE_X):
                line.append([])
            array_gamobjs.append(line)

        for (name, btn_pos_x, btn_pos_y, link) in PlayerInterface.BUTTON_DEFINITIONS:
            iterator_button_tiles = self.iterate_for_button(
                array_gamobjs,
                self.offset_btn_x + btn_pos_x * 4,
                self.offset_btn_y + btn_pos_y * 4,
            )
            for index_tile, tile_current in iterator_button_tiles:
                gamobj = f"{self.color}_{name}_{index_tile:02d}"
                tile_current[:] = ["ihm_background", gamobj]
            if "D" in link:
                final_x = self.offset_btn_x + btn_pos_x * 4 + 1
                final_y = self.offset_btn_y + btn_pos_y * 4 + 3
                array_gamobjs[final_y][final_x] = ["ihm_background"]
            if "R" in link:
                final_x = self.offset_btn_x + btn_pos_x * 4 + 3
                final_y = self.offset_btn_y + btn_pos_y * 4 + 1
                array_gamobjs[final_y][final_x] = ["ihm_background"]

        if self.ihm_right_side:
            border_x = 0
            gamobj_border = "ihm_border_right"
        else:
            border_x = OFFSET_INTERFACE_X - 1
            gamobj_border = "ihm_border_left"

        for y in range(WARZONE_HEIGHT):
            array_gamobjs[y][border_x] = (gamobj_border,)

        # FUTURE : faudra une fonction toute faite pour tuplifier un array,
        # parce que là c'est dégueu ce que je fais.
        for y in range(WARZONE_HEIGHT):
            for x in range(OFFSET_INTERFACE_X):
                array_gamobjs[y][x] = tuple(array_gamobjs[y][x])
        array_gamobjs = [tuple(line) for line in array_gamobjs]
        self.array_gamobjs_ihm_btn = tuple(array_gamobjs)

    def refresh_town_list(self):
        self.is_town_list_dirty = False
        selected_tile = self.selected_town.tiles_position[0]
        self.sorted_towns = sorted(
            self.player_me.active_towns, key=lambda town: (town.y_up, town.x_left)
        )
        self.nb_towns = len(self.sorted_towns)
        if not self.nb_towns:
            # Cas stupide où on se retrouve avec 0 villes actives pendant un cycle de jeu,
            # parce que Player a commencé par créer une grosse ville.
            # On laisse tomber, et cette foncton sera rappelée plus tard.
            return

        # On retrouve la town qu'on a sélectionné (c'est pas forcément la même, si y'a eu des merge/shatter)
        # Et à partir de la town sélectionnée, on retrouve son index dans la liste.
        new_selected_town = selected_tile.town

        if new_selected_town is None:
            raise Exception("Perte de la sélection de town. Not supposed to happen.")

        try:
            self.index_selected_town = self.sorted_towns.index(new_selected_town)
        except ValueError:
            # Ça arrive si la town qu'on avait sélectionnée avant est devenue désactivée.
            # Dans ce cas on sait pas trop quoi faire, on reste sur une town désactivée et pis c'est tout.
            # On réglera ça plus tard, quand Player voudra lancer une action.
            return

        self.selected_town = new_selected_town

    def dirtify_town_list(self):
        self.is_town_list_dirty = True
        if self.selected_town not in self.player_me.active_towns:
            # La liste des towns a changée, et en plus, la town actuellement sélectionnée
            # n'est plus dans la liste des town active. Dans ce cas, on doit immédiatement changer
            # la town sélectionnée.
            # Dans le cas contraire, pas besoin de faire ça tout de suite. On le fera lorsque Player
            # voudra sélectionner une autre town.
            self.refresh_town_list()

    def precalculate_ihm_gamobj_names(self):
        self.gamobj_bar_base_town = self.color + "_ihm_count_town_"
        self.gamobj_bar_base_tile = self.color + "_ihm_count_tile_"
        self.gamobj_bar_full_town = self.color + "_ihm_count_town_full"
        self.gamobj_bar_full_tile = self.color + "_ihm_count_tile_full"
        self.gamobjs_conquest_dir = tuple(
            [
                self.color + "_ihm_conquest_" + suffix_conq_dir
                for suffix_conq_dir in PlayerInterface.DIRECTION_NAMES
            ]
        )

        self.gamobj_conquest_dst_pot = self.color + "_ihm_conquest_dst_pot"
        self.gamobj_selector = self.color + "_ihm_selector"
        self.gamobj_conquest_nxt_town = self.color + "_ihm_conquest_nxt_town"
        self.gamobj_lit_background = self.color + "_ihm_lit_background"
        self.gamobj_arrow_to_map_1 = self.color + "_ihm_arrow_to_map_1"
        self.gamobj_arrow_to_map_2 = self.color + "_ihm_arrow_to_map_2"
        self.gamobj_conquest_horiz = self.color + "_ihm_conquest_horiz"
        self.gamobj_conquest_vertic = self.color + "_ihm_conquest_vertic"

    def refresh_bar_count(self, quantity, bar_count_type):
        if bar_count_type == PlayerInterface.BAR_COUNT_TYPE_TILE:
            gamobj_bar_base = self.gamobj_bar_base_tile
            gamobj_bar_full = self.gamobj_bar_full_tile
        else:
            gamobj_bar_base = self.gamobj_bar_base_town
            gamobj_bar_full = self.gamobj_bar_full_town

        nb_pix_bar = quantity // BAR_COUNT_RATIO
        nb_full_gamobjs = (nb_pix_bar // 8) * 2
        margin_left = (TOTAL_GAME_WIDTH - nb_full_gamobjs) // 2
        margin_right = TOTAL_GAME_WIDTH - nb_full_gamobjs - margin_left
        bar_count = (
            [""] * margin_left
            + [gamobj_bar_full] * nb_full_gamobjs
            + [""] * margin_right
        )
        nb_pix_remains = nb_pix_bar - nb_full_gamobjs * 4
        if nb_pix_remains >= len(PlayerInterface.GAMOBJS_SUFFIX_BAR_EXTREMITIES):
            # Not supposed to happen, mais on sait jamais.
            nb_pix_remains = len(PlayerInterface.GAMOBJS_SUFFIX_BAR_EXTREMITIES)
        gamobjs = PlayerInterface.GAMOBJS_SUFFIX_BAR_EXTREMITIES[nb_pix_remains]
        gamobj_left, gamobj_right = gamobjs
        if gamobj_left:
            gamobj_left = gamobj_bar_base + gamobj_left
            bar_count[margin_left - 1] = gamobj_left
        if gamobj_right:
            gamobj_right = gamobj_bar_base + gamobj_right
            bar_count[margin_left + nb_full_gamobjs] = gamobj_right
        return bar_count

    def add_interface_gamobjs(
        self, array_gamobjs, must_refresh_bar_count, show_selected_town
    ):
        if show_selected_town:
            town_selector_infos = PlayerInterface.TOWN_SELECTORS[
                self.selected_town.size
            ]
            for gamobj, index_tile in town_selector_infos:
                tile = self.selected_town.tiles_position[index_tile]
                tile_from_coords(array_gamobjs, tile).append(self.color + "_" + gamobj)

        if self.tile_conquest_start is not None:
            gamobj_conq_dir = self.gamobjs_conquest_dir[self.conquest_dir]
            tile_from_coords(array_gamobjs, self.tile_conquest_start).append(
                gamobj_conq_dir
            )
        for tile in self.conquest_dest_pot_tiles:
            tile_from_coords(array_gamobjs, tile).append(self.gamobj_conquest_dst_pot)
        if self.current_conquest_line:
            for tile in self.current_conquest_line[:-1]:
                tile_from_coords(array_gamobjs, tile).append(self.gamobj_conquest_line)
            last_tile = self.current_conquest_line[-1]
            tile_from_coords(array_gamobjs, last_tile).append(self.gamobj_selector)
        if self.tile_next_town is not None:
            if self.tile_next_town.town is not None:
                self.tile_next_town = None
            else:
                tile_from_coords(array_gamobjs, self.tile_next_town).append(
                    self.gamobj_conquest_nxt_town
                )

        x_lit_upleft, y_lit_upleft = self._get_lit_coordinates()
        x_lit_upleft += self.ihm_right_side * (WARZONE_WIDTH + OFFSET_INTERFACE_X)
        iterator_button_tiles = self.iterate_for_button(
            array_gamobjs, x_lit_upleft, y_lit_upleft
        )
        for _, tile_current in iterator_button_tiles:
            tile_current[0] = self.gamobj_lit_background

        show_cancel = (
            (
                self.current_mode == IhmMode.SELECT_CONQUEST_LINE
                and self.index_conquest_start is None
            )
            or (
                self.current_mode == IhmMode.SELECT_CONQUEST_DEST
                and self.index_conquest_line is None
            )
            or (self.sleep_mode)
        )

        if show_cancel:
            iterator_button_tiles = self.iterate_for_button(
                array_gamobjs, x_lit_upleft, y_lit_upleft
            )
            for index_tile, tile_current in iterator_button_tiles:
                tile_current[1] = f"{self.color}_ihm_btn_cancel_{index_tile:02d}"

        show_arrow_to_map = self.current_mode in (
            IhmMode.SELECT_TOWN,
            IhmMode.SELECT_CONQUEST_LINE,
            IhmMode.SELECT_CONQUEST_DEST,
        )
        if show_arrow_to_map:
            array_gamobjs[self.arrow_map_y][self.arrow_map_x].append(
                self.gamobj_arrow_to_map_1
            )
            array_gamobjs[self.arrow_map_y + 1][self.arrow_map_x].append(
                self.gamobj_arrow_to_map_2
            )

        if self.player_me.tile_magnet is not None:
            tile = self.player_me.tile_magnet
            tile_from_coords(array_gamobjs, tile).append(self.player_me.gamobj_magnet)
        if self.player_me.tile_go_backward is not None:
            tile = self.player_me.tile_go_backward
            tile_from_coords(array_gamobjs, tile).append(self.player_me.gamobj_go_back)

        if must_refresh_bar_count:
            tiles_quantity = len(self.player_me._controlled_tiles)
            self.bar_count_tiles = self.refresh_bar_count(
                tiles_quantity, PlayerInterface.BAR_COUNT_TYPE_TILE
            )
            towns_quantity = sum(
                (TOWN_NB_TILES[town.size] for town in self.player_me.towns)
            )
            self.bar_count_towns = self.refresh_bar_count(
                towns_quantity, PlayerInterface.BAR_COUNT_TYPE_TOWN
            )
        for x, (bar_gamobj_tile, bar_gamobj_town) in enumerate(
            zip(self.bar_count_tiles, self.bar_count_towns)
        ):
            if bar_gamobj_tile:
                array_gamobjs[0][x].append(bar_gamobj_tile)
            if bar_gamobj_town:
                array_gamobjs[0][x].append(bar_gamobj_town)

    def launch_missiles(self, town_launcher=None):
        if town_launcher is None:
            town_launcher = self.selected_town
        # On vérifie que y'a pas déjà des missiles en construction pour cette town.
        tiles_gen_missile = town_launcher.tiles_gen_missile
        for missile in self.game_master.missiles:
            if (
                missile.player_owner == self.player_me
                and missile.current_action == Missile.BUILDING
                and missile.tile in tiles_gen_missile
            ):
                # Il y a un missile en construction. On laisse tomber.
                return

        duration, missile_delays = Missile.GEN_INFOS_FROM_TOWN_SIZE[town_launcher.size]
        for tile, delay in zip(tiles_gen_missile, missile_delays):
            missile = Missile(self.player_me, tile, duration, self.game_master, delay)
            self.game_master.missiles.append(missile)

    def retrieve_conquest_direction(self):
        """
        Fonction un peu dégueulasse : on doit retrouver la direction de conquête en fonction de la town
        et de la tile de démarrage de conquête. Et on est obligé de faire une boucle pourrie que pour ça.
        J'aurais vraiment pu arranger ça mieux, mais zut.
        """
        for tile in self.selected_town.tiles_position:
            dirs = directions_from_pos(tile, self.tile_conquest_start)
            if len(dirs) == 1:
                return dirs[0]
        else:
            raise Exception("Impossible de trouver la conquest dir. Blargh.")

    def on_change_action(self):

        if self.sleep_mode:
            self.current_mode = IhmMode.MAIN_MENU
            self.next_mode = IhmMode.SELECT_TOWN
            self.sleep_mode = False

        elif self.current_mode == IhmMode.MAIN_MENU:
            next_modes = {
                IhmMode.SELECT_TOWN: (IhmMode.SELECT_CONQUEST_LINE),
                IhmMode.SELECT_CONQUEST_LINE: (IhmMode.BACKWARD_CONQUEST),
                IhmMode.BACKWARD_CONQUEST: (IhmMode.LAUNCH_MISSILE),
                IhmMode.LAUNCH_MISSILE: (IhmMode.SUBMENU_CANCEL),
                IhmMode.SUBMENU_CANCEL: (IhmMode.SELECT_TOWN),
            }
            next_next_mode = next_modes[self.next_mode]
            self.next_mode = next_next_mode

        elif self.current_mode == IhmMode.SELECT_TOWN:
            if self.is_town_list_dirty:
                self.refresh_town_list()
            self.index_selected_town += 1
            if self.index_selected_town >= self.nb_towns:
                self.index_selected_town = 0
            self.selected_town = self.sorted_towns[self.index_selected_town]

        elif self.current_mode == IhmMode.SELECT_CONQUEST_LINE:
            # On parcourt town.unit_gen_tiles : c'est la liste des tiles adjacentes de la town,
            # qui sont libres (c'est à dire que y'a pas une autre town dessus).
            conquest_tiles = self.selected_town.unit_gen_tiles
            if not conquest_tiles:
                # Cas particulier stupide, où une town s'est construite juste à côté de
                # la town sélectionnée, ce qui supprime la dernière tile libre de la town.
                # Dans ce cas, on déselectionne tout et on se barre.
                # Player doit obligatoirement annuler sa conquête.
                # Lorsque ce cas arrive, le jeu ne plante pas, mais on se retrouve dans
                # une situation d'IHM un peu dégueux. Osef, c'est un cas trop particulier
                # pour que je m'embête à le gérer correctement jusqu'au bout.
                self.index_conquest_start = None
                return

            if self.index_conquest_start is None:
                self.index_conquest_start = 0
            else:
                self.index_conquest_start += 1
                if self.index_conquest_start >= len(conquest_tiles):
                    self.index_conquest_start = None

            self.tile_conquest_start = (
                None
                if self.index_conquest_start is None
                else conquest_tiles[self.index_conquest_start]
            )
            if self.tile_conquest_start is None:
                self.conquest_dir = None
            else:
                self.conquest_dir = self.retrieve_conquest_direction()

        elif self.current_mode == IhmMode.SELECT_CONQUEST_DEST:
            if self.index_conquest_line is None:
                self.index_conquest_line = 0
            else:
                self.index_conquest_line += 1
                if self.index_conquest_line >= len(self.conquest_lines):
                    self.index_conquest_line = None

            self.current_conquest_line = (
                None
                if self.index_conquest_line is None
                else self.conquest_lines[self.index_conquest_line]
            )

        elif self.current_mode == IhmMode.SUBMENU_CANCEL:
            next_modes = {
                IhmMode.CANCEL_CURRENT_ORDERS: IhmMode.SLEEP_MODE,
                IhmMode.SLEEP_MODE: IhmMode.CANCEL_CURRENT_ORDERS,
            }
            next_next_mode = next_modes[self.next_mode]
            self.next_mode = next_next_mode

    def cancel_orders_and_interface(self):
        self.player_me.cancel_all_orders()
        self.tile_next_town = None
        self.current_conquest_line = []

    def on_activate_action(self):

        # Si on est sur une town désactivée, on se remet à la town 0.
        # Le cas peut arriver, car on refreshe pas forcément la sélection lors des constructions de towns.
        # C'est bourrin, mais osef.
        if self.selected_town is None or not self.selected_town.is_active:
            self.refresh_town_list()
            if not self.sorted_towns:
                self.current_mode = IhmMode.SUBMENU_CANCEL
                self.next_mode = IhmMode.SLEEP_MODE
                self.sleep_mode = True
                if self.must_tell_msg_sleep_mode:
                    text = COLOR_NAME[self.color] + " : plus aucune ville active."
                    print(text)
                    print("Activation du 'mode dodo'.")
                    self.must_tell_msg_sleep_mode = False
            else:
                self.index_selected_town = 0
                self.selected_town = self.sorted_towns[self.index_selected_town]
            return

        if self.current_mode == IhmMode.MAIN_MENU:
            self.tile_conquest_start = None
            self.current_mode = self.next_mode

            if self.current_mode == IhmMode.SELECT_CONQUEST_LINE:
                self.next_mode = IhmMode.SELECT_CONQUEST_DEST
                self.index_conquest_start = 0
                conquest_tiles = self.selected_town.unit_gen_tiles
                self.tile_conquest_start = conquest_tiles[self.index_conquest_start]
                self.conquest_dir = self.retrieve_conquest_direction()
            elif self.current_mode == IhmMode.BACKWARD_CONQUEST:
                self.cancel_orders_and_interface()
                self.current_mode = IhmMode.MAIN_MENU
                self.next_mode = IhmMode.SELECT_TOWN
                self.player_me.set_town_backward_conquest(self.selected_town)
            elif self.current_mode == IhmMode.LAUNCH_MISSILE:
                self.cancel_orders_and_interface()
                self.current_mode = IhmMode.MAIN_MENU
                self.next_mode = IhmMode.LAUNCH_MISSILE
                self.launch_missiles()
            elif self.current_mode == IhmMode.SUBMENU_CANCEL:
                self.next_mode = IhmMode.CANCEL_CURRENT_ORDERS

        elif self.current_mode == IhmMode.SELECT_TOWN:
            self.tile_conquest_start = None
            self.current_mode = IhmMode.MAIN_MENU

        elif self.current_mode == IhmMode.SELECT_CONQUEST_LINE:
            if self.tile_conquest_start is None:
                self.current_mode = IhmMode.MAIN_MENU
                self.next_mode = IhmMode.SELECT_CONQUEST_LINE
            else:
                self.conquest_lines = []
                self.conquest_dest_pot_tiles = []
                current_tile = self.tile_conquest_start
                current_conquest_line = []
                current_conquest_line.append(current_tile)
                for conquest_distance in range(8):

                    next_tile = current_tile.adjacencies[self.conquest_dir]
                    must_stop_lining = next_tile is None or next_tile.town is not None

                    if conquest_distance in (0, 3, 7) or must_stop_lining:
                        self.conquest_dest_pot_tiles.append(current_tile)
                        self.conquest_lines.append(list(current_conquest_line))
                        if must_stop_lining:
                            break

                    current_tile = next_tile
                    current_conquest_line.append(current_tile)

                if not self.conquest_lines:
                    raise Exception("conquest line empty. Not supposed to happen")
                self.tile_conquest_start = None
                self.conquest_lines = self.conquest_lines[::-1]
                self.index_conquest_line = 0
                self.current_conquest_line = self.conquest_lines[
                    self.index_conquest_line
                ]
                self.tile_conquest_start = None
                self.current_mode = IhmMode.SELECT_CONQUEST_DEST
                self.next_mode = IhmMode.MAIN_MENU
                # Détermination de la direction vertic/horiz des routes.
                self.gamobj_conquest_line = (
                    self.gamobj_conquest_horiz
                    if self.conquest_dir in (2, 6)
                    else self.gamobj_conquest_vertic
                )

        elif self.current_mode == IhmMode.SELECT_CONQUEST_DEST:
            self.conquest_dest_pot_tiles = []
            if self.index_conquest_line is None:
                self.current_mode = IhmMode.MAIN_MENU
                self.next_mode = IhmMode.SELECT_CONQUEST_LINE
            else:
                self.player_me.cancel_all_orders()
                self.player_me.tiles_to_roadify.extend(self.current_conquest_line)
                self.player_me.tile_to_townify = self.current_conquest_line[-1]
                self.tile_next_town = self.current_conquest_line[-1]
                self.player_me.is_roadify_horiz = self.conquest_dir in (2, 6)
                self.current_conquest_line = []
                self.current_mode = IhmMode.MAIN_MENU
                self.next_mode = IhmMode.SELECT_CONQUEST_LINE

        elif self.current_mode == IhmMode.SUBMENU_CANCEL:
            if self.next_mode == IhmMode.CANCEL_CURRENT_ORDERS:
                self.cancel_orders_and_interface()
                self.current_mode = IhmMode.MAIN_MENU
                self.next_mode = IhmMode.SELECT_TOWN
            else:
                self.sleep_mode = not self.sleep_mode
                if self.sleep_mode:
                    self.cancel_orders_and_interface()

    def _get_lit_coordinates(self):
        mode_infos = (self.current_mode, self.next_mode)
        if mode_infos not in PlayerInterface.INDEX_LIT_BUTTONS:
            raise Exception(f"Fail mode_infos {mode_infos}")
        index_lit_button = PlayerInterface.INDEX_LIT_BUTTONS[mode_infos]
        btn_pos_x, btn_pos_y = PlayerInterface.BUTTON_DEFINITIONS[index_lit_button][1:3]
        final_x = self.offset_btn_x + btn_pos_x * 4
        final_y = self.offset_btn_y + btn_pos_y * 4 + OFFSET_INTERFACE_Y
        return final_x, final_y


SANDBOX_MODES = [
    "switch to play mode",
    "add red unit",
    "add blu unit",
    "add horiz road",
    "add vertic road",
    "add town",
    "red magnet",
    "blu magnet",
    "backward conquest",
    "add grn unit",
    "conquest up",
    "conquest right",
    "conquest down",
    "conquest left",
    "missiles",
    "describe",
]

# Utile uniquement pour le mode sandbox.
def coord_move(x, y, direction):
    if direction == "R":
        x += 1
    elif direction == "L":
        x -= 1
    if direction == "D":
        y += 1
    if direction == "U":
        y -= 1
    return (x, y)


class GameModel:
    """
    Pour l'instant, pas de doc précise concernant cette classe.
    """

    JSON_PROCESS_TURN_SLOW = (
        """ { "delayed_actions": [ {"name": "process_turn", "delay_ms": 200} ] } """
    )
    JSON_PROCESS_TURN_FAST = (
        """ { "delayed_actions": [ {"name": "process_turn", "delay_ms": 10} ] } """
    )

    def __init__(self):
        self.w = WARZONE_WIDTH
        self.h = WARZONE_HEIGHT
        self.nb_warzone_tiles = WARZONE_WIDTH * WARZONE_HEIGHT

        self.game_master = GameMaster(self.w, self.h)
        self.player_red = PlayerHandler(
            0, self.w, self.h, "red", self.game_master, rightward=True, downward=False
        )
        self.player_blu = PlayerHandler(
            1, self.w, self.h, "blu", self.game_master, rightward=False, downward=True
        )
        self.player_bionature = PlayerHandler(
            2, self.w, self.h, "grn", self.game_master, None, None, is_bionature=True
        )
        self.game_master.init_all_players(
            [self.player_red, self.player_blu], self.player_bionature
        )
        self.must_start = True
        self.player_interface_red = PlayerInterface(
            self.game_master,
            self.player_red,
            self.player_blu,
            self.player_bionature,
            (0, 5),
            False,
        )
        self.player_red.set_player_interface(self.player_interface_red)
        self.player_interface_blu = PlayerInterface(
            self.game_master,
            self.player_blu,
            self.player_red,
            self.player_bionature,
            (1, 5),
            True,
        )
        self.player_blu.set_player_interface(self.player_interface_blu)

        self.sandboxing = AUTHORIZE_SANDBOX_MODE
        self.can_write_sandboxing_msg = True
        self.sandbox_action = False
        self.x_cursor = 0
        self.y_cursor = 0
        self.sandbox_mode_index = 1
        self.turn_index = 0

        # La deuxième ligne de tile de l'aire de jeu ne change jamais,
        # donc on la précalcule.
        self.tiles_line_interface_up = []
        for _ in range(OFFSET_INTERFACE_X):
            self.tiles_line_interface_up.append([])
        for _ in range(WARZONE_WIDTH):
            self.tiles_line_interface_up.append(["ihm_border_up"])
        for _ in range(OFFSET_INTERFACE_X):
            self.tiles_line_interface_up.append([])
        self.tiles_line_interface_up = tuple(self.tiles_line_interface_up)

        self.ihm_function_from_event_name = {
            "U": self.try_activate_sandbox_mode,
            "L": self.player_interface_red.on_change_action,
            "R": self.player_interface_red.on_activate_action,
            "action_1": self.player_interface_blu.on_change_action,
            "action_2": self.player_interface_blu.on_activate_action,
        }

        if self.sandboxing:
            print("Sandbox activé.")
            print("Déplacez votre curseur avec les flèches.")
            print("Changez de mode avec '1'.")
            print("Activez l'action avec '2'.")
            print("Mode actuel du sandbox :", SANDBOX_MODES[self.sandbox_mode_index])
        else:
            print("Appuyez sur un bouton pour démarrer.")

    def export_all_tiles(self):
        gamobjs_source = self.game_master.gamobjs_to_export
        gamobjs_copy = []
        for _ in range(OFFSET_INTERFACE_Y - 1):
            line = [[] for _ in range(TOTAL_GAME_WIDTH)]
            gamobjs_copy.append(line)
        gamobjs_copy.append(self.tiles_line_interface_up)
        for line_ihm_red, line_source, line_ihm_blu in zip(
            self.player_interface_red.array_gamobjs_ihm_btn,
            gamobjs_source,
            self.player_interface_blu.array_gamobjs_ihm_btn,
        ):
            line = [
                list(gamobjs) for gamobjs in line_ihm_red + line_source + line_ihm_blu
            ]
            gamobjs_copy.append(line)

        for missile in self.game_master.missiles:
            tile = missile.tile
            tile_from_coords(gamobjs_copy, tile).append(missile.gamobj)
        if self.sandboxing:
            # J'ai pas de tile pour gérer le sandbox_cursor,
            # du coup je suis obligé de mettre des offests dégueux. On dira qu'on l'a pas vu.
            final_x = self.x_cursor + OFFSET_INTERFACE_X
            final_y = self.y_cursor + OFFSET_INTERFACE_Y
            gamobjs_copy[final_y][final_x].append("sandbox_cursor")

        refresh_bar_count = self.turn_index % 10 == 0
        all_sleeping = (
            self.player_interface_red.sleep_mode
            and self.player_interface_blu.sleep_mode
        )
        self.player_interface_red.add_interface_gamobjs(
            gamobjs_copy, refresh_bar_count, not all_sleeping
        )
        self.player_interface_blu.add_interface_gamobjs(
            gamobjs_copy, refresh_bar_count, not all_sleeping
        )
        return gamobjs_copy

    def _conquest(self, tile_target, direc):
        if tile_target.town is None:
            return
        player = tile_target.player_owner
        player.cancel_all_orders()
        cur_tile = tile_target
        add_a_town = True
        for _ in range(7):
            next_tile = cur_tile.adjacencies[direc]
            if next_tile is None:
                add_a_town = False
                break
            if next_tile.town is not None:
                if next_tile.player_owner == player:
                    add_a_town = False
                break
            player.tiles_to_roadify.append(next_tile)
            cur_tile = next_tile
        if add_a_town and cur_tile is not None and cur_tile.town is None:
            player.tile_to_townify = cur_tile
        player.is_roadify_horiz = direc in (2, 6)

    def on_process_turn(self):
        if self.sandbox_action:
            sandbox_mode = SANDBOX_MODES[self.sandbox_mode_index]
            tile_target = self.game_master.game_area[self.y_cursor][self.x_cursor]
            if sandbox_mode == "add red unit":
                if tile_target.town is None:
                    tile_target.add_unit(self.player_red, 1)
            elif sandbox_mode == "add blu unit":
                if tile_target.town is None:
                    tile_target.add_unit(self.player_blu, 1)
            elif sandbox_mode == "add horiz road":
                if tile_target.town is not None:
                    print("Pas de route sur une town")
                else:
                    tile_target.add_road(horiz=True)
            elif sandbox_mode == "add vertic road":
                if tile_target.town is not None:
                    print("Pas de route sur une town")
                else:
                    tile_target.add_road(vertic=True)
            elif sandbox_mode == "add town":
                if tile_target.player_owner is None or tile_target.town is not None:
                    print("On ne peut construire que sur une case sans ville,")
                    print("et occupée par 16 pixels.")
                else:
                    if tile_target.player_owner.tile_building_town is not None:
                        print("Ville déjà en construction pour cette couleur.")
                    else:
                        tile_target.player_owner.tile_building_town = tile_target
            elif sandbox_mode == "red magnet":
                self.player_red.cancel_all_orders()
                if self.player_red.tile_magnet == tile_target:
                    self.player_red.tile_magnet = None
                else:
                    self.player_red.tile_magnet = tile_target
            elif sandbox_mode == "blu magnet":
                self.player_blu.cancel_all_orders()
                if self.player_blu.tile_magnet == tile_target:
                    self.player_blu.tile_magnet = None
                else:
                    self.player_blu.tile_magnet = tile_target
            elif sandbox_mode == "backward conquest":
                if tile_target.town is None:
                    print("Il faut sélectionner une ville pour le backward conquest")
                else:
                    player = tile_target.player_owner
                    player.cancel_all_orders()
                    player.set_town_backward_conquest(tile_target.town)
            elif sandbox_mode == "add grn unit":
                if tile_target.town is None:
                    tile_target.add_unit(self.player_bionature, 1)
            elif sandbox_mode == "conquest up":
                self._conquest(tile_target, 0)
            elif sandbox_mode == "conquest right":
                self._conquest(tile_target, 2)
            elif sandbox_mode == "conquest down":
                self._conquest(tile_target, 4)
            elif sandbox_mode == "conquest left":
                self._conquest(tile_target, 6)
            elif sandbox_mode == "missiles":
                if tile_target.town is None:
                    print("Il faut sélectionner une ville pour lancer des missiles.")
                else:
                    if tile_target.town.player_owner == self.player_red:
                        self.player_interface_red.launch_missiles(tile_target.town)
                    if tile_target.town.player_owner == self.player_blu:
                        self.player_interface_blu.launch_missiles(tile_target.town)
            elif sandbox_mode == "describe":
                print("-----")
                print(tile_target)
                print("red can generate units", self.player_red.can_generate_unit())
                print("blu can generate units", self.player_blu.can_generate_unit())

            elif sandbox_mode == "switch to play mode":
                print("Mode 'interface de jeu'")
                print("-" * 10)
                print("Appuyez sur la flèche du haut")
                print("pour revenir au mode sandbox")
                print("-" * 10)
                self.sandboxing = False

            self.sandbox_action = False

        self.game_master.conquest_neutral_roads()
        self.game_master.equilibrate_units_in_suburbs(self.turn_index)

        all_sleeping = (
            self.player_interface_red.sleep_mode
            and self.player_interface_blu.sleep_mode
        )

        for player in self.game_master.players:
            if not player.is_bionature:
                can_generate_unit = player.can_generate_unit()
                player.move_magnetized_units_on_suburb()
                player.process_town_building()
                player.move_units_on_roads(self.turn_index)
                player.move_units_on_bare_tiles(self.turn_index)
                player.process_backward_conquest(self.turn_index)
                if can_generate_unit:
                    player.process_unit_generation_town()
                player.process_town_merging()
                if can_generate_unit:
                    player.process_unit_gen_tile()
                player.process_line_conquest()
                if all_sleeping:
                    player.auto_build_towns()
            else:
                player.process_unit_gen_tile_bionature(self.turn_index)

        missiles_to_remove = []

        for missile in self.game_master.missiles:
            missile.handle()
            if missile.current_action == Missile.FINISHED:
                missiles_to_remove.append(missile)
        for missile_to_rem in missiles_to_remove:
            self.game_master.missiles.remove(missile_to_rem)

        self.turn_index += 1

        if self.turn_index & 127:
            # On contrôle si toutes les towns sont désactivées, et qu'il n'y a aucun
            # merge/shatter de town en cours.
            # Si oui, ça veut dire que plus aucune town ne peut lancer de conquête,
            # et donc ça veut dire que toutes les tiles de l'aire de jeu sont des towns.
            # Dans ce cas, on arrête la génération de units pour tout le monde, et on affiche le score final.
            if (
                self.player_red.town_merge_state == TOWN_MERGE_STATE_STABLE
                and self.player_blu.town_merge_state == TOWN_MERGE_STATE_STABLE
                and not self.player_red.active_towns
                and not self.player_blu.active_towns
            ):
                nb_tiles_red = len(self.player_red._controlled_tiles)
                nb_tiles_blu = len(self.player_blu._controlled_tiles)
                print("-" * 10)
                print(f"Rouge : {nb_tiles_red}. Bleue : {nb_tiles_blu}")
                if nb_tiles_red == nb_tiles_blu:
                    print("Égalité")
                else:
                    if nb_tiles_red > nb_tiles_blu:
                        win = COLOR_NAME["red"]
                    else:
                        win = COLOR_NAME["blu"]
                    print(f"La population {win} a gagné.")
                print("-" * 10)
                return None
        # FUTURE : calculer approximativement un délai plus ou moins long selon la quantité de trucs à gérer.
        # Plus on a eu à gérer de trucs durant ce tour, plus on met un délai court.
        # Mais c'est super chaud à estimer, ou alors faudrait regarder avec la date courante à chaque fois,
        # et je préfère m'occuper de ça plus tard (ou jamais).
        if all_sleeping:
            return GameModel.JSON_PROCESS_TURN_FAST
        else:
            return GameModel.JSON_PROCESS_TURN_SLOW

    def try_activate_sandbox_mode(self):
        if AUTHORIZE_SANDBOX_MODE:
            print("Mode 'sandbox'.")
            self.sandboxing = True
        elif self.can_write_sandboxing_msg:
            print("Vous pouvez activer un mode 'sandbox',")
            print("en modifiant une ligne dans le code source.")
            print("(Le texte affiché à gauche).")
            print("Lisez le début du code source pour plus d'infos.")
            self.can_write_sandboxing_msg = False

    def on_game_event(self, event_name):

        if event_name == "process_turn":
            return self.on_process_turn()
        if self.must_start:
            self.must_start = False
            print("C'est parti !!")
            return GameModel.JSON_PROCESS_TURN_FAST

        if self.sandboxing:

            if event_name == "action_1":
                self.sandbox_mode_index += 1
                if self.sandbox_mode_index >= len(SANDBOX_MODES):
                    self.sandbox_mode_index = 0
                print("mode actuel :", SANDBOX_MODES[self.sandbox_mode_index])
                return
            if event_name == "action_2":
                self.sandbox_action = True
                return
            if event_name in "URDL":
                x_cursor_new, y_cursor_new = coord_move(
                    self.x_cursor, self.y_cursor, event_name
                )
                if 0 <= x_cursor_new < self.w and 0 <= y_cursor_new < self.h:
                    self.x_cursor, self.y_cursor = x_cursor_new, y_cursor_new
                return

        else:

            function_to_call = self.ihm_function_from_event_name[event_name]
            function_to_call()
